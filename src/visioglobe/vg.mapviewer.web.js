/* Visioglobe SDK Copyright 2014 */
/* without requirejs */
var vg;
vg = (function (vg) {

 /* with requirejs (uncomment next line, comment two lines above)
 * make changes at the footer as well
 */
//define("visioweb",["jquery"],function(jQuery){
// Capture jQuery/$, do not interfere with client's jQuery
    var oldJQuery = window.jQuery, oldDollar = window.$; // #7187
    var jQuery, $;
    /*! jQuery v1.11.3 | (c) 2005, 2015 jQuery Foundation, Inc. | jquery.org/license */
    !function (a, b) {
        "object" == typeof module && "object" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function (a) {
            if (!a.document) throw new Error("jQuery requires a window with a document");
            return b(a)
        } : b(a)
    }("undefined" != typeof window ? window : this, function (a, b) {
        var c = [], d = c.slice, e = c.concat, f = c.push, g = c.indexOf, h = {}, i = h.toString, j = h.hasOwnProperty,
            k = {}, l = "1.11.3", m = function (a, b) {
                return new m.fn.init(a, b)
            }, n = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, o = /^-ms-/, p = /-([\da-z])/gi, q = function (a, b) {
                return b.toUpperCase()
            };
        m.fn = m.prototype = {
            jquery: l, constructor: m, selector: "", length: 0, toArray: function () {
                return d.call(this)
            }, get: function (a) {
                return null != a ? 0 > a ? this[a + this.length] : this[a] : d.call(this)
            }, pushStack: function (a) {
                var b = m.merge(this.constructor(), a);
                return b.prevObject = this, b.context = this.context, b
            }, each: function (a, b) {
                return m.each(this, a, b)
            }, map: function (a) {
                return this.pushStack(m.map(this, function (b, c) {
                    return a.call(b, c, b)
                }))
            }, slice: function () {
                return this.pushStack(d.apply(this, arguments))
            }, first: function () {
                return this.eq(0)
            }, last: function () {
                return this.eq(-1)
            }, eq: function (a) {
                var b = this.length, c = +a + (0 > a ? b : 0);
                return this.pushStack(c >= 0 && b > c ? [this[c]] : [])
            }, end: function () {
                return this.prevObject || this.constructor(null)
            }, push: f, sort: c.sort, splice: c.splice
        }, m.extend = m.fn.extend = function () {
            var a, b, c, d, e, f, g = arguments[0] || {}, h = 1, i = arguments.length, j = !1;
            for ("boolean" == typeof g && (j = g, g = arguments[h] || {}, h++), "object" == typeof g || m.isFunction(g) || (g = {}), h === i && (g = this, h--); i > h; h++) if (null != (e = arguments[h])) for (d in e) a = g[d], c = e[d], g !== c && (j && c && (m.isPlainObject(c) || (b = m.isArray(c))) ? (b ? (b = !1, f = a && m.isArray(a) ? a : []) : f = a && m.isPlainObject(a) ? a : {}, g[d] = m.extend(j, f, c)) : void 0 !== c && (g[d] = c));
            return g
        }, m.extend({
            expando: "jQuery" + (l + Math.random()).replace(/\D/g, ""), isReady: !0, error: function (a) {
                throw new Error(a)
            }, noop: function () {
            }, isFunction: function (a) {
                return "function" === m.type(a)
            }, isArray: Array.isArray || function (a) {
                return "array" === m.type(a)
            }, isWindow: function (a) {
                return null != a && a == a.window
            }, isNumeric: function (a) {
                return !m.isArray(a) && a - parseFloat(a) + 1 >= 0
            }, isEmptyObject: function (a) {
                var b;
                for (b in a) return !1;
                return !0
            }, isPlainObject: function (a) {
                var b;
                if (!a || "object" !== m.type(a) || a.nodeType || m.isWindow(a)) return !1;
                try {
                    if (a.constructor && !j.call(a, "constructor") && !j.call(a.constructor.prototype, "isPrototypeOf")) return !1
                } catch (c) {
                    return !1
                }
                if (k.ownLast) for (b in a) return j.call(a, b);
                for (b in a) ;
                return void 0 === b || j.call(a, b)
            }, type: function (a) {
                return null == a ? a + "" : "object" == typeof a || "function" == typeof a ? h[i.call(a)] || "object" : typeof a
            }, globalEval: function (b) {
                b && m.trim(b) && (a.execScript || function (b) {
                    a.eval.call(a, b)
                })(b)
            }, camelCase: function (a) {
                return a.replace(o, "ms-").replace(p, q)
            }, nodeName: function (a, b) {
                return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase()
            }, each: function (a, b, c) {
                var d, e = 0, f = a.length, g = r(a);
                if (c) {
                    if (g) {
                        for (; f > e; e++) if (d = b.apply(a[e], c), d === !1) break
                    } else for (e in a) if (d = b.apply(a[e], c), d === !1) break
                } else if (g) {
                    for (; f > e; e++) if (d = b.call(a[e], e, a[e]), d === !1) break
                } else for (e in a) if (d = b.call(a[e], e, a[e]), d === !1) break;
                return a
            }, trim: function (a) {
                return null == a ? "" : (a + "").replace(n, "")
            }, makeArray: function (a, b) {
                var c = b || [];
                return null != a && (r(Object(a)) ? m.merge(c, "string" == typeof a ? [a] : a) : f.call(c, a)), c
            }, inArray: function (a, b, c) {
                var d;
                if (b) {
                    if (g) return g.call(b, a, c);
                    for (d = b.length, c = c ? 0 > c ? Math.max(0, d + c) : c : 0; d > c; c++) if (c in b && b[c] === a) return c
                }
                return -1
            }, merge: function (a, b) {
                var c = +b.length, d = 0, e = a.length;
                while (c > d) a[e++] = b[d++];
                if (c !== c) while (void 0 !== b[d]) a[e++] = b[d++];
                return a.length = e, a
            }, grep: function (a, b, c) {
                for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++) d = !b(a[f], f), d !== h && e.push(a[f]);
                return e
            }, map: function (a, b, c) {
                var d, f = 0, g = a.length, h = r(a), i = [];
                if (h) for (; g > f; f++) d = b(a[f], f, c), null != d && i.push(d); else for (f in a) d = b(a[f], f, c), null != d && i.push(d);
                return e.apply([], i)
            }, guid: 1, proxy: function (a, b) {
                var c, e, f;
                return "string" == typeof b && (f = a[b], b = a, a = f), m.isFunction(a) ? (c = d.call(arguments, 2), e = function () {
                    return a.apply(b || this, c.concat(d.call(arguments)))
                }, e.guid = a.guid = a.guid || m.guid++, e) : void 0
            }, now: function () {
                return +new Date
            }, support: k
        }), m.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function (a, b) {
            h["[object " + b + "]"] = b.toLowerCase()
        });

        function r(a) {
            var b = "length" in a && a.length, c = m.type(a);
            return "function" === c || m.isWindow(a) ? !1 : 1 === a.nodeType && b ? !0 : "array" === c || 0 === b || "number" == typeof b && b > 0 && b - 1 in a
        }

        var s = function (a) {
            var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = "sizzle" + 1 * new Date, v = a.document,
                w = 0, x = 0, y = ha(), z = ha(), A = ha(), B = function (a, b) {
                    return a === b && (l = !0), 0
                }, C = 1 << 31, D = {}.hasOwnProperty, E = [], F = E.pop, G = E.push, H = E.push, I = E.slice,
                J = function (a, b) {
                    for (var c = 0, d = a.length; d > c; c++) if (a[c] === b) return c;
                    return -1
                },
                K = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
                L = "[\\x20\\t\\r\\n\\f]", M = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", N = M.replace("w", "w#"),
                O = "\\[" + L + "*(" + M + ")(?:" + L + "*([*^$|!~]?=)" + L + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + N + "))|)" + L + "*\\]",
                P = ":(" + M + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + O + ")*)|.*)\\)|)",
                Q = new RegExp(L + "+", "g"), R = new RegExp("^" + L + "+|((?:^|[^\\\\])(?:\\\\.)*)" + L + "+$", "g"),
                S = new RegExp("^" + L + "*," + L + "*"), T = new RegExp("^" + L + "*([>+~]|" + L + ")" + L + "*"),
                U = new RegExp("=" + L + "*([^\\]'\"]*?)" + L + "*\\]", "g"), V = new RegExp(P),
                W = new RegExp("^" + N + "$"), X = {
                    ID: new RegExp("^#(" + M + ")"),
                    CLASS: new RegExp("^\\.(" + M + ")"),
                    TAG: new RegExp("^(" + M.replace("w", "w*") + ")"),
                    ATTR: new RegExp("^" + O),
                    PSEUDO: new RegExp("^" + P),
                    CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + L + "*(even|odd|(([+-]|)(\\d*)n|)" + L + "*(?:([+-]|)" + L + "*(\\d+)|))" + L + "*\\)|)", "i"),
                    bool: new RegExp("^(?:" + K + ")$", "i"),
                    needsContext: new RegExp("^" + L + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + L + "*((?:-\\d)?\\d*)" + L + "*\\)|)(?=[^-]|$)", "i")
                }, Y = /^(?:input|select|textarea|button)$/i, Z = /^h\d$/i, $ = /^[^{]+\{\s*\[native \w/,
                _ = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, aa = /[+~]/, ba = /'|\\/g,
                ca = new RegExp("\\\\([\\da-f]{1,6}" + L + "?|(" + L + ")|.)", "ig"), da = function (a, b, c) {
                    var d = "0x" + b - 65536;
                    return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320)
                }, ea = function () {
                    m()
                };
            try {
                H.apply(E = I.call(v.childNodes), v.childNodes), E[v.childNodes.length].nodeType
            } catch (fa) {
                H = {
                    apply: E.length ? function (a, b) {
                        G.apply(a, I.call(b))
                    } : function (a, b) {
                        var c = a.length, d = 0;
                        while (a[c++] = b[d++]) ;
                        a.length = c - 1
                    }
                }
            }

            function ga(a, b, d, e) {
                var f, h, j, k, l, o, r, s, w, x;
                if ((b ? b.ownerDocument || b : v) !== n && m(b), b = b || n, d = d || [], k = b.nodeType, "string" != typeof a || !a || 1 !== k && 9 !== k && 11 !== k) return d;
                if (!e && p) {
                    if (11 !== k && (f = _.exec(a))) if (j = f[1]) {
                        if (9 === k) {
                            if (h = b.getElementById(j), !h || !h.parentNode) return d;
                            if (h.id === j) return d.push(h), d
                        } else if (b.ownerDocument && (h = b.ownerDocument.getElementById(j)) && t(b, h) && h.id === j) return d.push(h), d
                    } else {
                        if (f[2]) return H.apply(d, b.getElementsByTagName(a)), d;
                        if ((j = f[3]) && c.getElementsByClassName) return H.apply(d, b.getElementsByClassName(j)), d
                    }
                    if (c.qsa && (!q || !q.test(a))) {
                        if (s = r = u, w = b, x = 1 !== k && a, 1 === k && "object" !== b.nodeName.toLowerCase()) {
                            o = g(a), (r = b.getAttribute("id")) ? s = r.replace(ba, "\\$&") : b.setAttribute("id", s), s = "[id='" + s + "'] ", l = o.length;
                            while (l--) o[l] = s + ra(o[l]);
                            w = aa.test(a) && pa(b.parentNode) || b, x = o.join(",")
                        }
                        if (x) try {
                            return H.apply(d, w.querySelectorAll(x)), d
                        } catch (y) {
                        } finally {
                            r || b.removeAttribute("id")
                        }
                    }
                }
                return i(a.replace(R, "$1"), b, d, e)
            }

            function ha() {
                var a = [];

                function b(c, e) {
                    return a.push(c + " ") > d.cacheLength && delete b[a.shift()], b[c + " "] = e
                }

                return b
            }

            function ia(a) {
                return a[u] = !0, a
            }

            function ja(a) {
                var b = n.createElement("div");
                try {
                    return !!a(b)
                } catch (c) {
                    return !1
                } finally {
                    b.parentNode && b.parentNode.removeChild(b), b = null
                }
            }

            function ka(a, b) {
                var c = a.split("|"), e = a.length;
                while (e--) d.attrHandle[c[e]] = b
            }

            function la(a, b) {
                var c = b && a,
                    d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || C) - (~a.sourceIndex || C);
                if (d) return d;
                if (c) while (c = c.nextSibling) if (c === b) return -1;
                return a ? 1 : -1
            }

            function ma(a) {
                return function (b) {
                    var c = b.nodeName.toLowerCase();
                    return "input" === c && b.type === a
                }
            }

            function na(a) {
                return function (b) {
                    var c = b.nodeName.toLowerCase();
                    return ("input" === c || "button" === c) && b.type === a
                }
            }

            function oa(a) {
                return ia(function (b) {
                    return b = +b, ia(function (c, d) {
                        var e, f = a([], c.length, b), g = f.length;
                        while (g--) c[e = f[g]] && (c[e] = !(d[e] = c[e]))
                    })
                })
            }

            function pa(a) {
                return a && "undefined" != typeof a.getElementsByTagName && a
            }

            c = ga.support = {}, f = ga.isXML = function (a) {
                var b = a && (a.ownerDocument || a).documentElement;
                return b ? "HTML" !== b.nodeName : !1
            }, m = ga.setDocument = function (a) {
                var b, e, g = a ? a.ownerDocument || a : v;
                return g !== n && 9 === g.nodeType && g.documentElement ? (n = g, o = g.documentElement, e = g.defaultView, e && e !== e.top && (e.addEventListener ? e.addEventListener("unload", ea, !1) : e.attachEvent && e.attachEvent("onunload", ea)), p = !f(g), c.attributes = ja(function (a) {
                    return a.className = "i", !a.getAttribute("className")
                }), c.getElementsByTagName = ja(function (a) {
                    return a.appendChild(g.createComment("")), !a.getElementsByTagName("*").length
                }), c.getElementsByClassName = $.test(g.getElementsByClassName), c.getById = ja(function (a) {
                    return o.appendChild(a).id = u, !g.getElementsByName || !g.getElementsByName(u).length
                }), c.getById ? (d.find.ID = function (a, b) {
                    if ("undefined" != typeof b.getElementById && p) {
                        var c = b.getElementById(a);
                        return c && c.parentNode ? [c] : []
                    }
                }, d.filter.ID = function (a) {
                    var b = a.replace(ca, da);
                    return function (a) {
                        return a.getAttribute("id") === b
                    }
                }) : (delete d.find.ID, d.filter.ID = function (a) {
                    var b = a.replace(ca, da);
                    return function (a) {
                        var c = "undefined" != typeof a.getAttributeNode && a.getAttributeNode("id");
                        return c && c.value === b
                    }
                }), d.find.TAG = c.getElementsByTagName ? function (a, b) {
                    return "undefined" != typeof b.getElementsByTagName ? b.getElementsByTagName(a) : c.qsa ? b.querySelectorAll(a) : void 0
                } : function (a, b) {
                    var c, d = [], e = 0, f = b.getElementsByTagName(a);
                    if ("*" === a) {
                        while (c = f[e++]) 1 === c.nodeType && d.push(c);
                        return d
                    }
                    return f
                }, d.find.CLASS = c.getElementsByClassName && function (a, b) {
                    return p ? b.getElementsByClassName(a) : void 0
                }, r = [], q = [], (c.qsa = $.test(g.querySelectorAll)) && (ja(function (a) {
                    o.appendChild(a).innerHTML = "<a id='" + u + "'></a><select id='" + u + "-\f]' msallowcapture=''><option selected=''></option></select>", a.querySelectorAll("[msallowcapture^='']").length && q.push("[*^$]=" + L + "*(?:''|\"\")"), a.querySelectorAll("[selected]").length || q.push("\\[" + L + "*(?:value|" + K + ")"), a.querySelectorAll("[id~=" + u + "-]").length || q.push("~="), a.querySelectorAll(":checked").length || q.push(":checked"), a.querySelectorAll("a#" + u + "+*").length || q.push(".#.+[+~]")
                }), ja(function (a) {
                    var b = g.createElement("input");
                    b.setAttribute("type", "hidden"), a.appendChild(b).setAttribute("name", "D"), a.querySelectorAll("[name=d]").length && q.push("name" + L + "*[*^$|!~]?="), a.querySelectorAll(":enabled").length || q.push(":enabled", ":disabled"), a.querySelectorAll("*,:x"), q.push(",.*:")
                })), (c.matchesSelector = $.test(s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ja(function (a) {
                    c.disconnectedMatch = s.call(a, "div"), s.call(a, "[s!='']:x"), r.push("!=", P)
                }), q = q.length && new RegExp(q.join("|")), r = r.length && new RegExp(r.join("|")), b = $.test(o.compareDocumentPosition), t = b || $.test(o.contains) ? function (a, b) {
                    var c = 9 === a.nodeType ? a.documentElement : a, d = b && b.parentNode;
                    return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)))
                } : function (a, b) {
                    if (b) while (b = b.parentNode) if (b === a) return !0;
                    return !1
                }, B = b ? function (a, b) {
                    if (a === b) return l = !0, 0;
                    var d = !a.compareDocumentPosition - !b.compareDocumentPosition;
                    return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === g || a.ownerDocument === v && t(v, a) ? -1 : b === g || b.ownerDocument === v && t(v, b) ? 1 : k ? J(k, a) - J(k, b) : 0 : 4 & d ? -1 : 1)
                } : function (a, b) {
                    if (a === b) return l = !0, 0;
                    var c, d = 0, e = a.parentNode, f = b.parentNode, h = [a], i = [b];
                    if (!e || !f) return a === g ? -1 : b === g ? 1 : e ? -1 : f ? 1 : k ? J(k, a) - J(k, b) : 0;
                    if (e === f) return la(a, b);
                    c = a;
                    while (c = c.parentNode) h.unshift(c);
                    c = b;
                    while (c = c.parentNode) i.unshift(c);
                    while (h[d] === i[d]) d++;
                    return d ? la(h[d], i[d]) : h[d] === v ? -1 : i[d] === v ? 1 : 0
                }, g) : n
            }, ga.matches = function (a, b) {
                return ga(a, null, null, b)
            }, ga.matchesSelector = function (a, b) {
                if ((a.ownerDocument || a) !== n && m(a), b = b.replace(U, "='$1']"), !(!c.matchesSelector || !p || r && r.test(b) || q && q.test(b))) try {
                    var d = s.call(a, b);
                    if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d
                } catch (e) {
                }
                return ga(b, n, null, [a]).length > 0
            }, ga.contains = function (a, b) {
                return (a.ownerDocument || a) !== n && m(a), t(a, b)
            }, ga.attr = function (a, b) {
                (a.ownerDocument || a) !== n && m(a);
                var e = d.attrHandle[b.toLowerCase()],
                    f = e && D.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0;
                return void 0 !== f ? f : c.attributes || !p ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null
            }, ga.error = function (a) {
                throw new Error("Syntax error, unrecognized expression: " + a)
            }, ga.uniqueSort = function (a) {
                var b, d = [], e = 0, f = 0;
                if (l = !c.detectDuplicates, k = !c.sortStable && a.slice(0), a.sort(B), l) {
                    while (b = a[f++]) b === a[f] && (e = d.push(f));
                    while (e--) a.splice(d[e], 1)
                }
                return k = null, a
            }, e = ga.getText = function (a) {
                var b, c = "", d = 0, f = a.nodeType;
                if (f) {
                    if (1 === f || 9 === f || 11 === f) {
                        if ("string" == typeof a.textContent) return a.textContent;
                        for (a = a.firstChild; a; a = a.nextSibling) c += e(a)
                    } else if (3 === f || 4 === f) return a.nodeValue
                } else while (b = a[d++]) c += e(b);
                return c
            }, d = ga.selectors = {
                cacheLength: 50,
                createPseudo: ia,
                match: X,
                attrHandle: {},
                find: {},
                relative: {
                    ">": {dir: "parentNode", first: !0},
                    " ": {dir: "parentNode"},
                    "+": {dir: "previousSibling", first: !0},
                    "~": {dir: "previousSibling"}
                },
                preFilter: {
                    ATTR: function (a) {
                        return a[1] = a[1].replace(ca, da), a[3] = (a[3] || a[4] || a[5] || "").replace(ca, da), "~=" === a[2] && (a[3] = " " + a[3] + " "), a.slice(0, 4)
                    }, CHILD: function (a) {
                        return a[1] = a[1].toLowerCase(), "nth" === a[1].slice(0, 3) ? (a[3] || ga.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ("even" === a[3] || "odd" === a[3])), a[5] = +(a[7] + a[8] || "odd" === a[3])) : a[3] && ga.error(a[0]), a
                    }, PSEUDO: function (a) {
                        var b, c = !a[6] && a[2];
                        return X.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || "" : c && V.test(c) && (b = g(c, !0)) && (b = c.indexOf(")", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3))
                    }
                },
                filter: {
                    TAG: function (a) {
                        var b = a.replace(ca, da).toLowerCase();
                        return "*" === a ? function () {
                            return !0
                        } : function (a) {
                            return a.nodeName && a.nodeName.toLowerCase() === b
                        }
                    }, CLASS: function (a) {
                        var b = y[a + " "];
                        return b || (b = new RegExp("(^|" + L + ")" + a + "(" + L + "|$)")) && y(a, function (a) {
                            return b.test("string" == typeof a.className && a.className || "undefined" != typeof a.getAttribute && a.getAttribute("class") || "")
                        })
                    }, ATTR: function (a, b, c) {
                        return function (d) {
                            var e = ga.attr(d, a);
                            return null == e ? "!=" === b : b ? (e += "", "=" === b ? e === c : "!=" === b ? e !== c : "^=" === b ? c && 0 === e.indexOf(c) : "*=" === b ? c && e.indexOf(c) > -1 : "$=" === b ? c && e.slice(-c.length) === c : "~=" === b ? (" " + e.replace(Q, " ") + " ").indexOf(c) > -1 : "|=" === b ? e === c || e.slice(0, c.length + 1) === c + "-" : !1) : !0
                        }
                    }, CHILD: function (a, b, c, d, e) {
                        var f = "nth" !== a.slice(0, 3), g = "last" !== a.slice(-4), h = "of-type" === b;
                        return 1 === d && 0 === e ? function (a) {
                            return !!a.parentNode
                        } : function (b, c, i) {
                            var j, k, l, m, n, o, p = f !== g ? "nextSibling" : "previousSibling", q = b.parentNode,
                                r = h && b.nodeName.toLowerCase(), s = !i && !h;
                            if (q) {
                                if (f) {
                                    while (p) {
                                        l = b;
                                        while (l = l[p]) if (h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) return !1;
                                        o = p = "only" === a && !o && "nextSibling"
                                    }
                                    return !0
                                }
                                if (o = [g ? q.firstChild : q.lastChild], g && s) {
                                    k = q[u] || (q[u] = {}), j = k[a] || [], n = j[0] === w && j[1], m = j[0] === w && j[2], l = n && q.childNodes[n];
                                    while (l = ++n && l && l[p] || (m = n = 0) || o.pop()) if (1 === l.nodeType && ++m && l === b) {
                                        k[a] = [w, n, m];
                                        break
                                    }
                                } else if (s && (j = (b[u] || (b[u] = {}))[a]) && j[0] === w) m = j[1]; else while (l = ++n && l && l[p] || (m = n = 0) || o.pop()) if ((h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) && ++m && (s && ((l[u] || (l[u] = {}))[a] = [w, m]), l === b)) break;
                                return m -= e, m === d || m % d === 0 && m / d >= 0
                            }
                        }
                    }, PSEUDO: function (a, b) {
                        var c,
                            e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || ga.error("unsupported pseudo: " + a);
                        return e[u] ? e(b) : e.length > 1 ? (c = [a, a, "", b], d.setFilters.hasOwnProperty(a.toLowerCase()) ? ia(function (a, c) {
                            var d, f = e(a, b), g = f.length;
                            while (g--) d = J(a, f[g]), a[d] = !(c[d] = f[g])
                        }) : function (a) {
                            return e(a, 0, c)
                        }) : e
                    }
                },
                pseudos: {
                    not: ia(function (a) {
                        var b = [], c = [], d = h(a.replace(R, "$1"));
                        return d[u] ? ia(function (a, b, c, e) {
                            var f, g = d(a, null, e, []), h = a.length;
                            while (h--) (f = g[h]) && (a[h] = !(b[h] = f))
                        }) : function (a, e, f) {
                            return b[0] = a, d(b, null, f, c), b[0] = null, !c.pop()
                        }
                    }), has: ia(function (a) {
                        return function (b) {
                            return ga(a, b).length > 0
                        }
                    }), contains: ia(function (a) {
                        return a = a.replace(ca, da), function (b) {
                            return (b.textContent || b.innerText || e(b)).indexOf(a) > -1
                        }
                    }), lang: ia(function (a) {
                        return W.test(a || "") || ga.error("unsupported lang: " + a), a = a.replace(ca, da).toLowerCase(), function (b) {
                            var c;
                            do if (c = p ? b.lang : b.getAttribute("xml:lang") || b.getAttribute("lang")) return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + "-"); while ((b = b.parentNode) && 1 === b.nodeType);
                            return !1
                        }
                    }), target: function (b) {
                        var c = a.location && a.location.hash;
                        return c && c.slice(1) === b.id
                    }, root: function (a) {
                        return a === o
                    }, focus: function (a) {
                        return a === n.activeElement && (!n.hasFocus || n.hasFocus()) && !!(a.type || a.href || ~a.tabIndex)
                    }, enabled: function (a) {
                        return a.disabled === !1
                    }, disabled: function (a) {
                        return a.disabled === !0
                    }, checked: function (a) {
                        var b = a.nodeName.toLowerCase();
                        return "input" === b && !!a.checked || "option" === b && !!a.selected
                    }, selected: function (a) {
                        return a.parentNode && a.parentNode.selectedIndex, a.selected === !0
                    }, empty: function (a) {
                        for (a = a.firstChild; a; a = a.nextSibling) if (a.nodeType < 6) return !1;
                        return !0
                    }, parent: function (a) {
                        return !d.pseudos.empty(a)
                    }, header: function (a) {
                        return Z.test(a.nodeName)
                    }, input: function (a) {
                        return Y.test(a.nodeName)
                    }, button: function (a) {
                        var b = a.nodeName.toLowerCase();
                        return "input" === b && "button" === a.type || "button" === b
                    }, text: function (a) {
                        var b;
                        return "input" === a.nodeName.toLowerCase() && "text" === a.type && (null == (b = a.getAttribute("type")) || "text" === b.toLowerCase())
                    }, first: oa(function () {
                        return [0]
                    }), last: oa(function (a, b) {
                        return [b - 1]
                    }), eq: oa(function (a, b, c) {
                        return [0 > c ? c + b : c]
                    }), even: oa(function (a, b) {
                        for (var c = 0; b > c; c += 2) a.push(c);
                        return a
                    }), odd: oa(function (a, b) {
                        for (var c = 1; b > c; c += 2) a.push(c);
                        return a
                    }), lt: oa(function (a, b, c) {
                        for (var d = 0 > c ? c + b : c; --d >= 0;) a.push(d);
                        return a
                    }), gt: oa(function (a, b, c) {
                        for (var d = 0 > c ? c + b : c; ++d < b;) a.push(d);
                        return a
                    })
                }
            }, d.pseudos.nth = d.pseudos.eq;
            for (b in{radio: !0, checkbox: !0, file: !0, password: !0, image: !0}) d.pseudos[b] = ma(b);
            for (b in{submit: !0, reset: !0}) d.pseudos[b] = na(b);

            function qa() {
            }

            qa.prototype = d.filters = d.pseudos, d.setFilters = new qa, g = ga.tokenize = function (a, b) {
                var c, e, f, g, h, i, j, k = z[a + " "];
                if (k) return b ? 0 : k.slice(0);
                h = a, i = [], j = d.preFilter;
                while (h) {
                    (!c || (e = S.exec(h))) && (e && (h = h.slice(e[0].length) || h), i.push(f = [])), c = !1, (e = T.exec(h)) && (c = e.shift(), f.push({
                        value: c,
                        type: e[0].replace(R, " ")
                    }), h = h.slice(c.length));
                    for (g in d.filter) !(e = X[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), f.push({
                        value: c,
                        type: g,
                        matches: e
                    }), h = h.slice(c.length));
                    if (!c) break
                }
                return b ? h.length : h ? ga.error(a) : z(a, i).slice(0)
            };

            function ra(a) {
                for (var b = 0, c = a.length, d = ""; c > b; b++) d += a[b].value;
                return d
            }

            function sa(a, b, c) {
                var d = b.dir, e = c && "parentNode" === d, f = x++;
                return b.first ? function (b, c, f) {
                    while (b = b[d]) if (1 === b.nodeType || e) return a(b, c, f)
                } : function (b, c, g) {
                    var h, i, j = [w, f];
                    if (g) {
                        while (b = b[d]) if ((1 === b.nodeType || e) && a(b, c, g)) return !0
                    } else while (b = b[d]) if (1 === b.nodeType || e) {
                        if (i = b[u] || (b[u] = {}), (h = i[d]) && h[0] === w && h[1] === f) return j[2] = h[2];
                        if (i[d] = j, j[2] = a(b, c, g)) return !0
                    }
                }
            }

            function ta(a) {
                return a.length > 1 ? function (b, c, d) {
                    var e = a.length;
                    while (e--) if (!a[e](b, c, d)) return !1;
                    return !0
                } : a[0]
            }

            function ua(a, b, c) {
                for (var d = 0, e = b.length; e > d; d++) ga(a, b[d], c);
                return c
            }

            function va(a, b, c, d, e) {
                for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++) (f = a[h]) && (!c || c(f, d, e)) && (g.push(f), j && b.push(h));
                return g
            }

            function wa(a, b, c, d, e, f) {
                return d && !d[u] && (d = wa(d)), e && !e[u] && (e = wa(e, f)), ia(function (f, g, h, i) {
                    var j, k, l, m = [], n = [], o = g.length, p = f || ua(b || "*", h.nodeType ? [h] : h, []),
                        q = !a || !f && b ? p : va(p, m, a, h, i), r = c ? e || (f ? a : o || d) ? [] : g : q;
                    if (c && c(q, r, h, i), d) {
                        j = va(r, n), d(j, [], h, i), k = j.length;
                        while (k--) (l = j[k]) && (r[n[k]] = !(q[n[k]] = l))
                    }
                    if (f) {
                        if (e || a) {
                            if (e) {
                                j = [], k = r.length;
                                while (k--) (l = r[k]) && j.push(q[k] = l);
                                e(null, r = [], j, i)
                            }
                            k = r.length;
                            while (k--) (l = r[k]) && (j = e ? J(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l))
                        }
                    } else r = va(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : H.apply(g, r)
                })
            }

            function xa(a) {
                for (var b, c, e, f = a.length, g = d.relative[a[0].type], h = g || d.relative[" "], i = g ? 1 : 0, k = sa(function (a) {
                    return a === b
                }, h, !0), l = sa(function (a) {
                    return J(b, a) > -1
                }, h, !0), m = [function (a, c, d) {
                    var e = !g && (d || c !== j) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d));
                    return b = null, e
                }]; f > i; i++) if (c = d.relative[a[i].type]) m = [sa(ta(m), c)]; else {
                    if (c = d.filter[a[i].type].apply(null, a[i].matches), c[u]) {
                        for (e = ++i; f > e; e++) if (d.relative[a[e].type]) break;
                        return wa(i > 1 && ta(m), i > 1 && ra(a.slice(0, i - 1).concat({value: " " === a[i - 2].type ? "*" : ""})).replace(R, "$1"), c, e > i && xa(a.slice(i, e)), f > e && xa(a = a.slice(e)), f > e && ra(a))
                    }
                    m.push(c)
                }
                return ta(m)
            }

            function ya(a, b) {
                var c = b.length > 0, e = a.length > 0, f = function (f, g, h, i, k) {
                    var l, m, o, p = 0, q = "0", r = f && [], s = [], t = j, u = f || e && d.find.TAG("*", k),
                        v = w += null == t ? 1 : Math.random() || .1, x = u.length;
                    for (k && (j = g !== n && g); q !== x && null != (l = u[q]); q++) {
                        if (e && l) {
                            m = 0;
                            while (o = a[m++]) if (o(l, g, h)) {
                                i.push(l);
                                break
                            }
                            k && (w = v)
                        }
                        c && ((l = !o && l) && p--, f && r.push(l))
                    }
                    if (p += q, c && q !== p) {
                        m = 0;
                        while (o = b[m++]) o(r, s, g, h);
                        if (f) {
                            if (p > 0) while (q--) r[q] || s[q] || (s[q] = F.call(i));
                            s = va(s)
                        }
                        H.apply(i, s), k && !f && s.length > 0 && p + b.length > 1 && ga.uniqueSort(i)
                    }
                    return k && (w = v, j = t), r
                };
                return c ? ia(f) : f
            }

            return h = ga.compile = function (a, b) {
                var c, d = [], e = [], f = A[a + " "];
                if (!f) {
                    b || (b = g(a)), c = b.length;
                    while (c--) f = xa(b[c]), f[u] ? d.push(f) : e.push(f);
                    f = A(a, ya(e, d)), f.selector = a
                }
                return f
            }, i = ga.select = function (a, b, e, f) {
                var i, j, k, l, m, n = "function" == typeof a && a, o = !f && g(a = n.selector || a);
                if (e = e || [], 1 === o.length) {
                    if (j = o[0] = o[0].slice(0), j.length > 2 && "ID" === (k = j[0]).type && c.getById && 9 === b.nodeType && p && d.relative[j[1].type]) {
                        if (b = (d.find.ID(k.matches[0].replace(ca, da), b) || [])[0], !b) return e;
                        n && (b = b.parentNode), a = a.slice(j.shift().value.length)
                    }
                    i = X.needsContext.test(a) ? 0 : j.length;
                    while (i--) {
                        if (k = j[i], d.relative[l = k.type]) break;
                        if ((m = d.find[l]) && (f = m(k.matches[0].replace(ca, da), aa.test(j[0].type) && pa(b.parentNode) || b))) {
                            if (j.splice(i, 1), a = f.length && ra(j), !a) return H.apply(e, f), e;
                            break
                        }
                    }
                }
                return (n || h(a, o))(f, b, !p, e, aa.test(a) && pa(b.parentNode) || b), e
            }, c.sortStable = u.split("").sort(B).join("") === u, c.detectDuplicates = !!l, m(), c.sortDetached = ja(function (a) {
                return 1 & a.compareDocumentPosition(n.createElement("div"))
            }), ja(function (a) {
                return a.innerHTML = "<a href='#'></a>", "#" === a.firstChild.getAttribute("href")
            }) || ka("type|href|height|width", function (a, b, c) {
                return c ? void 0 : a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2)
            }), c.attributes && ja(function (a) {
                return a.innerHTML = "<input/>", a.firstChild.setAttribute("value", ""), "" === a.firstChild.getAttribute("value")
            }) || ka("value", function (a, b, c) {
                return c || "input" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue
            }), ja(function (a) {
                return null == a.getAttribute("disabled")
            }) || ka(K, function (a, b, c) {
                var d;
                return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null
            }), ga
        }(a);
        m.find = s, m.expr = s.selectors, m.expr[":"] = m.expr.pseudos, m.unique = s.uniqueSort, m.text = s.getText, m.isXMLDoc = s.isXML, m.contains = s.contains;
        var t = m.expr.match.needsContext, u = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, v = /^.[^:#\[\.,]*$/;

        function w(a, b, c) {
            if (m.isFunction(b)) return m.grep(a, function (a, d) {
                return !!b.call(a, d, a) !== c
            });
            if (b.nodeType) return m.grep(a, function (a) {
                return a === b !== c
            });
            if ("string" == typeof b) {
                if (v.test(b)) return m.filter(b, a, c);
                b = m.filter(b, a)
            }
            return m.grep(a, function (a) {
                return m.inArray(a, b) >= 0 !== c
            })
        }

        m.filter = function (a, b, c) {
            var d = b[0];
            return c && (a = ":not(" + a + ")"), 1 === b.length && 1 === d.nodeType ? m.find.matchesSelector(d, a) ? [d] : [] : m.find.matches(a, m.grep(b, function (a) {
                return 1 === a.nodeType
            }))
        }, m.fn.extend({
            find: function (a) {
                var b, c = [], d = this, e = d.length;
                if ("string" != typeof a) return this.pushStack(m(a).filter(function () {
                    for (b = 0; e > b; b++) if (m.contains(d[b], this)) return !0
                }));
                for (b = 0; e > b; b++) m.find(a, d[b], c);
                return c = this.pushStack(e > 1 ? m.unique(c) : c), c.selector = this.selector ? this.selector + " " + a : a, c
            }, filter: function (a) {
                return this.pushStack(w(this, a || [], !1))
            }, not: function (a) {
                return this.pushStack(w(this, a || [], !0))
            }, is: function (a) {
                return !!w(this, "string" == typeof a && t.test(a) ? m(a) : a || [], !1).length
            }
        });
        var x, y = a.document, z = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, A = m.fn.init = function (a, b) {
            var c, d;
            if (!a) return this;
            if ("string" == typeof a) {
                if (c = "<" === a.charAt(0) && ">" === a.charAt(a.length - 1) && a.length >= 3 ? [null, a, null] : z.exec(a), !c || !c[1] && b) return !b || b.jquery ? (b || x).find(a) : this.constructor(b).find(a);
                if (c[1]) {
                    if (b = b instanceof m ? b[0] : b, m.merge(this, m.parseHTML(c[1], b && b.nodeType ? b.ownerDocument || b : y, !0)), u.test(c[1]) && m.isPlainObject(b)) for (c in b) m.isFunction(this[c]) ? this[c](b[c]) : this.attr(c, b[c]);
                    return this
                }
                if (d = y.getElementById(c[2]), d && d.parentNode) {
                    if (d.id !== c[2]) return x.find(a);
                    this.length = 1, this[0] = d
                }
                return this.context = y, this.selector = a, this
            }
            return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : m.isFunction(a) ? "undefined" != typeof x.ready ? x.ready(a) : a(m) : (void 0 !== a.selector && (this.selector = a.selector, this.context = a.context), m.makeArray(a, this))
        };
        A.prototype = m.fn, x = m(y);
        var B = /^(?:parents|prev(?:Until|All))/, C = {children: !0, contents: !0, next: !0, prev: !0};
        m.extend({
            dir: function (a, b, c) {
                var d = [], e = a[b];
                while (e && 9 !== e.nodeType && (void 0 === c || 1 !== e.nodeType || !m(e).is(c))) 1 === e.nodeType && d.push(e), e = e[b];
                return d
            }, sibling: function (a, b) {
                for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a !== b && c.push(a);
                return c
            }
        }), m.fn.extend({
            has: function (a) {
                var b, c = m(a, this), d = c.length;
                return this.filter(function () {
                    for (b = 0; d > b; b++) if (m.contains(this, c[b])) return !0
                })
            }, closest: function (a, b) {
                for (var c, d = 0, e = this.length, f = [], g = t.test(a) || "string" != typeof a ? m(a, b || this.context) : 0; e > d; d++) for (c = this[d]; c && c !== b; c = c.parentNode) if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && m.find.matchesSelector(c, a))) {
                    f.push(c);
                    break
                }
                return this.pushStack(f.length > 1 ? m.unique(f) : f)
            }, index: function (a) {
                return a ? "string" == typeof a ? m.inArray(this[0], m(a)) : m.inArray(a.jquery ? a[0] : a, this) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
            }, add: function (a, b) {
                return this.pushStack(m.unique(m.merge(this.get(), m(a, b))))
            }, addBack: function (a) {
                return this.add(null == a ? this.prevObject : this.prevObject.filter(a))
            }
        });

        function D(a, b) {
            do a = a[b]; while (a && 1 !== a.nodeType);
            return a
        }

        m.each({
            parent: function (a) {
                var b = a.parentNode;
                return b && 11 !== b.nodeType ? b : null
            }, parents: function (a) {
                return m.dir(a, "parentNode")
            }, parentsUntil: function (a, b, c) {
                return m.dir(a, "parentNode", c)
            }, next: function (a) {
                return D(a, "nextSibling")
            }, prev: function (a) {
                return D(a, "previousSibling")
            }, nextAll: function (a) {
                return m.dir(a, "nextSibling")
            }, prevAll: function (a) {
                return m.dir(a, "previousSibling")
            }, nextUntil: function (a, b, c) {
                return m.dir(a, "nextSibling", c)
            }, prevUntil: function (a, b, c) {
                return m.dir(a, "previousSibling", c)
            }, siblings: function (a) {
                return m.sibling((a.parentNode || {}).firstChild, a)
            }, children: function (a) {
                return m.sibling(a.firstChild)
            }, contents: function (a) {
                return m.nodeName(a, "iframe") ? a.contentDocument || a.contentWindow.document : m.merge([], a.childNodes)
            }
        }, function (a, b) {
            m.fn[a] = function (c, d) {
                var e = m.map(this, b, c);
                return "Until" !== a.slice(-5) && (d = c), d && "string" == typeof d && (e = m.filter(d, e)), this.length > 1 && (C[a] || (e = m.unique(e)), B.test(a) && (e = e.reverse())), this.pushStack(e)
            }
        });
        var E = /\S+/g, F = {};

        function G(a) {
            var b = F[a] = {};
            return m.each(a.match(E) || [], function (a, c) {
                b[c] = !0
            }), b
        }

        m.Callbacks = function (a) {
            a = "string" == typeof a ? F[a] || G(a) : m.extend({}, a);
            var b, c, d, e, f, g, h = [], i = !a.once && [], j = function (l) {
                for (c = a.memory && l, d = !0, f = g || 0, g = 0, e = h.length, b = !0; h && e > f; f++) if (h[f].apply(l[0], l[1]) === !1 && a.stopOnFalse) {
                    c = !1;
                    break
                }
                b = !1, h && (i ? i.length && j(i.shift()) : c ? h = [] : k.disable())
            }, k = {
                add: function () {
                    if (h) {
                        var d = h.length;
                        !function f(b) {
                            m.each(b, function (b, c) {
                                var d = m.type(c);
                                "function" === d ? a.unique && k.has(c) || h.push(c) : c && c.length && "string" !== d && f(c)
                            })
                        }(arguments), b ? e = h.length : c && (g = d, j(c))
                    }
                    return this
                }, remove: function () {
                    return h && m.each(arguments, function (a, c) {
                        var d;
                        while ((d = m.inArray(c, h, d)) > -1) h.splice(d, 1), b && (e >= d && e--, f >= d && f--)
                    }), this
                }, has: function (a) {
                    return a ? m.inArray(a, h) > -1 : !(!h || !h.length)
                }, empty: function () {
                    return h = [], e = 0, this
                }, disable: function () {
                    return h = i = c = void 0, this
                }, disabled: function () {
                    return !h
                }, lock: function () {
                    return i = void 0, c || k.disable(), this
                }, locked: function () {
                    return !i
                }, fireWith: function (a, c) {
                    return !h || d && !i || (c = c || [], c = [a, c.slice ? c.slice() : c], b ? i.push(c) : j(c)), this
                }, fire: function () {
                    return k.fireWith(this, arguments), this
                }, fired: function () {
                    return !!d
                }
            };
            return k
        }, m.extend({
            Deferred: function (a) {
                var b = [["resolve", "done", m.Callbacks("once memory"), "resolved"], ["reject", "fail", m.Callbacks("once memory"), "rejected"], ["notify", "progress", m.Callbacks("memory")]],
                    c = "pending", d = {
                        state: function () {
                            return c
                        }, always: function () {
                            return e.done(arguments).fail(arguments), this
                        }, then: function () {
                            var a = arguments;
                            return m.Deferred(function (c) {
                                m.each(b, function (b, f) {
                                    var g = m.isFunction(a[b]) && a[b];
                                    e[f[1]](function () {
                                        var a = g && g.apply(this, arguments);
                                        a && m.isFunction(a.promise) ? a.promise().done(c.resolve).fail(c.reject).progress(c.notify) : c[f[0] + "With"](this === d ? c.promise() : this, g ? [a] : arguments)
                                    })
                                }), a = null
                            }).promise()
                        }, promise: function (a) {
                            return null != a ? m.extend(a, d) : d
                        }
                    }, e = {};
                return d.pipe = d.then, m.each(b, function (a, f) {
                    var g = f[2], h = f[3];
                    d[f[1]] = g.add, h && g.add(function () {
                        c = h
                    }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function () {
                        return e[f[0] + "With"](this === e ? d : this, arguments), this
                    }, e[f[0] + "With"] = g.fireWith
                }), d.promise(e), a && a.call(e, e), e
            }, when: function (a) {
                var b = 0, c = d.call(arguments), e = c.length, f = 1 !== e || a && m.isFunction(a.promise) ? e : 0,
                    g = 1 === f ? a : m.Deferred(), h = function (a, b, c) {
                        return function (e) {
                            b[a] = this, c[a] = arguments.length > 1 ? d.call(arguments) : e, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c)
                        }
                    }, i, j, k;
                if (e > 1) for (i = new Array(e), j = new Array(e), k = new Array(e); e > b; b++) c[b] && m.isFunction(c[b].promise) ? c[b].promise().done(h(b, k, c)).fail(g.reject).progress(h(b, j, i)) : --f;
                return f || g.resolveWith(k, c), g.promise()
            }
        });
        var H;
        m.fn.ready = function (a) {
            return m.ready.promise().done(a), this
        }, m.extend({
            isReady: !1, readyWait: 1, holdReady: function (a) {
                a ? m.readyWait++ : m.ready(!0)
            }, ready: function (a) {
                if (a === !0 ? !--m.readyWait : !m.isReady) {
                    if (!y.body) return setTimeout(m.ready);
                    m.isReady = !0, a !== !0 && --m.readyWait > 0 || (H.resolveWith(y, [m]), m.fn.triggerHandler && (m(y).triggerHandler("ready"), m(y).off("ready")))
                }
            }
        });

        function I() {
            y.addEventListener ? (y.removeEventListener("DOMContentLoaded", J, !1), a.removeEventListener("load", J, !1)) : (y.detachEvent("onreadystatechange", J), a.detachEvent("onload", J))
        }

        function J() {
            (y.addEventListener || "load" === event.type || "complete" === y.readyState) && (I(), m.ready())
        }

        m.ready.promise = function (b) {
            if (!H) if (H = m.Deferred(), "complete" === y.readyState) setTimeout(m.ready); else if (y.addEventListener) y.addEventListener("DOMContentLoaded", J, !1), a.addEventListener("load", J, !1); else {
                y.attachEvent("onreadystatechange", J), a.attachEvent("onload", J);
                var c = !1;
                try {
                    c = null == a.frameElement && y.documentElement
                } catch (d) {
                }
                c && c.doScroll && !function e() {
                    if (!m.isReady) {
                        try {
                            c.doScroll("left")
                        } catch (a) {
                            return setTimeout(e, 50)
                        }
                        I(), m.ready()
                    }
                }()
            }
            return H.promise(b)
        };
        var K = "undefined", L;
        for (L in m(k)) break;
        k.ownLast = "0" !== L, k.inlineBlockNeedsLayout = !1, m(function () {
            var a, b, c, d;
            c = y.getElementsByTagName("body")[0], c && c.style && (b = y.createElement("div"), d = y.createElement("div"), d.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", c.appendChild(d).appendChild(b), typeof b.style.zoom !== K && (b.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1", k.inlineBlockNeedsLayout = a = 3 === b.offsetWidth, a && (c.style.zoom = 1)), c.removeChild(d))
        }), function () {
            var a = y.createElement("div");
            if (null == k.deleteExpando) {
                k.deleteExpando = !0;
                try {
                    delete a.test
                } catch (b) {
                    k.deleteExpando = !1
                }
            }
            a = null
        }(), m.acceptData = function (a) {
            var b = m.noData[(a.nodeName + " ").toLowerCase()], c = +a.nodeType || 1;
            return 1 !== c && 9 !== c ? !1 : !b || b !== !0 && a.getAttribute("classid") === b
        };
        var M = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, N = /([A-Z])/g;

        function O(a, b, c) {
            if (void 0 === c && 1 === a.nodeType) {
                var d = "data-" + b.replace(N, "-$1").toLowerCase();
                if (c = a.getAttribute(d), "string" == typeof c) {
                    try {
                        c = "true" === c ? !0 : "false" === c ? !1 : "null" === c ? null : +c + "" === c ? +c : M.test(c) ? m.parseJSON(c) : c
                    } catch (e) {
                    }
                    m.data(a, b, c)
                } else c = void 0
            }
            return c
        }

        function P(a) {
            var b;
            for (b in a) if (("data" !== b || !m.isEmptyObject(a[b])) && "toJSON" !== b) return !1;

            return !0
        }

        function Q(a, b, d, e) {
            if (m.acceptData(a)) {
                var f, g, h = m.expando, i = a.nodeType, j = i ? m.cache : a, k = i ? a[h] : a[h] && h;
                if (k && j[k] && (e || j[k].data) || void 0 !== d || "string" != typeof b) return k || (k = i ? a[h] = c.pop() || m.guid++ : h), j[k] || (j[k] = i ? {} : {toJSON: m.noop}), ("object" == typeof b || "function" == typeof b) && (e ? j[k] = m.extend(j[k], b) : j[k].data = m.extend(j[k].data, b)), g = j[k], e || (g.data || (g.data = {}), g = g.data), void 0 !== d && (g[m.camelCase(b)] = d), "string" == typeof b ? (f = g[b], null == f && (f = g[m.camelCase(b)])) : f = g, f
            }
        }

        function R(a, b, c) {
            if (m.acceptData(a)) {
                var d, e, f = a.nodeType, g = f ? m.cache : a, h = f ? a[m.expando] : m.expando;
                if (g[h]) {
                    if (b && (d = c ? g[h] : g[h].data)) {
                        m.isArray(b) ? b = b.concat(m.map(b, m.camelCase)) : b in d ? b = [b] : (b = m.camelCase(b), b = b in d ? [b] : b.split(" ")), e = b.length;
                        while (e--) delete d[b[e]];
                        if (c ? !P(d) : !m.isEmptyObject(d)) return
                    }
                    (c || (delete g[h].data, P(g[h]))) && (f ? m.cleanData([a], !0) : k.deleteExpando || g != g.window ? delete g[h] : g[h] = null)
                }
            }
        }

        m.extend({
            cache: {},
            noData: {"applet ": !0, "embed ": !0, "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"},
            hasData: function (a) {
                return a = a.nodeType ? m.cache[a[m.expando]] : a[m.expando], !!a && !P(a)
            },
            data: function (a, b, c) {
                return Q(a, b, c)
            },
            removeData: function (a, b) {
                return R(a, b)
            },
            _data: function (a, b, c) {
                return Q(a, b, c, !0)
            },
            _removeData: function (a, b) {
                return R(a, b, !0)
            }
        }), m.fn.extend({
            data: function (a, b) {
                var c, d, e, f = this[0], g = f && f.attributes;
                if (void 0 === a) {
                    if (this.length && (e = m.data(f), 1 === f.nodeType && !m._data(f, "parsedAttrs"))) {
                        c = g.length;
                        while (c--) g[c] && (d = g[c].name, 0 === d.indexOf("data-") && (d = m.camelCase(d.slice(5)), O(f, d, e[d])));
                        m._data(f, "parsedAttrs", !0)
                    }
                    return e
                }
                return "object" == typeof a ? this.each(function () {
                    m.data(this, a)
                }) : arguments.length > 1 ? this.each(function () {
                    m.data(this, a, b)
                }) : f ? O(f, a, m.data(f, a)) : void 0
            }, removeData: function (a) {
                return this.each(function () {
                    m.removeData(this, a)
                })
            }
        }), m.extend({
            queue: function (a, b, c) {
                var d;
                return a ? (b = (b || "fx") + "queue", d = m._data(a, b), c && (!d || m.isArray(c) ? d = m._data(a, b, m.makeArray(c)) : d.push(c)), d || []) : void 0
            }, dequeue: function (a, b) {
                b = b || "fx";
                var c = m.queue(a, b), d = c.length, e = c.shift(), f = m._queueHooks(a, b), g = function () {
                    m.dequeue(a, b)
                };
                "inprogress" === e && (e = c.shift(), d--), e && ("fx" === b && c.unshift("inprogress"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire()
            }, _queueHooks: function (a, b) {
                var c = b + "queueHooks";
                return m._data(a, c) || m._data(a, c, {
                    empty: m.Callbacks("once memory").add(function () {
                        m._removeData(a, b + "queue"), m._removeData(a, c)
                    })
                })
            }
        }), m.fn.extend({
            queue: function (a, b) {
                var c = 2;
                return "string" != typeof a && (b = a, a = "fx", c--), arguments.length < c ? m.queue(this[0], a) : void 0 === b ? this : this.each(function () {
                    var c = m.queue(this, a, b);
                    m._queueHooks(this, a), "fx" === a && "inprogress" !== c[0] && m.dequeue(this, a)
                })
            }, dequeue: function (a) {
                return this.each(function () {
                    m.dequeue(this, a)
                })
            }, clearQueue: function (a) {
                return this.queue(a || "fx", [])
            }, promise: function (a, b) {
                var c, d = 1, e = m.Deferred(), f = this, g = this.length, h = function () {
                    --d || e.resolveWith(f, [f])
                };
                "string" != typeof a && (b = a, a = void 0), a = a || "fx";
                while (g--) c = m._data(f[g], a + "queueHooks"), c && c.empty && (d++, c.empty.add(h));
                return h(), e.promise(b)
            }
        });
        var S = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, T = ["Top", "Right", "Bottom", "Left"],
            U = function (a, b) {
                return a = b || a, "none" === m.css(a, "display") || !m.contains(a.ownerDocument, a)
            }, V = m.access = function (a, b, c, d, e, f, g) {
                var h = 0, i = a.length, j = null == c;
                if ("object" === m.type(c)) {
                    e = !0;
                    for (h in c) m.access(a, b, h, c[h], !0, f, g)
                } else if (void 0 !== d && (e = !0, m.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function (a, b, c) {
                        return j.call(m(a), c)
                    })), b)) for (; i > h; h++) b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));
                return e ? a : j ? b.call(a) : i ? b(a[0], c) : f
            }, W = /^(?:checkbox|radio)$/i;
        !function () {
            var a = y.createElement("input"), b = y.createElement("div"), c = y.createDocumentFragment();
            if (b.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", k.leadingWhitespace = 3 === b.firstChild.nodeType, k.tbody = !b.getElementsByTagName("tbody").length, k.htmlSerialize = !!b.getElementsByTagName("link").length, k.html5Clone = "<:nav></:nav>" !== y.createElement("nav").cloneNode(!0).outerHTML, a.type = "checkbox", a.checked = !0, c.appendChild(a), k.appendChecked = a.checked, b.innerHTML = "<textarea>x</textarea>", k.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue, c.appendChild(b), b.innerHTML = "<input type='radio' checked='checked' name='t'/>", k.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, k.noCloneEvent = !0, b.attachEvent && (b.attachEvent("onclick", function () {
                    k.noCloneEvent = !1
                }), b.cloneNode(!0).click()), null == k.deleteExpando) {
                k.deleteExpando = !0;
                try {
                    delete b.test
                } catch (d) {
                    k.deleteExpando = !1
                }
            }
        }(), function () {
            var b, c, d = y.createElement("div");
            for (b in{
                submit: !0,
                change: !0,
                focusin: !0
            }) c = "on" + b, (k[b + "Bubbles"] = c in a) || (d.setAttribute(c, "t"), k[b + "Bubbles"] = d.attributes[c].expando === !1);
            d = null
        }();
        var X = /^(?:input|select|textarea)$/i, Y = /^key/, Z = /^(?:mouse|pointer|contextmenu)|click/,
            $ = /^(?:focusinfocus|focusoutblur)$/, _ = /^([^.]*)(?:\.(.+)|)$/;

        function aa() {
            return !0
        }

        function ba() {
            return !1
        }

        function ca() {
            try {
                return y.activeElement
            } catch (a) {
            }
        }

        m.event = {
            global: {},
            add: function (a, b, c, d, e) {
                var f, g, h, i, j, k, l, n, o, p, q, r = m._data(a);
                if (r) {
                    c.handler && (i = c, c = i.handler, e = i.selector), c.guid || (c.guid = m.guid++), (g = r.events) || (g = r.events = {}), (k = r.handle) || (k = r.handle = function (a) {
                        return typeof m === K || a && m.event.triggered === a.type ? void 0 : m.event.dispatch.apply(k.elem, arguments)
                    }, k.elem = a), b = (b || "").match(E) || [""], h = b.length;
                    while (h--) f = _.exec(b[h]) || [], o = q = f[1], p = (f[2] || "").split(".").sort(), o && (j = m.event.special[o] || {}, o = (e ? j.delegateType : j.bindType) || o, j = m.event.special[o] || {}, l = m.extend({
                        type: o,
                        origType: q,
                        data: d,
                        handler: c,
                        guid: c.guid,
                        selector: e,
                        needsContext: e && m.expr.match.needsContext.test(e),
                        namespace: p.join(".")
                    }, i), (n = g[o]) || (n = g[o] = [], n.delegateCount = 0, j.setup && j.setup.call(a, d, p, k) !== !1 || (a.addEventListener ? a.addEventListener(o, k, !1) : a.attachEvent && a.attachEvent("on" + o, k))), j.add && (j.add.call(a, l), l.handler.guid || (l.handler.guid = c.guid)), e ? n.splice(n.delegateCount++, 0, l) : n.push(l), m.event.global[o] = !0);
                    a = null
                }
            },
            remove: function (a, b, c, d, e) {
                var f, g, h, i, j, k, l, n, o, p, q, r = m.hasData(a) && m._data(a);
                if (r && (k = r.events)) {
                    b = (b || "").match(E) || [""], j = b.length;
                    while (j--) if (h = _.exec(b[j]) || [], o = q = h[1], p = (h[2] || "").split(".").sort(), o) {
                        l = m.event.special[o] || {}, o = (d ? l.delegateType : l.bindType) || o, n = k[o] || [], h = h[2] && new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"), i = f = n.length;
                        while (f--) g = n[f], !e && q !== g.origType || c && c.guid !== g.guid || h && !h.test(g.namespace) || d && d !== g.selector && ("**" !== d || !g.selector) || (n.splice(f, 1), g.selector && n.delegateCount--, l.remove && l.remove.call(a, g));
                        i && !n.length && (l.teardown && l.teardown.call(a, p, r.handle) !== !1 || m.removeEvent(a, o, r.handle), delete k[o])
                    } else for (o in k) m.event.remove(a, o + b[j], c, d, !0);
                    m.isEmptyObject(k) && (delete r.handle, m._removeData(a, "events"))
                }
            },
            trigger: function (b, c, d, e) {
                var f, g, h, i, k, l, n, o = [d || y], p = j.call(b, "type") ? b.type : b,
                    q = j.call(b, "namespace") ? b.namespace.split(".") : [];
                if (h = l = d = d || y, 3 !== d.nodeType && 8 !== d.nodeType && !$.test(p + m.event.triggered) && (p.indexOf(".") >= 0 && (q = p.split("."), p = q.shift(), q.sort()), g = p.indexOf(":") < 0 && "on" + p, b = b[m.expando] ? b : new m.Event(p, "object" == typeof b && b), b.isTrigger = e ? 2 : 3, b.namespace = q.join("."), b.namespace_re = b.namespace ? new RegExp("(^|\\.)" + q.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, b.result = void 0, b.target || (b.target = d), c = null == c ? [b] : m.makeArray(c, [b]), k = m.event.special[p] || {}, e || !k.trigger || k.trigger.apply(d, c) !== !1)) {
                    if (!e && !k.noBubble && !m.isWindow(d)) {
                        for (i = k.delegateType || p, $.test(i + p) || (h = h.parentNode); h; h = h.parentNode) o.push(h), l = h;
                        l === (d.ownerDocument || y) && o.push(l.defaultView || l.parentWindow || a)
                    }
                    n = 0;
                    while ((h = o[n++]) && !b.isPropagationStopped()) b.type = n > 1 ? i : k.bindType || p, f = (m._data(h, "events") || {})[b.type] && m._data(h, "handle"), f && f.apply(h, c), f = g && h[g], f && f.apply && m.acceptData(h) && (b.result = f.apply(h, c), b.result === !1 && b.preventDefault());
                    if (b.type = p, !e && !b.isDefaultPrevented() && (!k._default || k._default.apply(o.pop(), c) === !1) && m.acceptData(d) && g && d[p] && !m.isWindow(d)) {
                        l = d[g], l && (d[g] = null), m.event.triggered = p;
                        try {
                            d[p]()
                        } catch (r) {
                        }
                        m.event.triggered = void 0, l && (d[g] = l)
                    }
                    return b.result
                }
            },
            dispatch: function (a) {
                a = m.event.fix(a);
                var b, c, e, f, g, h = [], i = d.call(arguments), j = (m._data(this, "events") || {})[a.type] || [],
                    k = m.event.special[a.type] || {};
                if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) {
                    h = m.event.handlers.call(this, a, j), b = 0;
                    while ((f = h[b++]) && !a.isPropagationStopped()) {
                        a.currentTarget = f.elem, g = 0;
                        while ((e = f.handlers[g++]) && !a.isImmediatePropagationStopped()) (!a.namespace_re || a.namespace_re.test(e.namespace)) && (a.handleObj = e, a.data = e.data, c = ((m.event.special[e.origType] || {}).handle || e.handler).apply(f.elem, i), void 0 !== c && (a.result = c) === !1 && (a.preventDefault(), a.stopPropagation()))
                    }
                    return k.postDispatch && k.postDispatch.call(this, a), a.result
                }
            },
            handlers: function (a, b) {
                var c, d, e, f, g = [], h = b.delegateCount, i = a.target;
                if (h && i.nodeType && (!a.button || "click" !== a.type)) for (; i != this; i = i.parentNode || this) if (1 === i.nodeType && (i.disabled !== !0 || "click" !== a.type)) {
                    for (e = [], f = 0; h > f; f++) d = b[f], c = d.selector + " ", void 0 === e[c] && (e[c] = d.needsContext ? m(c, this).index(i) >= 0 : m.find(c, this, null, [i]).length), e[c] && e.push(d);
                    e.length && g.push({elem: i, handlers: e})
                }
                return h < b.length && g.push({elem: this, handlers: b.slice(h)}), g
            },
            fix: function (a) {
                if (a[m.expando]) return a;
                var b, c, d, e = a.type, f = a, g = this.fixHooks[e];
                g || (this.fixHooks[e] = g = Z.test(e) ? this.mouseHooks : Y.test(e) ? this.keyHooks : {}), d = g.props ? this.props.concat(g.props) : this.props, a = new m.Event(f), b = d.length;
                while (b--) c = d[b], a[c] = f[c];
                return a.target || (a.target = f.srcElement || y), 3 === a.target.nodeType && (a.target = a.target.parentNode), a.metaKey = !!a.metaKey, g.filter ? g.filter(a, f) : a
            },
            props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
            fixHooks: {},
            keyHooks: {
                props: "char charCode key keyCode".split(" "), filter: function (a, b) {
                    return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), a
                }
            },
            mouseHooks: {
                props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
                filter: function (a, b) {
                    var c, d, e, f = b.button, g = b.fromElement;
                    return null == a.pageX && null != b.clientX && (d = a.target.ownerDocument || y, e = d.documentElement, c = d.body, a.pageX = b.clientX + (e && e.scrollLeft || c && c.scrollLeft || 0) - (e && e.clientLeft || c && c.clientLeft || 0), a.pageY = b.clientY + (e && e.scrollTop || c && c.scrollTop || 0) - (e && e.clientTop || c && c.clientTop || 0)), !a.relatedTarget && g && (a.relatedTarget = g === a.target ? b.toElement : g), a.which || void 0 === f || (a.which = 1 & f ? 1 : 2 & f ? 3 : 4 & f ? 2 : 0), a
                }
            },
            special: {
                load: {noBubble: !0}, focus: {
                    trigger: function () {
                        if (this !== ca() && this.focus) try {
                            return this.focus(), !1
                        } catch (a) {
                        }
                    }, delegateType: "focusin"
                }, blur: {
                    trigger: function () {
                        return this === ca() && this.blur ? (this.blur(), !1) : void 0
                    }, delegateType: "focusout"
                }, click: {
                    trigger: function () {
                        return m.nodeName(this, "input") && "checkbox" === this.type && this.click ? (this.click(), !1) : void 0
                    }, _default: function (a) {
                        return m.nodeName(a.target, "a")
                    }
                }, beforeunload: {
                    postDispatch: function (a) {
                        void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result)
                    }
                }
            },
            simulate: function (a, b, c, d) {
                var e = m.extend(new m.Event, c, {type: a, isSimulated: !0, originalEvent: {}});
                d ? m.event.trigger(e, null, b) : m.event.dispatch.call(b, e), e.isDefaultPrevented() && c.preventDefault()
            }
        }, m.removeEvent = y.removeEventListener ? function (a, b, c) {
            a.removeEventListener && a.removeEventListener(b, c, !1)
        } : function (a, b, c) {
            var d = "on" + b;
            a.detachEvent && (typeof a[d] === K && (a[d] = null), a.detachEvent(d, c))
        }, m.Event = function (a, b) {
            return this instanceof m.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? aa : ba) : this.type = a, b && m.extend(this, b), this.timeStamp = a && a.timeStamp || m.now(), void(this[m.expando] = !0)) : new m.Event(a, b)
        }, m.Event.prototype = {
            isDefaultPrevented: ba,
            isPropagationStopped: ba,
            isImmediatePropagationStopped: ba,
            preventDefault: function () {
                var a = this.originalEvent;
                this.isDefaultPrevented = aa, a && (a.preventDefault ? a.preventDefault() : a.returnValue = !1)
            },
            stopPropagation: function () {
                var a = this.originalEvent;
                this.isPropagationStopped = aa, a && (a.stopPropagation && a.stopPropagation(), a.cancelBubble = !0)
            },
            stopImmediatePropagation: function () {
                var a = this.originalEvent;
                this.isImmediatePropagationStopped = aa, a && a.stopImmediatePropagation && a.stopImmediatePropagation(), this.stopPropagation()
            }
        }, m.each({
            mouseenter: "mouseover",
            mouseleave: "mouseout",
            pointerenter: "pointerover",
            pointerleave: "pointerout"
        }, function (a, b) {
            m.event.special[a] = {
                delegateType: b, bindType: b, handle: function (a) {
                    var c, d = this, e = a.relatedTarget, f = a.handleObj;
                    return (!e || e !== d && !m.contains(d, e)) && (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c
                }
            }
        }), k.submitBubbles || (m.event.special.submit = {
            setup: function () {
                return m.nodeName(this, "form") ? !1 : void m.event.add(this, "click._submit keypress._submit", function (a) {
                    var b = a.target, c = m.nodeName(b, "input") || m.nodeName(b, "button") ? b.form : void 0;
                    c && !m._data(c, "submitBubbles") && (m.event.add(c, "submit._submit", function (a) {
                        a._submit_bubble = !0
                    }), m._data(c, "submitBubbles", !0))
                })
            }, postDispatch: function (a) {
                a._submit_bubble && (delete a._submit_bubble, this.parentNode && !a.isTrigger && m.event.simulate("submit", this.parentNode, a, !0))
            }, teardown: function () {
                return m.nodeName(this, "form") ? !1 : void m.event.remove(this, "._submit")
            }
        }), k.changeBubbles || (m.event.special.change = {
            setup: function () {
                return X.test(this.nodeName) ? (("checkbox" === this.type || "radio" === this.type) && (m.event.add(this, "propertychange._change", function (a) {
                    "checked" === a.originalEvent.propertyName && (this._just_changed = !0)
                }), m.event.add(this, "click._change", function (a) {
                    this._just_changed && !a.isTrigger && (this._just_changed = !1), m.event.simulate("change", this, a, !0)
                })), !1) : void m.event.add(this, "beforeactivate._change", function (a) {
                    var b = a.target;
                    X.test(b.nodeName) && !m._data(b, "changeBubbles") && (m.event.add(b, "change._change", function (a) {
                        !this.parentNode || a.isSimulated || a.isTrigger || m.event.simulate("change", this.parentNode, a, !0)
                    }), m._data(b, "changeBubbles", !0))
                })
            }, handle: function (a) {
                var b = a.target;
                return this !== b || a.isSimulated || a.isTrigger || "radio" !== b.type && "checkbox" !== b.type ? a.handleObj.handler.apply(this, arguments) : void 0
            }, teardown: function () {
                return m.event.remove(this, "._change"), !X.test(this.nodeName)
            }
        }), k.focusinBubbles || m.each({focus: "focusin", blur: "focusout"}, function (a, b) {
            var c = function (a) {
                m.event.simulate(b, a.target, m.event.fix(a), !0)
            };
            m.event.special[b] = {
                setup: function () {
                    var d = this.ownerDocument || this, e = m._data(d, b);
                    e || d.addEventListener(a, c, !0), m._data(d, b, (e || 0) + 1)
                }, teardown: function () {
                    var d = this.ownerDocument || this, e = m._data(d, b) - 1;
                    e ? m._data(d, b, e) : (d.removeEventListener(a, c, !0), m._removeData(d, b))
                }
            }
        }), m.fn.extend({
            on: function (a, b, c, d, e) {
                var f, g;
                if ("object" == typeof a) {
                    "string" != typeof b && (c = c || b, b = void 0);
                    for (f in a) this.on(f, b, c, a[f], e);
                    return this
                }
                if (null == c && null == d ? (d = b, c = b = void 0) : null == d && ("string" == typeof b ? (d = c, c = void 0) : (d = c, c = b, b = void 0)), d === !1) d = ba; else if (!d) return this;
                return 1 === e && (g = d, d = function (a) {
                    return m().off(a), g.apply(this, arguments)
                }, d.guid = g.guid || (g.guid = m.guid++)), this.each(function () {
                    m.event.add(this, a, d, c, b)
                })
            }, one: function (a, b, c, d) {
                return this.on(a, b, c, d, 1)
            }, off: function (a, b, c) {
                var d, e;
                if (a && a.preventDefault && a.handleObj) return d = a.handleObj, m(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler), this;
                if ("object" == typeof a) {
                    for (e in a) this.off(e, b, a[e]);
                    return this
                }
                return (b === !1 || "function" == typeof b) && (c = b, b = void 0), c === !1 && (c = ba), this.each(function () {
                    m.event.remove(this, a, c, b)
                })
            }, trigger: function (a, b) {
                return this.each(function () {
                    m.event.trigger(a, b, this)
                })
            }, triggerHandler: function (a, b) {
                var c = this[0];
                return c ? m.event.trigger(a, b, c, !0) : void 0
            }
        });

        function da(a) {
            var b = ea.split("|"), c = a.createDocumentFragment();
            if (c.createElement) while (b.length) c.createElement(b.pop());
            return c
        }

        var ea = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
            fa = / jQuery\d+="(?:null|\d+)"/g, ga = new RegExp("<(?:" + ea + ")[\\s/>]", "i"), ha = /^\s+/,
            ia = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, ja = /<([\w:]+)/,
            ka = /<tbody/i, la = /<|&#?\w+;/, ma = /<(?:script|style|link)/i, na = /checked\s*(?:[^=]|=\s*.checked.)/i,
            oa = /^$|\/(?:java|ecma)script/i, pa = /^true\/(.*)/, qa = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
            ra = {
                option: [1, "<select multiple='multiple'>", "</select>"],
                legend: [1, "<fieldset>", "</fieldset>"],
                area: [1, "<map>", "</map>"],
                param: [1, "<object>", "</object>"],
                thead: [1, "<table>", "</table>"],
                tr: [2, "<table><tbody>", "</tbody></table>"],
                col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
                td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
                _default: k.htmlSerialize ? [0, "", ""] : [1, "X<div>", "</div>"]
            }, sa = da(y), ta = sa.appendChild(y.createElement("div"));
        ra.optgroup = ra.option, ra.tbody = ra.tfoot = ra.colgroup = ra.caption = ra.thead, ra.th = ra.td;

        function ua(a, b) {
            var c, d, e = 0,
                f = typeof a.getElementsByTagName !== K ? a.getElementsByTagName(b || "*") : typeof a.querySelectorAll !== K ? a.querySelectorAll(b || "*") : void 0;
            if (!f) for (f = [], c = a.childNodes || a; null != (d = c[e]); e++) !b || m.nodeName(d, b) ? f.push(d) : m.merge(f, ua(d, b));
            return void 0 === b || b && m.nodeName(a, b) ? m.merge([a], f) : f
        }

        function va(a) {
            W.test(a.type) && (a.defaultChecked = a.checked)
        }

        function wa(a, b) {
            return m.nodeName(a, "table") && m.nodeName(11 !== b.nodeType ? b : b.firstChild, "tr") ? a.getElementsByTagName("tbody")[0] || a.appendChild(a.ownerDocument.createElement("tbody")) : a
        }

        function xa(a) {
            return a.type = (null !== m.find.attr(a, "type")) + "/" + a.type, a
        }

        function ya(a) {
            var b = pa.exec(a.type);
            return b ? a.type = b[1] : a.removeAttribute("type"), a
        }

        function za(a, b) {
            for (var c, d = 0; null != (c = a[d]); d++) m._data(c, "globalEval", !b || m._data(b[d], "globalEval"))
        }

        function Aa(a, b) {
            if (1 === b.nodeType && m.hasData(a)) {
                var c, d, e, f = m._data(a), g = m._data(b, f), h = f.events;
                if (h) {
                    delete g.handle, g.events = {};
                    for (c in h) for (d = 0, e = h[c].length; e > d; d++) m.event.add(b, c, h[c][d])
                }
                g.data && (g.data = m.extend({}, g.data))
            }
        }

        function Ba(a, b) {
            var c, d, e;
            if (1 === b.nodeType) {
                if (c = b.nodeName.toLowerCase(), !k.noCloneEvent && b[m.expando]) {
                    e = m._data(b);
                    for (d in e.events) m.removeEvent(b, d, e.handle);
                    b.removeAttribute(m.expando)
                }
                "script" === c && b.text !== a.text ? (xa(b).text = a.text, ya(b)) : "object" === c ? (b.parentNode && (b.outerHTML = a.outerHTML), k.html5Clone && a.innerHTML && !m.trim(b.innerHTML) && (b.innerHTML = a.innerHTML)) : "input" === c && W.test(a.type) ? (b.defaultChecked = b.checked = a.checked, b.value !== a.value && (b.value = a.value)) : "option" === c ? b.defaultSelected = b.selected = a.defaultSelected : ("input" === c || "textarea" === c) && (b.defaultValue = a.defaultValue)
            }
        }

        m.extend({
            clone: function (a, b, c) {
                var d, e, f, g, h, i = m.contains(a.ownerDocument, a);
                if (k.html5Clone || m.isXMLDoc(a) || !ga.test("<" + a.nodeName + ">") ? f = a.cloneNode(!0) : (ta.innerHTML = a.outerHTML, ta.removeChild(f = ta.firstChild)), !(k.noCloneEvent && k.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || m.isXMLDoc(a))) for (d = ua(f), h = ua(a), g = 0; null != (e = h[g]); ++g) d[g] && Ba(e, d[g]);
                if (b) if (c) for (h = h || ua(a), d = d || ua(f), g = 0; null != (e = h[g]); g++) Aa(e, d[g]); else Aa(a, f);
                return d = ua(f, "script"), d.length > 0 && za(d, !i && ua(a, "script")), d = h = e = null, f
            }, buildFragment: function (a, b, c, d) {
                for (var e, f, g, h, i, j, l, n = a.length, o = da(b), p = [], q = 0; n > q; q++) if (f = a[q], f || 0 === f) if ("object" === m.type(f)) m.merge(p, f.nodeType ? [f] : f); else if (la.test(f)) {
                    h = h || o.appendChild(b.createElement("div")), i = (ja.exec(f) || ["", ""])[1].toLowerCase(), l = ra[i] || ra._default, h.innerHTML = l[1] + f.replace(ia, "<$1></$2>") + l[2], e = l[0];
                    while (e--) h = h.lastChild;
                    if (!k.leadingWhitespace && ha.test(f) && p.push(b.createTextNode(ha.exec(f)[0])), !k.tbody) {
                        f = "table" !== i || ka.test(f) ? "<table>" !== l[1] || ka.test(f) ? 0 : h : h.firstChild, e = f && f.childNodes.length;
                        while (e--) m.nodeName(j = f.childNodes[e], "tbody") && !j.childNodes.length && f.removeChild(j)
                    }
                    m.merge(p, h.childNodes), h.textContent = "";
                    while (h.firstChild) h.removeChild(h.firstChild);
                    h = o.lastChild
                } else p.push(b.createTextNode(f));
                h && o.removeChild(h), k.appendChecked || m.grep(ua(p, "input"), va), q = 0;
                while (f = p[q++]) if ((!d || -1 === m.inArray(f, d)) && (g = m.contains(f.ownerDocument, f), h = ua(o.appendChild(f), "script"), g && za(h), c)) {
                    e = 0;
                    while (f = h[e++]) oa.test(f.type || "") && c.push(f)
                }
                return h = null, o
            }, cleanData: function (a, b) {
                for (var d, e, f, g, h = 0, i = m.expando, j = m.cache, l = k.deleteExpando, n = m.event.special; null != (d = a[h]); h++) if ((b || m.acceptData(d)) && (f = d[i], g = f && j[f])) {
                    if (g.events) for (e in g.events) n[e] ? m.event.remove(d, e) : m.removeEvent(d, e, g.handle);
                    j[f] && (delete j[f], l ? delete d[i] : typeof d.removeAttribute !== K ? d.removeAttribute(i) : d[i] = null, c.push(f))
                }
            }
        }), m.fn.extend({
            text: function (a) {
                return V(this, function (a) {
                    return void 0 === a ? m.text(this) : this.empty().append((this[0] && this[0].ownerDocument || y).createTextNode(a))
                }, null, a, arguments.length)
            }, append: function () {
                return this.domManip(arguments, function (a) {
                    if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                        var b = wa(this, a);
                        b.appendChild(a)
                    }
                })
            }, prepend: function () {
                return this.domManip(arguments, function (a) {
                    if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                        var b = wa(this, a);
                        b.insertBefore(a, b.firstChild)
                    }
                })
            }, before: function () {
                return this.domManip(arguments, function (a) {
                    this.parentNode && this.parentNode.insertBefore(a, this)
                })
            }, after: function () {
                return this.domManip(arguments, function (a) {
                    this.parentNode && this.parentNode.insertBefore(a, this.nextSibling)
                })
            }, remove: function (a, b) {
                for (var c, d = a ? m.filter(a, this) : this, e = 0; null != (c = d[e]); e++) b || 1 !== c.nodeType || m.cleanData(ua(c)), c.parentNode && (b && m.contains(c.ownerDocument, c) && za(ua(c, "script")), c.parentNode.removeChild(c));
                return this
            }, empty: function () {
                for (var a, b = 0; null != (a = this[b]); b++) {
                    1 === a.nodeType && m.cleanData(ua(a, !1));
                    while (a.firstChild) a.removeChild(a.firstChild);
                    a.options && m.nodeName(a, "select") && (a.options.length = 0)
                }
                return this
            }, clone: function (a, b) {
                return a = null == a ? !1 : a, b = null == b ? a : b, this.map(function () {
                    return m.clone(this, a, b)
                })
            }, html: function (a) {
                return V(this, function (a) {
                    var b = this[0] || {}, c = 0, d = this.length;
                    if (void 0 === a) return 1 === b.nodeType ? b.innerHTML.replace(fa, "") : void 0;
                    if (!("string" != typeof a || ma.test(a) || !k.htmlSerialize && ga.test(a) || !k.leadingWhitespace && ha.test(a) || ra[(ja.exec(a) || ["", ""])[1].toLowerCase()])) {
                        a = a.replace(ia, "<$1></$2>");
                        try {
                            for (; d > c; c++) b = this[c] || {}, 1 === b.nodeType && (m.cleanData(ua(b, !1)), b.innerHTML = a);
                            b = 0
                        } catch (e) {
                        }
                    }
                    b && this.empty().append(a)
                }, null, a, arguments.length)
            }, replaceWith: function () {
                var a = arguments[0];
                return this.domManip(arguments, function (b) {
                    a = this.parentNode, m.cleanData(ua(this)), a && a.replaceChild(b, this)
                }), a && (a.length || a.nodeType) ? this : this.remove()
            }, detach: function (a) {
                return this.remove(a, !0)
            }, domManip: function (a, b) {
                a = e.apply([], a);
                var c, d, f, g, h, i, j = 0, l = this.length, n = this, o = l - 1, p = a[0], q = m.isFunction(p);
                if (q || l > 1 && "string" == typeof p && !k.checkClone && na.test(p)) return this.each(function (c) {
                    var d = n.eq(c);
                    q && (a[0] = p.call(this, c, d.html())), d.domManip(a, b)
                });
                if (l && (i = m.buildFragment(a, this[0].ownerDocument, !1, this), c = i.firstChild, 1 === i.childNodes.length && (i = c), c)) {
                    for (g = m.map(ua(i, "script"), xa), f = g.length; l > j; j++) d = i, j !== o && (d = m.clone(d, !0, !0), f && m.merge(g, ua(d, "script"))), b.call(this[j], d, j);
                    if (f) for (h = g[g.length - 1].ownerDocument, m.map(g, ya), j = 0; f > j; j++) d = g[j], oa.test(d.type || "") && !m._data(d, "globalEval") && m.contains(h, d) && (d.src ? m._evalUrl && m._evalUrl(d.src) : m.globalEval((d.text || d.textContent || d.innerHTML || "").replace(qa, "")));
                    i = c = null
                }
                return this
            }
        }), m.each({
            appendTo: "append",
            prependTo: "prepend",
            insertBefore: "before",
            insertAfter: "after",
            replaceAll: "replaceWith"
        }, function (a, b) {
            m.fn[a] = function (a) {
                for (var c, d = 0, e = [], g = m(a), h = g.length - 1; h >= d; d++) c = d === h ? this : this.clone(!0), m(g[d])[b](c), f.apply(e, c.get());
                return this.pushStack(e)
            }
        });
        var Ca, Da = {};

        function Ea(b, c) {
            var d, e = m(c.createElement(b)).appendTo(c.body),
                f = a.getDefaultComputedStyle && (d = a.getDefaultComputedStyle(e[0])) ? d.display : m.css(e[0], "display");
            return e.detach(), f
        }

        function Fa(a) {
            var b = y, c = Da[a];
            return c || (c = Ea(a, b), "none" !== c && c || (Ca = (Ca || m("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement), b = (Ca[0].contentWindow || Ca[0].contentDocument).document, b.write(), b.close(), c = Ea(a, b), Ca.detach()), Da[a] = c), c
        }

        !function () {
            var a;
            k.shrinkWrapBlocks = function () {
                if (null != a) return a;
                a = !1;
                var b, c, d;
                return c = y.getElementsByTagName("body")[0], c && c.style ? (b = y.createElement("div"), d = y.createElement("div"), d.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", c.appendChild(d).appendChild(b), typeof b.style.zoom !== K && (b.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:1px;width:1px;zoom:1", b.appendChild(y.createElement("div")).style.width = "5px", a = 3 !== b.offsetWidth), c.removeChild(d), a) : void 0
            }
        }();
        var Ga = /^margin/, Ha = new RegExp("^(" + S + ")(?!px)[a-z%]+$", "i"), Ia, Ja,
            Ka = /^(top|right|bottom|left)$/;
        a.getComputedStyle ? (Ia = function (b) {
            return b.ownerDocument.defaultView.opener ? b.ownerDocument.defaultView.getComputedStyle(b, null) : a.getComputedStyle(b, null)
        }, Ja = function (a, b, c) {
            var d, e, f, g, h = a.style;
            return c = c || Ia(a), g = c ? c.getPropertyValue(b) || c[b] : void 0, c && ("" !== g || m.contains(a.ownerDocument, a) || (g = m.style(a, b)), Ha.test(g) && Ga.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 === g ? g : g + ""
        }) : y.documentElement.currentStyle && (Ia = function (a) {
            return a.currentStyle
        }, Ja = function (a, b, c) {
            var d, e, f, g, h = a.style;
            return c = c || Ia(a), g = c ? c[b] : void 0, null == g && h && h[b] && (g = h[b]), Ha.test(g) && !Ka.test(b) && (d = h.left, e = a.runtimeStyle, f = e && e.left, f && (e.left = a.currentStyle.left), h.left = "fontSize" === b ? "1em" : g, g = h.pixelLeft + "px", h.left = d, f && (e.left = f)), void 0 === g ? g : g + "" || "auto"
        });

        function La(a, b) {
            return {
                get: function () {
                    var c = a();
                    if (null != c) return c ? void delete this.get : (this.get = b).apply(this, arguments)
                }
            }
        }

        !function () {
            var b, c, d, e, f, g, h;
            if (b = y.createElement("div"), b.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", d = b.getElementsByTagName("a")[0], c = d && d.style) {
                c.cssText = "float:left;opacity:.5", k.opacity = "0.5" === c.opacity, k.cssFloat = !!c.cssFloat, b.style.backgroundClip = "content-box", b.cloneNode(!0).style.backgroundClip = "", k.clearCloneStyle = "content-box" === b.style.backgroundClip, k.boxSizing = "" === c.boxSizing || "" === c.MozBoxSizing || "" === c.WebkitBoxSizing, m.extend(k, {
                    reliableHiddenOffsets: function () {
                        return null == g && i(), g
                    }, boxSizingReliable: function () {
                        return null == f && i(), f
                    }, pixelPosition: function () {
                        return null == e && i(), e
                    }, reliableMarginRight: function () {
                        return null == h && i(), h
                    }
                });

                function i() {
                    var b, c, d, i;
                    c = y.getElementsByTagName("body")[0], c && c.style && (b = y.createElement("div"), d = y.createElement("div"), d.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", c.appendChild(d).appendChild(b), b.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute", e = f = !1, h = !0, a.getComputedStyle && (e = "1%" !== (a.getComputedStyle(b, null) || {}).top, f = "4px" === (a.getComputedStyle(b, null) || {width: "4px"}).width, i = b.appendChild(y.createElement("div")), i.style.cssText = b.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", i.style.marginRight = i.style.width = "0", b.style.width = "1px", h = !parseFloat((a.getComputedStyle(i, null) || {}).marginRight), b.removeChild(i)), b.innerHTML = "<table><tr><td></td><td>t</td></tr></table>", i = b.getElementsByTagName("td"), i[0].style.cssText = "margin:0;border:0;padding:0;display:none", g = 0 === i[0].offsetHeight, g && (i[0].style.display = "", i[1].style.display = "none", g = 0 === i[0].offsetHeight), c.removeChild(d))
                }
            }
        }(), m.swap = function (a, b, c, d) {
            var e, f, g = {};
            for (f in b) g[f] = a.style[f], a.style[f] = b[f];
            e = c.apply(a, d || []);
            for (f in b) a.style[f] = g[f];
            return e
        };
        var Ma = /alpha\([^)]*\)/i, Na = /opacity\s*=\s*([^)]*)/, Oa = /^(none|table(?!-c[ea]).+)/,
            Pa = new RegExp("^(" + S + ")(.*)$", "i"), Qa = new RegExp("^([+-])=(" + S + ")", "i"),
            Ra = {position: "absolute", visibility: "hidden", display: "block"},
            Sa = {letterSpacing: "0", fontWeight: "400"}, Ta = ["Webkit", "O", "Moz", "ms"];

        function Ua(a, b) {
            if (b in a) return b;
            var c = b.charAt(0).toUpperCase() + b.slice(1), d = b, e = Ta.length;
            while (e--) if (b = Ta[e] + c, b in a) return b;
            return d
        }

        function Va(a, b) {
            for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++) d = a[g], d.style && (f[g] = m._data(d, "olddisplay"), c = d.style.display, b ? (f[g] || "none" !== c || (d.style.display = ""), "" === d.style.display && U(d) && (f[g] = m._data(d, "olddisplay", Fa(d.nodeName)))) : (e = U(d), (c && "none" !== c || !e) && m._data(d, "olddisplay", e ? c : m.css(d, "display"))));
            for (g = 0; h > g; g++) d = a[g], d.style && (b && "none" !== d.style.display && "" !== d.style.display || (d.style.display = b ? f[g] || "" : "none"));
            return a
        }

        function Wa(a, b, c) {
            var d = Pa.exec(b);
            return d ? Math.max(0, d[1] - (c || 0)) + (d[2] || "px") : b
        }

        function Xa(a, b, c, d, e) {
            for (var f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0, g = 0; 4 > f; f += 2) "margin" === c && (g += m.css(a, c + T[f], !0, e)), d ? ("content" === c && (g -= m.css(a, "padding" + T[f], !0, e)), "margin" !== c && (g -= m.css(a, "border" + T[f] + "Width", !0, e))) : (g += m.css(a, "padding" + T[f], !0, e), "padding" !== c && (g += m.css(a, "border" + T[f] + "Width", !0, e)));
            return g
        }

        function Ya(a, b, c) {
            var d = !0, e = "width" === b ? a.offsetWidth : a.offsetHeight, f = Ia(a),
                g = k.boxSizing && "border-box" === m.css(a, "boxSizing", !1, f);
            if (0 >= e || null == e) {
                if (e = Ja(a, b, f), (0 > e || null == e) && (e = a.style[b]), Ha.test(e)) return e;
                d = g && (k.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0
            }
            return e + Xa(a, b, c || (g ? "border" : "content"), d, f) + "px"
        }

        m.extend({
            cssHooks: {
                opacity: {
                    get: function (a, b) {
                        if (b) {
                            var c = Ja(a, "opacity");
                            return "" === c ? "1" : c
                        }
                    }
                }
            },
            cssNumber: {
                columnCount: !0,
                fillOpacity: !0,
                flexGrow: !0,
                flexShrink: !0,
                fontWeight: !0,
                lineHeight: !0,
                opacity: !0,
                order: !0,
                orphans: !0,
                widows: !0,
                zIndex: !0,
                zoom: !0
            },
            cssProps: {"float": k.cssFloat ? "cssFloat" : "styleFloat"},
            style: function (a, b, c, d) {
                if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {
                    var e, f, g, h = m.camelCase(b), i = a.style;
                    if (b = m.cssProps[h] || (m.cssProps[h] = Ua(i, h)), g = m.cssHooks[b] || m.cssHooks[h], void 0 === c) return g && "get" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b];
                    if (f = typeof c, "string" === f && (e = Qa.exec(c)) && (c = (e[1] + 1) * e[2] + parseFloat(m.css(a, b)), f = "number"), null != c && c === c && ("number" !== f || m.cssNumber[h] || (c += "px"), k.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (i[b] = "inherit"), !(g && "set" in g && void 0 === (c = g.set(a, c, d))))) try {
                        i[b] = c
                    } catch (j) {
                    }
                }
            },
            css: function (a, b, c, d) {
                var e, f, g, h = m.camelCase(b);
                return b = m.cssProps[h] || (m.cssProps[h] = Ua(a.style, h)), g = m.cssHooks[b] || m.cssHooks[h], g && "get" in g && (f = g.get(a, !0, c)), void 0 === f && (f = Ja(a, b, d)), "normal" === f && b in Sa && (f = Sa[b]), "" === c || c ? (e = parseFloat(f), c === !0 || m.isNumeric(e) ? e || 0 : f) : f
            }
        }), m.each(["height", "width"], function (a, b) {
            m.cssHooks[b] = {
                get: function (a, c, d) {
                    return c ? Oa.test(m.css(a, "display")) && 0 === a.offsetWidth ? m.swap(a, Ra, function () {
                        return Ya(a, b, d)
                    }) : Ya(a, b, d) : void 0
                }, set: function (a, c, d) {
                    var e = d && Ia(a);
                    return Wa(a, c, d ? Xa(a, b, d, k.boxSizing && "border-box" === m.css(a, "boxSizing", !1, e), e) : 0)
                }
            }
        }), k.opacity || (m.cssHooks.opacity = {
            get: function (a, b) {
                return Na.test((b && a.currentStyle ? a.currentStyle.filter : a.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : b ? "1" : ""
            }, set: function (a, b) {
                var c = a.style, d = a.currentStyle, e = m.isNumeric(b) ? "alpha(opacity=" + 100 * b + ")" : "",
                    f = d && d.filter || c.filter || "";
                c.zoom = 1, (b >= 1 || "" === b) && "" === m.trim(f.replace(Ma, "")) && c.removeAttribute && (c.removeAttribute("filter"), "" === b || d && !d.filter) || (c.filter = Ma.test(f) ? f.replace(Ma, e) : f + " " + e)
            }
        }), m.cssHooks.marginRight = La(k.reliableMarginRight, function (a, b) {
            return b ? m.swap(a, {display: "inline-block"}, Ja, [a, "marginRight"]) : void 0
        }), m.each({margin: "", padding: "", border: "Width"}, function (a, b) {
            m.cssHooks[a + b] = {
                expand: function (c) {
                    for (var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [c]; 4 > d; d++) e[a + T[d] + b] = f[d] || f[d - 2] || f[0];
                    return e
                }
            }, Ga.test(a) || (m.cssHooks[a + b].set = Wa)
        }), m.fn.extend({
            css: function (a, b) {
                return V(this, function (a, b, c) {
                    var d, e, f = {}, g = 0;
                    if (m.isArray(b)) {
                        for (d = Ia(a), e = b.length; e > g; g++) f[b[g]] = m.css(a, b[g], !1, d);
                        return f
                    }
                    return void 0 !== c ? m.style(a, b, c) : m.css(a, b)
                }, a, b, arguments.length > 1)
            }, show: function () {
                return Va(this, !0)
            }, hide: function () {
                return Va(this)
            }, toggle: function (a) {
                return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function () {
                    U(this) ? m(this).show() : m(this).hide()
                })
            }
        });

        function Za(a, b, c, d, e) {
            return new Za.prototype.init(a, b, c, d, e)
        }

        m.Tween = Za, Za.prototype = {
            constructor: Za, init: function (a, b, c, d, e, f) {
                this.elem = a, this.prop = c, this.easing = e || "swing", this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (m.cssNumber[c] ? "" : "px")
            }, cur: function () {
                var a = Za.propHooks[this.prop];
                return a && a.get ? a.get(this) : Za.propHooks._default.get(this)
            }, run: function (a) {
                var b, c = Za.propHooks[this.prop];
                return this.options.duration ? this.pos = b = m.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : this.pos = b = a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : Za.propHooks._default.set(this), this
            }
        }, Za.prototype.init.prototype = Za.prototype, Za.propHooks = {
            _default: {
                get: function (a) {
                    var b;
                    return null == a.elem[a.prop] || a.elem.style && null != a.elem.style[a.prop] ? (b = m.css(a.elem, a.prop, ""), b && "auto" !== b ? b : 0) : a.elem[a.prop]
                }, set: function (a) {
                    m.fx.step[a.prop] ? m.fx.step[a.prop](a) : a.elem.style && (null != a.elem.style[m.cssProps[a.prop]] || m.cssHooks[a.prop]) ? m.style(a.elem, a.prop, a.now + a.unit) : a.elem[a.prop] = a.now
                }
            }
        }, Za.propHooks.scrollTop = Za.propHooks.scrollLeft = {
            set: function (a) {
                a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now)
            }
        }, m.easing = {
            linear: function (a) {
                return a
            }, swing: function (a) {
                return .5 - Math.cos(a * Math.PI) / 2
            }
        }, m.fx = Za.prototype.init, m.fx.step = {};
        var $a, _a, ab = /^(?:toggle|show|hide)$/, bb = new RegExp("^(?:([+-])=|)(" + S + ")([a-z%]*)$", "i"),
            cb = /queueHooks$/, db = [ib], eb = {
                "*": [function (a, b) {
                    var c = this.createTween(a, b), d = c.cur(), e = bb.exec(b),
                        f = e && e[3] || (m.cssNumber[a] ? "" : "px"),
                        g = (m.cssNumber[a] || "px" !== f && +d) && bb.exec(m.css(c.elem, a)), h = 1, i = 20;
                    if (g && g[3] !== f) {
                        f = f || g[3], e = e || [], g = +d || 1;
                        do h = h || ".5", g /= h, m.style(c.elem, a, g + f); while (h !== (h = c.cur() / d) && 1 !== h && --i)
                    }
                    return e && (g = c.start = +g || +d || 0, c.unit = f, c.end = e[1] ? g + (e[1] + 1) * e[2] : +e[2]), c
                }]
            };

        function fb() {
            return setTimeout(function () {
                $a = void 0
            }), $a = m.now()
        }

        function gb(a, b) {
            var c, d = {height: a}, e = 0;
            for (b = b ? 1 : 0; 4 > e; e += 2 - b) c = T[e], d["margin" + c] = d["padding" + c] = a;
            return b && (d.opacity = d.width = a), d
        }

        function hb(a, b, c) {
            for (var d, e = (eb[b] || []).concat(eb["*"]), f = 0, g = e.length; g > f; f++) if (d = e[f].call(c, b, a)) return d
        }

        function ib(a, b, c) {
            var d, e, f, g, h, i, j, l, n = this, o = {}, p = a.style, q = a.nodeType && U(a), r = m._data(a, "fxshow");
            c.queue || (h = m._queueHooks(a, "fx"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function () {
                h.unqueued || i()
            }), h.unqueued++, n.always(function () {
                n.always(function () {
                    h.unqueued--, m.queue(a, "fx").length || h.empty.fire()
                })
            })), 1 === a.nodeType && ("height" in b || "width" in b) && (c.overflow = [p.overflow, p.overflowX, p.overflowY], j = m.css(a, "display"), l = "none" === j ? m._data(a, "olddisplay") || Fa(a.nodeName) : j, "inline" === l && "none" === m.css(a, "float") && (k.inlineBlockNeedsLayout && "inline" !== Fa(a.nodeName) ? p.zoom = 1 : p.display = "inline-block")), c.overflow && (p.overflow = "hidden", k.shrinkWrapBlocks() || n.always(function () {
                p.overflow = c.overflow[0], p.overflowX = c.overflow[1], p.overflowY = c.overflow[2]
            }));
            for (d in b) if (e = b[d], ab.exec(e)) {
                if (delete b[d], f = f || "toggle" === e, e === (q ? "hide" : "show")) {
                    if ("show" !== e || !r || void 0 === r[d]) continue;
                    q = !0
                }
                o[d] = r && r[d] || m.style(a, d)
            } else j = void 0;
            if (m.isEmptyObject(o)) "inline" === ("none" === j ? Fa(a.nodeName) : j) && (p.display = j); else {
                r ? "hidden" in r && (q = r.hidden) : r = m._data(a, "fxshow", {}), f && (r.hidden = !q), q ? m(a).show() : n.done(function () {
                    m(a).hide()
                }), n.done(function () {
                    var b;
                    m._removeData(a, "fxshow");
                    for (b in o) m.style(a, b, o[b])
                });
                for (d in o) g = hb(q ? r[d] : 0, d, n), d in r || (r[d] = g.start, q && (g.end = g.start, g.start = "width" === d || "height" === d ? 1 : 0))
            }
        }

        function jb(a, b) {
            var c, d, e, f, g;
            for (c in a) if (d = m.camelCase(c), e = b[d], f = a[c], m.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = m.cssHooks[d], g && "expand" in g) {
                f = g.expand(f), delete a[d];
                for (c in f) c in a || (a[c] = f[c], b[c] = e)
            } else b[d] = e
        }

        function kb(a, b, c) {
            var d, e, f = 0, g = db.length, h = m.Deferred().always(function () {
                delete i.elem
            }), i = function () {
                if (e) return !1;
                for (var b = $a || fb(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++) j.tweens[g].run(f);
                return h.notifyWith(a, [j, f, c]), 1 > f && i ? c : (h.resolveWith(a, [j]), !1)
            }, j = h.promise({
                elem: a,
                props: m.extend({}, b),
                opts: m.extend(!0, {specialEasing: {}}, c),
                originalProperties: b,
                originalOptions: c,
                startTime: $a || fb(),
                duration: c.duration,
                tweens: [],
                createTween: function (b, c) {
                    var d = m.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);
                    return j.tweens.push(d), d
                },
                stop: function (b) {
                    var c = 0, d = b ? j.tweens.length : 0;
                    if (e) return this;
                    for (e = !0; d > c; c++) j.tweens[c].run(1);
                    return b ? h.resolveWith(a, [j, b]) : h.rejectWith(a, [j, b]), this
                }
            }), k = j.props;
            for (jb(k, j.opts.specialEasing); g > f; f++) if (d = db[f].call(j, a, k, j.opts)) return d;
            return m.map(k, hb, j), m.isFunction(j.opts.start) && j.opts.start.call(a, j), m.fx.timer(m.extend(i, {
                elem: a,
                anim: j,
                queue: j.opts.queue
            })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always)
        }

        m.Animation = m.extend(kb, {
            tweener: function (a, b) {
                m.isFunction(a) ? (b = a, a = ["*"]) : a = a.split(" ");
                for (var c, d = 0, e = a.length; e > d; d++) c = a[d], eb[c] = eb[c] || [], eb[c].unshift(b)
            }, prefilter: function (a, b) {
                b ? db.unshift(a) : db.push(a)
            }
        }), m.speed = function (a, b, c) {
            var d = a && "object" == typeof a ? m.extend({}, a) : {
                complete: c || !c && b || m.isFunction(a) && a,
                duration: a,
                easing: c && b || b && !m.isFunction(b) && b
            };
            return d.duration = m.fx.off ? 0 : "number" == typeof d.duration ? d.duration : d.duration in m.fx.speeds ? m.fx.speeds[d.duration] : m.fx.speeds._default, (null == d.queue || d.queue === !0) && (d.queue = "fx"), d.old = d.complete, d.complete = function () {
                m.isFunction(d.old) && d.old.call(this), d.queue && m.dequeue(this, d.queue)
            }, d
        }, m.fn.extend({
            fadeTo: function (a, b, c, d) {
                return this.filter(U).css("opacity", 0).show().end().animate({opacity: b}, a, c, d)
            }, animate: function (a, b, c, d) {
                var e = m.isEmptyObject(a), f = m.speed(b, c, d), g = function () {
                    var b = kb(this, m.extend({}, a), f);
                    (e || m._data(this, "finish")) && b.stop(!0)
                };
                return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g)
            }, stop: function (a, b, c) {
                var d = function (a) {
                    var b = a.stop;
                    delete a.stop, b(c)
                };
                return "string" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || "fx", []), this.each(function () {
                    var b = !0, e = null != a && a + "queueHooks", f = m.timers, g = m._data(this);
                    if (e) g[e] && g[e].stop && d(g[e]); else for (e in g) g[e] && g[e].stop && cb.test(e) && d(g[e]);
                    for (e = f.length; e--;) f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1));
                    (b || !c) && m.dequeue(this, a)
                })
            }, finish: function (a) {
                return a !== !1 && (a = a || "fx"), this.each(function () {
                    var b, c = m._data(this), d = c[a + "queue"], e = c[a + "queueHooks"], f = m.timers,
                        g = d ? d.length : 0;
                    for (c.finish = !0, m.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--;) f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1));
                    for (b = 0; g > b; b++) d[b] && d[b].finish && d[b].finish.call(this);
                    delete c.finish
                })
            }
        }), m.each(["toggle", "show", "hide"], function (a, b) {
            var c = m.fn[b];
            m.fn[b] = function (a, d, e) {
                return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(gb(b, !0), a, d, e)
            }
        }), m.each({
            slideDown: gb("show"),
            slideUp: gb("hide"),
            slideToggle: gb("toggle"),
            fadeIn: {opacity: "show"},
            fadeOut: {opacity: "hide"},
            fadeToggle: {opacity: "toggle"}
        }, function (a, b) {
            m.fn[a] = function (a, c, d) {
                return this.animate(b, a, c, d)
            }
        }), m.timers = [], m.fx.tick = function () {
            var a, b = m.timers, c = 0;
            for ($a = m.now(); c < b.length; c++) a = b[c], a() || b[c] !== a || b.splice(c--, 1);
            b.length || m.fx.stop(), $a = void 0
        }, m.fx.timer = function (a) {
            m.timers.push(a), a() ? m.fx.start() : m.timers.pop()
        }, m.fx.interval = 13, m.fx.start = function () {
            _a || (_a = setInterval(m.fx.tick, m.fx.interval))
        }, m.fx.stop = function () {
            clearInterval(_a), _a = null
        }, m.fx.speeds = {slow: 600, fast: 200, _default: 400}, m.fn.delay = function (a, b) {
            return a = m.fx ? m.fx.speeds[a] || a : a, b = b || "fx", this.queue(b, function (b, c) {
                var d = setTimeout(b, a);
                c.stop = function () {
                    clearTimeout(d)
                }
            })
        }, function () {
            var a, b, c, d, e;
            b = y.createElement("div"), b.setAttribute("className", "t"), b.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", d = b.getElementsByTagName("a")[0], c = y.createElement("select"), e = c.appendChild(y.createElement("option")), a = b.getElementsByTagName("input")[0], d.style.cssText = "top:1px", k.getSetAttribute = "t" !== b.className, k.style = /top/.test(d.getAttribute("style")), k.hrefNormalized = "/a" === d.getAttribute("href"), k.checkOn = !!a.value, k.optSelected = e.selected, k.enctype = !!y.createElement("form").enctype, c.disabled = !0, k.optDisabled = !e.disabled, a = y.createElement("input"), a.setAttribute("value", ""), k.input = "" === a.getAttribute("value"), a.value = "t", a.setAttribute("type", "radio"), k.radioValue = "t" === a.value
        }();
        var lb = /\r/g;
        m.fn.extend({
            val: function (a) {
                var b, c, d, e = this[0];
                {
                    if (arguments.length) return d = m.isFunction(a), this.each(function (c) {
                        var e;
                        1 === this.nodeType && (e = d ? a.call(this, c, m(this).val()) : a, null == e ? e = "" : "number" == typeof e ? e += "" : m.isArray(e) && (e = m.map(e, function (a) {
                            return null == a ? "" : a + ""
                        })), b = m.valHooks[this.type] || m.valHooks[this.nodeName.toLowerCase()], b && "set" in b && void 0 !== b.set(this, e, "value") || (this.value = e))
                    });
                    if (e) return b = m.valHooks[e.type] || m.valHooks[e.nodeName.toLowerCase()], b && "get" in b && void 0 !== (c = b.get(e, "value")) ? c : (c = e.value, "string" == typeof c ? c.replace(lb, "") : null == c ? "" : c)
                }
            }
        }), m.extend({
            valHooks: {
                option: {
                    get: function (a) {
                        var b = m.find.attr(a, "value");
                        return null != b ? b : m.trim(m.text(a))
                    }
                }, select: {
                    get: function (a) {
                        for (var b, c, d = a.options, e = a.selectedIndex, f = "select-one" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++) if (c = d[i], !(!c.selected && i !== e || (k.optDisabled ? c.disabled : null !== c.getAttribute("disabled")) || c.parentNode.disabled && m.nodeName(c.parentNode, "optgroup"))) {
                            if (b = m(c).val(), f) return b;
                            g.push(b)
                        }
                        return g
                    }, set: function (a, b) {
                        var c, d, e = a.options, f = m.makeArray(b), g = e.length;
                        while (g--) if (d = e[g], m.inArray(m.valHooks.option.get(d), f) >= 0) try {
                            d.selected = c = !0
                        } catch (h) {
                            d.scrollHeight
                        } else d.selected = !1;
                        return c || (a.selectedIndex = -1), e
                    }
                }
            }
        }), m.each(["radio", "checkbox"], function () {
            m.valHooks[this] = {
                set: function (a, b) {
                    return m.isArray(b) ? a.checked = m.inArray(m(a).val(), b) >= 0 : void 0
                }
            }, k.checkOn || (m.valHooks[this].get = function (a) {
                return null === a.getAttribute("value") ? "on" : a.value
            })
        });
        var mb, nb, ob = m.expr.attrHandle, pb = /^(?:checked|selected)$/i, qb = k.getSetAttribute, rb = k.input;
        m.fn.extend({
            attr: function (a, b) {
                return V(this, m.attr, a, b, arguments.length > 1)
            }, removeAttr: function (a) {
                return this.each(function () {
                    m.removeAttr(this, a)
                })
            }
        }), m.extend({
            attr: function (a, b, c) {
                var d, e, f = a.nodeType;
                if (a && 3 !== f && 8 !== f && 2 !== f) return typeof a.getAttribute === K ? m.prop(a, b, c) : (1 === f && m.isXMLDoc(a) || (b = b.toLowerCase(), d = m.attrHooks[b] || (m.expr.match.bool.test(b) ? nb : mb)), void 0 === c ? d && "get" in d && null !== (e = d.get(a, b)) ? e : (e = m.find.attr(a, b), null == e ? void 0 : e) : null !== c ? d && "set" in d && void 0 !== (e = d.set(a, c, b)) ? e : (a.setAttribute(b, c + ""), c) : void m.removeAttr(a, b))
            }, removeAttr: function (a, b) {
                var c, d, e = 0, f = b && b.match(E);
                if (f && 1 === a.nodeType) while (c = f[e++]) d = m.propFix[c] || c, m.expr.match.bool.test(c) ? rb && qb || !pb.test(c) ? a[d] = !1 : a[m.camelCase("default-" + c)] = a[d] = !1 : m.attr(a, c, ""), a.removeAttribute(qb ? c : d)
            }, attrHooks: {
                type: {
                    set: function (a, b) {
                        if (!k.radioValue && "radio" === b && m.nodeName(a, "input")) {
                            var c = a.value;
                            return a.setAttribute("type", b), c && (a.value = c), b
                        }
                    }
                }
            }
        }), nb = {
            set: function (a, b, c) {
                return b === !1 ? m.removeAttr(a, c) : rb && qb || !pb.test(c) ? a.setAttribute(!qb && m.propFix[c] || c, c) : a[m.camelCase("default-" + c)] = a[c] = !0, c
            }
        }, m.each(m.expr.match.bool.source.match(/\w+/g), function (a, b) {
            var c = ob[b] || m.find.attr;
            ob[b] = rb && qb || !pb.test(b) ? function (a, b, d) {
                var e, f;
                return d || (f = ob[b], ob[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, ob[b] = f), e
            } : function (a, b, c) {
                return c ? void 0 : a[m.camelCase("default-" + b)] ? b.toLowerCase() : null
            }
        }), rb && qb || (m.attrHooks.value = {
            set: function (a, b, c) {
                return m.nodeName(a, "input") ? void(a.defaultValue = b) : mb && mb.set(a, b, c)
            }
        }), qb || (mb = {
            set: function (a, b, c) {
                var d = a.getAttributeNode(c);
                return d || a.setAttributeNode(d = a.ownerDocument.createAttribute(c)), d.value = b += "", "value" === c || b === a.getAttribute(c) ? b : void 0
            }
        }, ob.id = ob.name = ob.coords = function (a, b, c) {
            var d;
            return c ? void 0 : (d = a.getAttributeNode(b)) && "" !== d.value ? d.value : null
        }, m.valHooks.button = {
            get: function (a, b) {
                var c = a.getAttributeNode(b);
                return c && c.specified ? c.value : void 0
            }, set: mb.set
        }, m.attrHooks.contenteditable = {
            set: function (a, b, c) {
                mb.set(a, "" === b ? !1 : b, c)
            }
        }, m.each(["width", "height"], function (a, b) {
            m.attrHooks[b] = {
                set: function (a, c) {
                    return "" === c ? (a.setAttribute(b, "auto"), c) : void 0
                }
            }
        })), k.style || (m.attrHooks.style = {
            get: function (a) {
                return a.style.cssText || void 0
            }, set: function (a, b) {
                return a.style.cssText = b + ""
            }
        });
        var sb = /^(?:input|select|textarea|button|object)$/i, tb = /^(?:a|area)$/i;
        m.fn.extend({
            prop: function (a, b) {
                return V(this, m.prop, a, b, arguments.length > 1)
            }, removeProp: function (a) {
                return a = m.propFix[a] || a, this.each(function () {
                    try {
                        this[a] = void 0, delete this[a]
                    } catch (b) {
                    }
                })
            }
        }), m.extend({
            propFix: {"for": "htmlFor", "class": "className"}, prop: function (a, b, c) {
                var d, e, f, g = a.nodeType;
                if (a && 3 !== g && 8 !== g && 2 !== g) return f = 1 !== g || !m.isXMLDoc(a), f && (b = m.propFix[b] || b, e = m.propHooks[b]), void 0 !== c ? e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && "get" in e && null !== (d = e.get(a, b)) ? d : a[b]
            }, propHooks: {
                tabIndex: {
                    get: function (a) {
                        var b = m.find.attr(a, "tabindex");
                        return b ? parseInt(b, 10) : sb.test(a.nodeName) || tb.test(a.nodeName) && a.href ? 0 : -1
                    }
                }
            }
        }), k.hrefNormalized || m.each(["href", "src"], function (a, b) {
            m.propHooks[b] = {
                get: function (a) {
                    return a.getAttribute(b, 4)
                }
            }
        }), k.optSelected || (m.propHooks.selected = {
            get: function (a) {
                var b = a.parentNode;
                return b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex), null
            }
        }), m.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
            m.propFix[this.toLowerCase()] = this
        }), k.enctype || (m.propFix.enctype = "encoding");
        var ub = /[\t\r\n\f]/g;
        m.fn.extend({
            addClass: function (a) {
                var b, c, d, e, f, g, h = 0, i = this.length, j = "string" == typeof a && a;
                if (m.isFunction(a)) return this.each(function (b) {
                    m(this).addClass(a.call(this, b, this.className))
                });
                if (j) for (b = (a || "").match(E) || []; i > h; h++) if (c = this[h], d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(ub, " ") : " ")) {
                    f = 0;
                    while (e = b[f++]) d.indexOf(" " + e + " ") < 0 && (d += e + " ");
                    g = m.trim(d), c.className !== g && (c.className = g)
                }
                return this
            }, removeClass: function (a) {
                var b, c, d, e, f, g, h = 0, i = this.length, j = 0 === arguments.length || "string" == typeof a && a;
                if (m.isFunction(a)) return this.each(function (b) {
                    m(this).removeClass(a.call(this, b, this.className))
                });
                if (j) for (b = (a || "").match(E) || []; i > h; h++) if (c = this[h], d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(ub, " ") : "")) {
                    f = 0;
                    while (e = b[f++]) while (d.indexOf(" " + e + " ") >= 0) d = d.replace(" " + e + " ", " ");
                    g = a ? m.trim(d) : "", c.className !== g && (c.className = g)
                }
                return this
            }, toggleClass: function (a, b) {
                var c = typeof a;
                return "boolean" == typeof b && "string" === c ? b ? this.addClass(a) : this.removeClass(a) : this.each(m.isFunction(a) ? function (c) {
                    m(this).toggleClass(a.call(this, c, this.className, b), b)
                } : function () {
                    if ("string" === c) {
                        var b, d = 0, e = m(this), f = a.match(E) || [];
                        while (b = f[d++]) e.hasClass(b) ? e.removeClass(b) : e.addClass(b)
                    } else (c === K || "boolean" === c) && (this.className && m._data(this, "__className__", this.className), this.className = this.className || a === !1 ? "" : m._data(this, "__className__") || "")
                })
            }, hasClass: function (a) {
                for (var b = " " + a + " ", c = 0, d = this.length; d > c; c++) if (1 === this[c].nodeType && (" " + this[c].className + " ").replace(ub, " ").indexOf(b) >= 0) return !0;
                return !1
            }
        }), m.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function (a, b) {
            m.fn[b] = function (a, c) {
                return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b)
            }
        }), m.fn.extend({
            hover: function (a, b) {
                return this.mouseenter(a).mouseleave(b || a)
            }, bind: function (a, b, c) {
                return this.on(a, null, b, c)
            }, unbind: function (a, b) {
                return this.off(a, null, b)
            }, delegate: function (a, b, c, d) {
                return this.on(b, a, c, d)
            }, undelegate: function (a, b, c) {
                return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c)
            }
        });
        var vb = m.now(), wb = /\?/,
            xb = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;
        m.parseJSON = function (b) {
            if (a.JSON && a.JSON.parse) return a.JSON.parse(b + "");
            var c, d = null, e = m.trim(b + "");
            return e && !m.trim(e.replace(xb, function (a, b, e, f) {
                return c && b && (d = 0), 0 === d ? a : (c = e || b, d += !f - !e, "")
            })) ? Function("return " + e)() : m.error("Invalid JSON: " + b)
        }, m.parseXML = function (b) {
            var c, d;
            if (!b || "string" != typeof b) return null;
            try {
                a.DOMParser ? (d = new DOMParser, c = d.parseFromString(b, "text/xml")) : (c = new ActiveXObject("Microsoft.XMLDOM"), c.async = "false", c.loadXML(b))
            } catch (e) {
                c = void 0
            }
            return c && c.documentElement && !c.getElementsByTagName("parsererror").length || m.error("Invalid XML: " + b), c
        };
        var yb, zb, Ab = /#.*$/, Bb = /([?&])_=[^&]*/, Cb = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm,
            Db = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, Eb = /^(?:GET|HEAD)$/, Fb = /^\/\//,
            Gb = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, Hb = {}, Ib = {}, Jb = "*/".concat("*");
        try {
            zb = location.href
        } catch (Kb) {
            zb = y.createElement("a"), zb.href = "", zb = zb.href
        }
        yb = Gb.exec(zb.toLowerCase()) || [];

        function Lb(a) {
            return function (b, c) {
                "string" != typeof b && (c = b, b = "*");
                var d, e = 0, f = b.toLowerCase().match(E) || [];
                if (m.isFunction(c)) while (d = f[e++]) "+" === d.charAt(0) ? (d = d.slice(1) || "*", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c)
            }
        }

        function Mb(a, b, c, d) {
            var e = {}, f = a === Ib;

            function g(h) {
                var i;
                return e[h] = !0, m.each(a[h] || [], function (a, h) {
                    var j = h(b, c, d);
                    return "string" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1)
                }), i
            }

            return g(b.dataTypes[0]) || !e["*"] && g("*")
        }

        function Nb(a, b) {
            var c, d, e = m.ajaxSettings.flatOptions || {};
            for (d in b) void 0 !== b[d] && ((e[d] ? a : c || (c = {}))[d] = b[d]);
            return c && m.extend(!0, a, c), a
        }

        function Ob(a, b, c) {
            var d, e, f, g, h = a.contents, i = a.dataTypes;
            while ("*" === i[0]) i.shift(), void 0 === e && (e = a.mimeType || b.getResponseHeader("Content-Type"));
            if (e) for (g in h) if (h[g] && h[g].test(e)) {
                i.unshift(g);
                break
            }
            if (i[0] in c) f = i[0]; else {
                for (g in c) {
                    if (!i[0] || a.converters[g + " " + i[0]]) {
                        f = g;
                        break
                    }
                    d || (d = g)
                }
                f = f || d
            }
            return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0
        }

        function Pb(a, b, c, d) {
            var e, f, g, h, i, j = {}, k = a.dataTypes.slice();
            if (k[1]) for (g in a.converters) j[g.toLowerCase()] = a.converters[g];
            f = k.shift();
            while (f) if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift()) if ("*" === f) f = i; else if ("*" !== i && i !== f) {
                if (g = j[i + " " + f] || j["* " + f], !g) for (e in j) if (h = e.split(" "), h[1] === f && (g = j[i + " " + h[0]] || j["* " + h[0]])) {
                    g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));
                    break
                }
                if (g !== !0) if (g && a["throws"]) b = g(b); else try {
                    b = g(b)
                } catch (l) {
                    return {state: "parsererror", error: g ? l : "No conversion from " + i + " to " + f}
                }
            }
            return {state: "success", data: b}
        }

        m.extend({
            active: 0,
            lastModified: {},
            etag: {},
            ajaxSettings: {
                url: zb,
                type: "GET",
                isLocal: Db.test(yb[1]),
                global: !0,
                processData: !0,
                async: !0,
                contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                accepts: {
                    "*": Jb,
                    text: "text/plain",
                    html: "text/html",
                    xml: "application/xml, text/xml",
                    json: "application/json, text/javascript"
                },
                contents: {xml: /xml/, html: /html/, json: /json/},
                responseFields: {xml: "responseXML", text: "responseText", json: "responseJSON"},
                converters: {"* text": String, "text html": !0, "text json": m.parseJSON, "text xml": m.parseXML},
                flatOptions: {url: !0, context: !0}
            },
            ajaxSetup: function (a, b) {
                return b ? Nb(Nb(a, m.ajaxSettings), b) : Nb(m.ajaxSettings, a)
            },
            ajaxPrefilter: Lb(Hb),
            ajaxTransport: Lb(Ib),
            ajax: function (a, b) {
                "object" == typeof a && (b = a, a = void 0), b = b || {};
                var c, d, e, f, g, h, i, j, k = m.ajaxSetup({}, b), l = k.context || k,
                    n = k.context && (l.nodeType || l.jquery) ? m(l) : m.event, o = m.Deferred(),
                    p = m.Callbacks("once memory"), q = k.statusCode || {}, r = {}, s = {}, t = 0, u = "canceled", v = {
                        readyState: 0, getResponseHeader: function (a) {
                            var b;
                            if (2 === t) {
                                if (!j) {
                                    j = {};
                                    while (b = Cb.exec(f)) j[b[1].toLowerCase()] = b[2]
                                }
                                b = j[a.toLowerCase()]
                            }
                            return null == b ? null : b
                        }, getAllResponseHeaders: function () {
                            return 2 === t ? f : null
                        }, setRequestHeader: function (a, b) {
                            var c = a.toLowerCase();
                            return t || (a = s[c] = s[c] || a, r[a] = b), this
                        }, overrideMimeType: function (a) {
                            return t || (k.mimeType = a), this
                        }, statusCode: function (a) {
                            var b;
                            if (a) if (2 > t) for (b in a) q[b] = [q[b], a[b]]; else v.always(a[v.status]);
                            return this
                        }, abort: function (a) {
                            var b = a || u;
                            return i && i.abort(b), x(0, b), this
                        }
                    };
                if (o.promise(v).complete = p.add, v.success = v.done, v.error = v.fail, k.url = ((a || k.url || zb) + "").replace(Ab, "").replace(Fb, yb[1] + "//"), k.type = b.method || b.type || k.method || k.type, k.dataTypes = m.trim(k.dataType || "*").toLowerCase().match(E) || [""], null == k.crossDomain && (c = Gb.exec(k.url.toLowerCase()), k.crossDomain = !(!c || c[1] === yb[1] && c[2] === yb[2] && (c[3] || ("http:" === c[1] ? "80" : "443")) === (yb[3] || ("http:" === yb[1] ? "80" : "443")))), k.data && k.processData && "string" != typeof k.data && (k.data = m.param(k.data, k.traditional)), Mb(Hb, k, b, v), 2 === t) return v;
                h = m.event && k.global, h && 0 === m.active++ && m.event.trigger("ajaxStart"), k.type = k.type.toUpperCase(), k.hasContent = !Eb.test(k.type), e = k.url, k.hasContent || (k.data && (e = k.url += (wb.test(e) ? "&" : "?") + k.data, delete k.data), k.cache === !1 && (k.url = Bb.test(e) ? e.replace(Bb, "$1_=" + vb++) : e + (wb.test(e) ? "&" : "?") + "_=" + vb++)), k.ifModified && (m.lastModified[e] && v.setRequestHeader("If-Modified-Since", m.lastModified[e]), m.etag[e] && v.setRequestHeader("If-None-Match", m.etag[e])), (k.data && k.hasContent && k.contentType !== !1 || b.contentType) && v.setRequestHeader("Content-Type", k.contentType), v.setRequestHeader("Accept", k.dataTypes[0] && k.accepts[k.dataTypes[0]] ? k.accepts[k.dataTypes[0]] + ("*" !== k.dataTypes[0] ? ", " + Jb + "; q=0.01" : "") : k.accepts["*"]);
                for (d in k.headers) v.setRequestHeader(d, k.headers[d]);
                if (k.beforeSend && (k.beforeSend.call(l, v, k) === !1 || 2 === t)) return v.abort();
                u = "abort";
                for (d in{success: 1, error: 1, complete: 1}) v[d](k[d]);
                if (i = Mb(Ib, k, b, v)) {
                    v.readyState = 1, h && n.trigger("ajaxSend", [v, k]), k.async && k.timeout > 0 && (g = setTimeout(function () {
                        v.abort("timeout")
                    }, k.timeout));
                    try {
                        t = 1, i.send(r, x)
                    } catch (w) {
                        if (!(2 > t)) throw w;
                        x(-1, w)
                    }
                } else x(-1, "No Transport");

                function x(a, b, c, d) {
                    var j, r, s, u, w, x = b;
                    2 !== t && (t = 2, g && clearTimeout(g), i = void 0, f = d || "", v.readyState = a > 0 ? 4 : 0, j = a >= 200 && 300 > a || 304 === a, c && (u = Ob(k, v, c)), u = Pb(k, u, v, j), j ? (k.ifModified && (w = v.getResponseHeader("Last-Modified"), w && (m.lastModified[e] = w), w = v.getResponseHeader("etag"), w && (m.etag[e] = w)), 204 === a || "HEAD" === k.type ? x = "nocontent" : 304 === a ? x = "notmodified" : (x = u.state, r = u.data, s = u.error, j = !s)) : (s = x, (a || !x) && (x = "error", 0 > a && (a = 0))), v.status = a, v.statusText = (b || x) + "", j ? o.resolveWith(l, [r, x, v]) : o.rejectWith(l, [v, x, s]), v.statusCode(q), q = void 0, h && n.trigger(j ? "ajaxSuccess" : "ajaxError", [v, k, j ? r : s]), p.fireWith(l, [v, x]), h && (n.trigger("ajaxComplete", [v, k]), --m.active || m.event.trigger("ajaxStop")))
                }

                return v
            },
            getJSON: function (a, b, c) {
                return m.get(a, b, c, "json")
            },
            getScript: function (a, b) {
                return m.get(a, void 0, b, "script")
            }
        }), m.each(["get", "post"], function (a, b) {
            m[b] = function (a, c, d, e) {
                return m.isFunction(c) && (e = e || d, d = c, c = void 0), m.ajax({
                    url: a,
                    type: b,
                    dataType: e,
                    data: c,
                    success: d
                })
            }
        }), m._evalUrl = function (a) {
            return m.ajax({url: a, type: "GET", dataType: "script", async: !1, global: !1, "throws": !0})
        }, m.fn.extend({
            wrapAll: function (a) {
                if (m.isFunction(a)) return this.each(function (b) {
                    m(this).wrapAll(a.call(this, b))
                });
                if (this[0]) {
                    var b = m(a, this[0].ownerDocument).eq(0).clone(!0);
                    this[0].parentNode && b.insertBefore(this[0]), b.map(function () {
                        var a = this;
                        while (a.firstChild && 1 === a.firstChild.nodeType) a = a.firstChild;
                        return a
                    }).append(this)
                }
                return this
            }, wrapInner: function (a) {
                return this.each(m.isFunction(a) ? function (b) {
                    m(this).wrapInner(a.call(this, b))
                } : function () {
                    var b = m(this), c = b.contents();
                    c.length ? c.wrapAll(a) : b.append(a)
                })
            }, wrap: function (a) {
                var b = m.isFunction(a);
                return this.each(function (c) {
                    m(this).wrapAll(b ? a.call(this, c) : a)
                })
            }, unwrap: function () {
                return this.parent().each(function () {
                    m.nodeName(this, "body") || m(this).replaceWith(this.childNodes)
                }).end()
            }
        }), m.expr.filters.hidden = function (a) {
            return a.offsetWidth <= 0 && a.offsetHeight <= 0 || !k.reliableHiddenOffsets() && "none" === (a.style && a.style.display || m.css(a, "display"))
        }, m.expr.filters.visible = function (a) {
            return !m.expr.filters.hidden(a)
        };
        var Qb = /%20/g, Rb = /\[\]$/, Sb = /\r?\n/g, Tb = /^(?:submit|button|image|reset|file)$/i,
            Ub = /^(?:input|select|textarea|keygen)/i;

        function Vb(a, b, c, d) {
            var e;
            if (m.isArray(b)) m.each(b, function (b, e) {
                c || Rb.test(a) ? d(a, e) : Vb(a + "[" + ("object" == typeof e ? b : "") + "]", e, c, d)
            }); else if (c || "object" !== m.type(b)) d(a, b); else for (e in b) Vb(a + "[" + e + "]", b[e], c, d)
        }

        m.param = function (a, b) {
            var c, d = [], e = function (a, b) {
                b = m.isFunction(b) ? b() : null == b ? "" : b, d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(b)
            };
            if (void 0 === b && (b = m.ajaxSettings && m.ajaxSettings.traditional), m.isArray(a) || a.jquery && !m.isPlainObject(a)) m.each(a, function () {
                e(this.name, this.value)
            }); else for (c in a) Vb(c, a[c], b, e);
            return d.join("&").replace(Qb, "+")
        }, m.fn.extend({
            serialize: function () {
                return m.param(this.serializeArray())
            }, serializeArray: function () {
                return this.map(function () {
                    var a = m.prop(this, "elements");
                    return a ? m.makeArray(a) : this
                }).filter(function () {
                    var a = this.type;
                    return this.name && !m(this).is(":disabled") && Ub.test(this.nodeName) && !Tb.test(a) && (this.checked || !W.test(a))
                }).map(function (a, b) {
                    var c = m(this).val();
                    return null == c ? null : m.isArray(c) ? m.map(c, function (a) {
                        return {name: b.name, value: a.replace(Sb, "\r\n")}
                    }) : {name: b.name, value: c.replace(Sb, "\r\n")}
                }).get()
            }
        }), m.ajaxSettings.xhr = void 0 !== a.ActiveXObject ? function () {
            return !this.isLocal && /^(get|post|head|put|delete|options)$/i.test(this.type) && Zb() || $b()
        } : Zb;
        var Wb = 0, Xb = {}, Yb = m.ajaxSettings.xhr();
        a.attachEvent && a.attachEvent("onunload", function () {
            for (var a in Xb) Xb[a](void 0, !0)
        }), k.cors = !!Yb && "withCredentials" in Yb, Yb = k.ajax = !!Yb, Yb && m.ajaxTransport(function (a) {
            if (!a.crossDomain || k.cors) {
                var b;
                return {
                    send: function (c, d) {
                        var e, f = a.xhr(), g = ++Wb;
                        if (f.open(a.type, a.url, a.async, a.username, a.password), a.xhrFields) for (e in a.xhrFields) f[e] = a.xhrFields[e];
                        a.mimeType && f.overrideMimeType && f.overrideMimeType(a.mimeType), a.crossDomain || c["X-Requested-With"] || (c["X-Requested-With"] = "XMLHttpRequest");
                        for (e in c) void 0 !== c[e] && f.setRequestHeader(e, c[e] + "");
                        f.send(a.hasContent && a.data || null), b = function (c, e) {
                            var h, i, j;
                            if (b && (e || 4 === f.readyState)) if (delete Xb[g], b = void 0, f.onreadystatechange = m.noop, e) 4 !== f.readyState && f.abort(); else {
                                j = {}, h = f.status, "string" == typeof f.responseText && (j.text = f.responseText);
                                try {
                                    i = f.statusText
                                } catch (k) {
                                    i = ""
                                }
                                h || !a.isLocal || a.crossDomain ? 1223 === h && (h = 204) : h = j.text ? 200 : 404
                            }
                            j && d(h, i, j, f.getAllResponseHeaders())
                        }, a.async ? 4 === f.readyState ? setTimeout(b) : f.onreadystatechange = Xb[g] = b : b()
                    }, abort: function () {
                        b && b(void 0, !0)
                    }
                }
            }
        });

        function Zb() {
            try {
                return new a.XMLHttpRequest
            } catch (b) {
            }
        }

        function $b() {
            try {
                return new a.ActiveXObject("Microsoft.XMLHTTP")
            } catch (b) {
            }
        }

        m.ajaxSetup({
            accepts: {script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},
            contents: {script: /(?:java|ecma)script/},
            converters: {
                "text script": function (a) {
                    return m.globalEval(a), a
                }
            }
        }), m.ajaxPrefilter("script", function (a) {
            void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = "GET", a.global = !1)
        }), m.ajaxTransport("script", function (a) {
            if (a.crossDomain) {
                var b, c = y.head || m("head")[0] || y.documentElement;
                return {
                    send: function (d, e) {
                        b = y.createElement("script"), b.async = !0, a.scriptCharset && (b.charset = a.scriptCharset), b.src = a.url, b.onload = b.onreadystatechange = function (a, c) {
                            (c || !b.readyState || /loaded|complete/.test(b.readyState)) && (b.onload = b.onreadystatechange = null, b.parentNode && b.parentNode.removeChild(b), b = null, c || e(200, "success"))
                        }, c.insertBefore(b, c.firstChild)
                    }, abort: function () {
                        b && b.onload(void 0, !0)
                    }
                }
            }
        });
        var _b = [], ac = /(=)\?(?=&|$)|\?\?/;
        m.ajaxSetup({
            jsonp: "callback", jsonpCallback: function () {
                var a = _b.pop() || m.expando + "_" + vb++;
                return this[a] = !0, a
            }
        }), m.ajaxPrefilter("json jsonp", function (b, c, d) {
            var e, f, g,
                h = b.jsonp !== !1 && (ac.test(b.url) ? "url" : "string" == typeof b.data && !(b.contentType || "").indexOf("application/x-www-form-urlencoded") && ac.test(b.data) && "data");
            return h || "jsonp" === b.dataTypes[0] ? (e = b.jsonpCallback = m.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(ac, "$1" + e) : b.jsonp !== !1 && (b.url += (wb.test(b.url) ? "&" : "?") + b.jsonp + "=" + e), b.converters["script json"] = function () {
                return g || m.error(e + " was not called"), g[0]
            }, b.dataTypes[0] = "json", f = a[e], a[e] = function () {
                g = arguments
            }, d.always(function () {
                a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, _b.push(e)), g && m.isFunction(f) && f(g[0]), g = f = void 0
            }), "script") : void 0
        }), m.parseHTML = function (a, b, c) {
            if (!a || "string" != typeof a) return null;
            "boolean" == typeof b && (c = b, b = !1), b = b || y;
            var d = u.exec(a), e = !c && [];
            return d ? [b.createElement(d[1])] : (d = m.buildFragment([a], b, e), e && e.length && m(e).remove(), m.merge([], d.childNodes))
        };
        var bc = m.fn.load;
        m.fn.load = function (a, b, c) {
            if ("string" != typeof a && bc) return bc.apply(this, arguments);
            var d, e, f, g = this, h = a.indexOf(" ");
            return h >= 0 && (d = m.trim(a.slice(h, a.length)), a = a.slice(0, h)), m.isFunction(b) ? (c = b, b = void 0) : b && "object" == typeof b && (f = "POST"), g.length > 0 && m.ajax({
                url: a,
                type: f,
                dataType: "html",
                data: b
            }).done(function (a) {
                e = arguments, g.html(d ? m("<div>").append(m.parseHTML(a)).find(d) : a)
            }).complete(c && function (a, b) {
                g.each(c, e || [a.responseText, b, a])
            }), this
        }, m.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (a, b) {
            m.fn[b] = function (a) {
                return this.on(b, a)
            }
        }), m.expr.filters.animated = function (a) {
            return m.grep(m.timers, function (b) {
                return a === b.elem
            }).length
        };
        var cc = a.document.documentElement;

        function dc(a) {
            return m.isWindow(a) ? a : 9 === a.nodeType ? a.defaultView || a.parentWindow : !1
        }

        m.offset = {
            setOffset: function (a, b, c) {
                var d, e, f, g, h, i, j, k = m.css(a, "position"), l = m(a), n = {};
                "static" === k && (a.style.position = "relative"), h = l.offset(), f = m.css(a, "top"), i = m.css(a, "left"), j = ("absolute" === k || "fixed" === k) && m.inArray("auto", [f, i]) > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), m.isFunction(b) && (b = b.call(a, c, h)), null != b.top && (n.top = b.top - h.top + g), null != b.left && (n.left = b.left - h.left + e), "using" in b ? b.using.call(a, n) : l.css(n)
            }
        }, m.fn.extend({
            offset: function (a) {
                if (arguments.length) return void 0 === a ? this : this.each(function (b) {
                    m.offset.setOffset(this, a, b)
                });
                var b, c, d = {top: 0, left: 0}, e = this[0], f = e && e.ownerDocument;
                if (f) return b = f.documentElement, m.contains(b, e) ? (typeof e.getBoundingClientRect !== K && (d = e.getBoundingClientRect()), c = dc(f), {
                    top: d.top + (c.pageYOffset || b.scrollTop) - (b.clientTop || 0),
                    left: d.left + (c.pageXOffset || b.scrollLeft) - (b.clientLeft || 0)
                }) : d
            }, position: function () {
                if (this[0]) {
                    var a, b, c = {top: 0, left: 0}, d = this[0];
                    return "fixed" === m.css(d, "position") ? b = d.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), m.nodeName(a[0], "html") || (c = a.offset()), c.top += m.css(a[0], "borderTopWidth", !0), c.left += m.css(a[0], "borderLeftWidth", !0)), {
                        top: b.top - c.top - m.css(d, "marginTop", !0),
                        left: b.left - c.left - m.css(d, "marginLeft", !0)
                    }
                }
            }, offsetParent: function () {
                return this.map(function () {
                    var a = this.offsetParent || cc;
                    while (a && !m.nodeName(a, "html") && "static" === m.css(a, "position")) a = a.offsetParent;
                    return a || cc
                })
            }
        }), m.each({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function (a, b) {
            var c = /Y/.test(b);
            m.fn[a] = function (d) {
                return V(this, function (a, d, e) {
                    var f = dc(a);
                    return void 0 === e ? f ? b in f ? f[b] : f.document.documentElement[d] : a[d] : void(f ? f.scrollTo(c ? m(f).scrollLeft() : e, c ? e : m(f).scrollTop()) : a[d] = e)
                }, a, d, arguments.length, null)
            }
        }), m.each(["top", "left"], function (a, b) {
            m.cssHooks[b] = La(k.pixelPosition, function (a, c) {
                return c ? (c = Ja(a, b), Ha.test(c) ? m(a).position()[b] + "px" : c) : void 0
            })
        }), m.each({Height: "height", Width: "width"}, function (a, b) {
            m.each({padding: "inner" + a, content: b, "": "outer" + a}, function (c, d) {
                m.fn[d] = function (d, e) {
                    var f = arguments.length && (c || "boolean" != typeof d),
                        g = c || (d === !0 || e === !0 ? "margin" : "border");
                    return V(this, function (b, c, d) {
                        var e;
                        return m.isWindow(b) ? b.document.documentElement["client" + a] : 9 === b.nodeType ? (e = b.documentElement, Math.max(b.body["scroll" + a], e["scroll" + a], b.body["offset" + a], e["offset" + a], e["client" + a])) : void 0 === d ? m.css(b, c, g) : m.style(b, c, d, g)
                    }, b, f ? d : void 0, f, null)
                }
            })
        }), m.fn.size = function () {
            return this.length
        }, m.fn.andSelf = m.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function () {
            return m
        });
        var ec = a.jQuery, fc = a.$;
        return m.noConflict = function (b) {
            return a.$ === m && (a.$ = fc), b && a.jQuery === m && (a.jQuery = ec), m
        }, typeof b === K && (a.jQuery = a.$ = m), m
    });
// revert window jQuery and $ to original values, #7187
// do this after loading jQuery, we have to do this because we are not using require as well.
    jQuery = window.jQuery;
// For debugging
    jQuery.vgmark = true;
    $ = jQuery;
    if (typeof(oldDollar) !== 'undefined') {
        window.$ = oldDollar;
    }
    else {
        try {
            delete window.$;
        } catch (e) {
        }
    }
    if (typeof(oldJQuery) !== 'undefined') {
        window.jQuery = oldJQuery;
    }
    else {
        try {
            delete window.jQuery;
        } catch (e) {
        }
    }
    /*
 * jQuery BBQ: Back Button & Query Library - v1.2.1 - 2/17/2010
 * http://benalman.com/projects/jquery-bbq-plugin/
 *
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */
// http://stackoverflow.com/questions/14923301/uncaught-typeerror-cannot-read-property-msie-of-undefined-jquery-tools
    if (jQuery.browser === undefined) {
        jQuery.browser = {};
        (function () {
            jQuery.browser.msie = false;
            jQuery.browser.version = 0;
            if (navigator.userAgent.match(/MSIE ([0-9]+)\./)) {
                jQuery.browser.msie = true;
                jQuery.browser.version = RegExp.$1;
            }
        })();
    }
    (function ($, p) {
        var i, m = Array.prototype.slice, r = decodeURIComponent, a = $.param, c, l, v, b = $.bbq = $.bbq || {}, q, u,
            j, e = $.event.special, d = "hashchange", A = "querystring", D = "fragment", y = "elemUrlAttr",
            g = "location", k = "href", t = "src", x = /^.*\?|#.*$/g, w = /^.*\#/, h, C = {};

        function E(F) {
            return typeof F === "string"
        }

        function B(G) {
            var F = m.call(arguments, 1);
            return function () {
                return G.apply(this, F.concat(m.call(arguments)))
            }
        }

        function n(F) {
            return F.replace(/^[^#]*#?(.*)$/, "$1")
        }

        function o(F) {
            return F.replace(/(?:^[^?#]*\?([^#]*).*$)?.*/, "$1")
        }

        function f(H, M, F, I, G) {
            var O, L, K, N, J;
            if (I !== i) {
                K = F.match(H ? /^([^#]*)\#?(.*)$/ : /^([^#?]*)\??([^#]*)(#?.*)/);
                J = K[3] || "";
                if (G === 2 && E(I)) {
                    L = I.replace(H ? w : x, "")
                } else {
                    N = l(K[2]);
                    I = E(I) ? l[H ? D : A](I) : I;
                    L = G === 2 ? I : G === 1 ? $.extend({}, I, N) : $.extend({}, N, I);
                    L = a(L);
                    if (H) {
                        L = L.replace(h, r)
                    }
                }
                O = K[1] + (H ? "#" : L || !K[1] ? "?" : "") + L + J
            } else {
                O = M(F !== i ? F : p[g][k])
            }
            return O
        }

        a[A] = B(f, 0, o);
        a[D] = c = B(f, 1, n);
        c.noEscape = function (G) {
            G = G || "";
            var F = $.map(G.split(""), encodeURIComponent);
            h = new RegExp(F.join("|"), "g")
        };
        c.noEscape(",/");
        $.deparam = l = function (I, F) {
            var H = {}, G = {"true": !0, "false": !1, "null": null};
            $.each(I.replace(/\+/g, " ").split("&"), function (L, Q) {
                var K = Q.split("="), P = r(K[0]), J, O = H, M = 0, R = P.split("]["), N = R.length - 1;
                if (/\[/.test(R[0]) && /\]$/.test(R[N])) {
                    R[N] = R[N].replace(/\]$/, "");
                    R = R.shift().split("[").concat(R);
                    N = R.length - 1
                } else {
                    N = 0
                }
                if (K.length === 2) {
                    J = r(K[1]);
                    if (F) {
                        J = J && !isNaN(J) ? +J : J === "undefined" ? i : G[J] !== i ? G[J] : J
                    }
                    if (N) {
                        for (; M <= N; M++) {
                            P = R[M] === "" ? O.length : R[M];
                            O = O[P] = M < N ? O[P] || (R[M + 1] && isNaN(R[M + 1]) ? {} : []) : J
                        }
                    } else {
                        if ($.isArray(H[P])) {
                            H[P].push(J)
                        } else {
                            if (H[P] !== i) {
                                H[P] = [H[P], J]
                            } else {
                                H[P] = J
                            }
                        }
                    }
                } else {
                    if (P) {
                        H[P] = F ? i : ""
                    }
                }
            });
            return H
        };

        function z(H, F, G) {
            if (F === i || typeof F === "boolean") {
                G = F;
                F = a[H ? D : A]()
            } else {
                F = E(F) ? F.replace(H ? w : x, "") : F
            }
            return l(F, G)
        }

        l[A] = B(z, 0);
        l[D] = v = B(z, 1);
        $[y] || ($[y] = function (F) {
            return $.extend(C, F)
        })({a: k, base: k, iframe: t, img: t, input: t, form: "action", link: k, script: t});
        j = $[y];

        function s(I, G, H, F) {
            if (!E(H) && typeof H !== "object") {
                F = H;
                H = G;
                G = i
            }
            return this.each(function () {
                var L = $(this), J = G || j()[(this.nodeName || "").toLowerCase()] || "", K = J && L.attr(J) || "";
                L.attr(J, a[I](K, H, F))
            })
        }

        $.fn[A] = B(s, A);
        $.fn[D] = B(s, D);
        b.pushState = q = function (I, F) {
            if (E(I) && /^#/.test(I) && F === i) {
                F = 2
            }
            var H = I !== i, G = c(p[g][k], H ? I : {}, H ? F : 2);
            p[g][k] = G + (/#/.test(G) ? "" : "#")
        };
        b.getState = u = function (F, G) {
            return F === i || typeof F === "boolean" ? v(F) : v(G)[F]
        };
        b.removeState = function (F) {
            var G = {};
            if (F !== i) {
                G = u();
                $.each($.isArray(F) ? F : arguments, function (I, H) {
                    delete G[H]
                })
            }
            q(G, 2)
        };
        e[d] = $.extend(e[d], {
            add: function (F) {
                var H;

                function G(J) {
                    var I = J[D] = c();
                    J.getState = function (K, L) {
                        return K === i || typeof K === "boolean" ? l(I, K) : l(I, L)[K]
                    };
                    H.apply(this, arguments)
                }

                if ($.isFunction(F)) {
                    H = F;
                    return G
                } else {
                    H = F.handler;
                    F.handler = G
                }
            }
        })
    })(jQuery, this);
// jquery.jsonp 2.4.0 (c)2012 Julian Aubourg | MIT License
// https://github.com/jaubourg/jquery-jsonp
    (function (e) {
        function t() {
        }

        function n(e) {
            C = [e]
        }

        function r(e, t, n) {
            return e && e.apply && e.apply(t.context || t, n)
        }

        function i(e) {
            return /\?/.test(e) ? "&" : "?"
        }

        function O(c) {
            function Y(e) {
                z++ || (W(), j && (T[I] = {s: [e]}), D && (e = D.apply(c, [e])), r(O, c, [e, b, c]), r(_, c, [c, b]))
            }

            function Z(e) {
                z++ || (W(), j && e != w && (T[I] = e), r(M, c, [c, e]), r(_, c, [c, e]))
            }

            c = e.extend({}, k, c);
            var O = c.success, M = c.error, _ = c.complete, D = c.dataFilter, P = c.callbackParameter, H = c.callback,
                B = c.cache, j = c.pageCache, F = c.charset, I = c.url, q = c.data, R = c.timeout, U, z = 0, W = t, X,
                V, J, K, Q, G;
            return S && S(function (e) {
                e.done(O).fail(M), O = e.resolve, M = e.reject
            }).promise(c), c.abort = function () {
                !(z++) && W()
            }, r(c.beforeSend, c, [c]) === !1 || z ? c : (I = I || u, q = q ? typeof q == "string" ? q : e.param(q, c.traditional) : u, I += q ? i(I) + q : u, P && (I += i(I) + encodeURIComponent(P) + "=?"), !B && !j && (I += i(I) + "_" + (new Date).getTime() + "="), I = I.replace(/=\?(&|$)/, "=" + H + "$1"), j && (U = T[I]) ? U.s ? Y(U.s[0]) : Z(U) : (E[H] = n, K = e(y)[0], K.id = l + N++, F && (K[o] = F), L && L.version() < 11.6 ? (Q = e(y)[0]).text = "document.getElementById('" + K.id + "')." + p + "()" : K[s] = s, A && (K.htmlFor = K.id, K.event = h), K[d] = K[p] = K[v] = function (e) {
                if (!K[m] || !/i/.test(K[m])) {
                    try {
                        K[h] && K[h]()
                    } catch (t) {
                    }
                    e = C, C = 0, e ? Y(e[0]) : Z(a)
                }
            }, K.src = I, W = function (e) {
                G && clearTimeout(G), K[v] = K[d] = K[p] = null, x[g](K), Q && x[g](Q)
            }, x[f](K, J = x.firstChild), Q && x[f](Q, J), G = R > 0 && setTimeout(function () {
                Z(w)
            }, R)), c)
        }

        var s = "async", o = "charset", u = "", a = "error", f = "insertBefore", l = "_jqjsp", c = "on",
            h = c + "click", p = c + a, d = c + "load", v = c + "readystatechange", m = "readyState", g = "removeChild",
            y = "<script>", b = "success", w = "timeout", E = window, S = e.Deferred,
            x = e("head")[0] || document.documentElement, T = {}, N = 0, C, k = {callback: l, url: location.href},
            L = E.opera, A = !!e("<div>").html("<!--[if IE]><i><![endif]-->").find("i").length;
        O.setup = function (t) {
            e.extend(k, t)
        }, e.jsonp = O
    })(jQuery);
// Visioglobe Mapviewer 468e7a3
    var __almond_force_sync = !0;
    var requirejs, require, define;
    (function (a) {
        function b(a, b) {
            var d, e, g, h, f, k, l, m, n, p = b && b.split("/"), q = v.map, r = q && q["*"] || {};
            if (a && "." === a.charAt(0)) if (b) {
                p = p.slice(0, p.length - 1);
                a = p.concat(a.split("/"));
                for (m = 0; m < a.length; m += 1) if (d = a[m], "." === d) a.splice(m, 1), --m; else if (".." === d) if (1 !== m || ".." !== a[2] && ".." !== a[0]) 0 < m && (a.splice(m - 1, 2), m -= 2); else break;
                a = a.join("/")
            } else 0 === a.indexOf("./") && (a = a.substring(2));
            if ((p || r) && q) {
                d = a.split("/");
                for (m = d.length; 0 < m; --m) {
                    e = d.slice(0, m).join("/");
                    if (p) for (n = p.length; 0 < n; --n) if (g = q[p.slice(0,
                            n).join("/")]) if (g = g[e]) {
                        h = g;
                        f = m;
                        break
                    }
                    if (h) break;
                    !k && r && r[e] && (k = r[e], l = m)
                }
                !h && k && (h = k, f = l);
                h && (d.splice(0, f, h), a = d.join("/"))
            }
            return a
        }

        function d(b, d) {
            return function () {
                return m.apply(a, w.call(arguments, 0).concat([b, d]))
            }
        }

        function e(a) {
            return function (d) {
                return b(d, a)
            }
        }

        function f(a) {
            return function (b) {
                p[a] = b
            }
        }

        function h(b) {
            if (x.call(r, b)) {
                var d = r[b];
                delete r[b];
                u[b] = !0;
                l.apply(a, d)
            }
            if (!x.call(p, b) && !x.call(u, b)) throw Error("No " + b);
            return p[b]
        }

        function g(a) {
            var b, d = a ? a.indexOf("!") : -1;
            -1 < d && (b =
                a.substring(0, d), a = a.substring(d + 1, a.length));
            return [b, a]
        }

        function k(a) {
            return function () {
                return v && v.config && v.config[a] || {}
            }
        }

        var l, m, n, q, p = {}, r = {}, v = {}, u = {}, x = Object.prototype.hasOwnProperty, w = [].slice;
        n = function (a, d) {
            var f, k = g(a), l = k[0];
            a = k[1];
            l && (l = b(l, d), f = h(l));
            l ? a = f && f.normalize ? f.normalize(a, e(d)) : b(a, d) : (a = b(a, d), k = g(a), l = k[0], a = k[1], l && (f = h(l)));
            return {f: l ? l + "!" + a : a, n: a, pr: l, p: f}
        };
        q = {
            require: function (a) {
                return d(a)
            }, exports: function (a) {
                var b = p[a];
                return "undefined" !== typeof b ? b : p[a] = {}
            },
            module: function (a) {
                return {id: a, uri: "", exports: p[a], config: k(a)}
            }
        };
        l = function (b, e, g, k) {
            var l, m, v, w, G = [], D;
            k = k || b;
            if ("function" === typeof g) {
                e = !e.length && g.length ? ["require", "exports", "module"] : e;
                for (w = 0; w < e.length; w += 1) if (v = n(e[w], k), m = v.f, "require" === m) G[w] = q.require(b); else if ("exports" === m) G[w] = q.exports(b), D = !0; else if ("module" === m) l = G[w] = q.module(b); else if (x.call(p, m) || x.call(r, m) || x.call(u, m)) G[w] = h(m); else if (v.p) v.p.load(v.n, d(k, !0), f(m), {}), G[w] = p[m]; else throw Error(b + " missing " + m);
                e = g.apply(p[b],
                    G);
                b && (l && l.exports !== a && l.exports !== p[b] ? p[b] = l.exports : e === a && D || (p[b] = e))
            } else b && (p[b] = g)
        };
        requirejs = require = m = function (b, d, e, g, f) {
            if ("string" === typeof b) return q[b] ? q[b](d) : h(n(b, d).f);
            b && b.splice || (v = b, callbak && d.splice ? (b = d, d = e, e = null) : b = a);
            d = d || function () {
            };
            "function" === typeof e && (e = g, g = f);
            g || __almond_force_sync ? l(a, b, d, e) : setTimeout(function () {
                l(a, b, d, e)
            }, 4);
            return m
        };
        m.config = function (a) {
            v = a;
            v.deps && m(v.deps, v.callback);
            return m
        };
        define = function (a, b, d) {
            b && b.splice || (d = b, b = []);
            x.call(p, a) ||
            x.call(r, a) || (r[a] = [a, b, d])
        };
        define.amd = {jQuery: !0}
    })();
    var THREE = {REVISION: "69"}, console = console || window.console || {}, noOp = function () {
    };
    console.log = console.log || noOp;
    console.time = console.time || noOp;
    console.timeEnd = console.timeEnd || noOp;
    console.warn = console.warn || console.log || noOp;
    "object" === typeof module && (module.exports = THREE);
    void 0 === Math.sign && (Math.sign = function (a) {
        return 0 > a ? -1 : 0 < a ? 1 : 0
    });
    THREE.MOUSE = {LEFT: 0, MIDDLE: 1, RIGHT: 2};
    THREE.CullFaceNone = 0;
    THREE.CullFaceBack = 1;
    THREE.CullFaceFront = 2;
    THREE.CullFaceFrontBack = 3;
    THREE.FrontFaceDirectionCW = 0;
    THREE.FrontFaceDirectionCCW = 1;
    THREE.BasicShadowMap = 0;
    THREE.PCFShadowMap = 1;
    THREE.PCFSoftShadowMap = 2;
    THREE.FrontSide = 0;
    THREE.BackSide = 1;
    THREE.DoubleSide = 2;
    THREE.NoShading = 0;
    THREE.FlatShading = 1;
    THREE.SmoothShading = 2;
    THREE.NoColors = 0;
    THREE.FaceColors = 1;
    THREE.VertexColors = 2;
    THREE.NoBlending = 0;
    THREE.NormalBlending = 1;
    THREE.AdditiveBlending = 2;
    THREE.SubtractiveBlending = 3;
    THREE.MultiplyBlending = 4;
    THREE.CustomBlending = 5;
    THREE.AddEquation = 100;
    THREE.SubtractEquation = 101;
    THREE.ReverseSubtractEquation = 102;
    THREE.MinEquation = 103;
    THREE.MaxEquation = 104;
    THREE.ZeroFactor = 200;
    THREE.OneFactor = 201;
    THREE.SrcColorFactor = 202;
    THREE.OneMinusSrcColorFactor = 203;
    THREE.SrcAlphaFactor = 204;
    THREE.OneMinusSrcAlphaFactor = 205;
    THREE.DstAlphaFactor = 206;
    THREE.OneMinusDstAlphaFactor = 207;
    THREE.DstColorFactor = 208;
    THREE.OneMinusDstColorFactor = 209;
    THREE.SrcAlphaSaturateFactor = 210;
    THREE.MultiplyOperation = 0;
    THREE.MixOperation = 1;
    THREE.AddOperation = 2;
    THREE.UVMapping = function () {
    };
    THREE.CubeReflectionMapping = function () {
    };
    THREE.CubeRefractionMapping = function () {
    };
    THREE.SphericalReflectionMapping = function () {
    };
    THREE.SphericalRefractionMapping = function () {
    };
    THREE.RepeatWrapping = 1E3;
    THREE.ClampToEdgeWrapping = 1001;
    THREE.MirroredRepeatWrapping = 1002;
    THREE.NearestFilter = 1003;
    THREE.NearestMipMapNearestFilter = 1004;
    THREE.NearestMipMapLinearFilter = 1005;
    THREE.LinearFilter = 1006;
    THREE.LinearMipMapNearestFilter = 1007;
    THREE.LinearMipMapLinearFilter = 1008;
    THREE.UnsignedByteType = 1009;
    THREE.ByteType = 1010;
    THREE.ShortType = 1011;
    THREE.UnsignedShortType = 1012;
    THREE.IntType = 1013;
    THREE.UnsignedIntType = 1014;
    THREE.FloatType = 1015;
    THREE.UnsignedShort4444Type = 1016;
    THREE.UnsignedShort5551Type = 1017;
    THREE.UnsignedShort565Type = 1018;
    THREE.AlphaFormat = 1019;
    THREE.RGBFormat = 1020;
    THREE.RGBAFormat = 1021;
    THREE.LuminanceFormat = 1022;
    THREE.LuminanceAlphaFormat = 1023;
    THREE.RGB_S3TC_DXT1_Format = 2001;
    THREE.RGBA_S3TC_DXT1_Format = 2002;
    THREE.RGBA_S3TC_DXT3_Format = 2003;
    THREE.RGBA_S3TC_DXT5_Format = 2004;
    THREE.RGB_PVRTC_4BPPV1_Format = 2100;
    THREE.RGB_PVRTC_2BPPV1_Format = 2101;
    THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
    THREE.RGBA_PVRTC_2BPPV1_Format = 2103;
    THREE.Color = function (a) {
        return 3 === arguments.length ? this.setRGB(arguments[0], arguments[1], arguments[2]) : this.set(a)
    };
    THREE.Color.prototype = {
        constructor: THREE.Color, r: 1, g: 1, b: 1, set: function (a) {
            a instanceof THREE.Color ? this.copy(a) : "number" === typeof a ? this.setHex(a) : "string" === typeof a && this.setStyle(a);
            return this
        }, setHex: function (a) {
            a = Math.floor(a);
            this.r = (a >> 16 & 255) / 255;
            this.g = (a >> 8 & 255) / 255;
            this.b = (a & 255) / 255;
            return this
        }, setRGB: function (a, b, d) {
            this.r = a;
            this.g = b;
            this.b = d;
            return this
        }, setHSL: function (a, b, d) {
            if (0 === b) this.r = this.g = this.b = d; else {
                var e = function (a, b, d) {
                    0 > d && (d += 1);
                    1 < d && --d;
                    return d < 1 / 6 ? a + 6 * (b - a) * d :
                        .5 > d ? b : d < 2 / 3 ? a + 6 * (b - a) * (2 / 3 - d) : a
                };
                b = .5 >= d ? d * (1 + b) : d + b - d * b;
                d = 2 * d - b;
                this.r = e(d, b, a + 1 / 3);
                this.g = e(d, b, a);
                this.b = e(d, b, a - 1 / 3)
            }
            return this
        }, setStyle: function (a) {
            if (/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(a)) return a = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(a), this.r = Math.min(255, parseInt(a[1], 10)) / 255, this.g = Math.min(255, parseInt(a[2], 10)) / 255, this.b = Math.min(255, parseInt(a[3], 10)) / 255, this;
            if (/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(a)) return a = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(a), this.r =
                Math.min(100, parseInt(a[1], 10)) / 100, this.g = Math.min(100, parseInt(a[2], 10)) / 100, this.b = Math.min(100, parseInt(a[3], 10)) / 100, this;
            if (/^\#([0-9a-f]{6})$/i.test(a)) return a = /^\#([0-9a-f]{6})$/i.exec(a), this.setHex(parseInt(a[1], 16)), this;
            if (/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(a)) return a = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(a), this.setHex(parseInt(a[1] + a[1] + a[2] + a[2] + a[3] + a[3], 16)), this;
            if (/^(\w+)$/i.test(a)) return this.setHex(THREE.ColorKeywords[a]), this
        }, copy: function (a) {
            this.r = a.r;
            this.g =
                a.g;
            this.b = a.b;
            return this
        }, copyGammaToLinear: function (a) {
            this.r = a.r * a.r;
            this.g = a.g * a.g;
            this.b = a.b * a.b;
            return this
        }, copyLinearToGamma: function (a) {
            this.r = Math.sqrt(a.r);
            this.g = Math.sqrt(a.g);
            this.b = Math.sqrt(a.b);
            return this
        }, convertGammaToLinear: function () {
            var a = this.r, b = this.g, d = this.b;
            this.r = a * a;
            this.g = b * b;
            this.b = d * d;
            return this
        }, convertLinearToGamma: function () {
            this.r = Math.sqrt(this.r);
            this.g = Math.sqrt(this.g);
            this.b = Math.sqrt(this.b);
            return this
        }, getHex: function () {
            return 255 * this.r << 16 ^ 255 * this.g <<
                8 ^ 255 * this.b << 0
        }, getHexString: function () {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        }, getHSL: function (a) {
            a = a || {h: 0, s: 0, l: 0};
            var b = this.r, d = this.g, e = this.b, f = Math.max(b, d, e), h = Math.min(b, d, e), g, k = (h + f) / 2;
            if (h === f) h = g = 0; else {
                var l = f - h, h = .5 >= k ? l / (f + h) : l / (2 - f - h);
                switch (f) {
                    case b:
                        g = (d - e) / l + (d < e ? 6 : 0);
                        break;
                    case d:
                        g = (e - b) / l + 2;
                        break;
                    case e:
                        g = (b - d) / l + 4
                }
                g /= 6
            }
            a.h = g;
            a.s = h;
            a.l = k;
            return a
        }, getStyle: function () {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        }, offsetHSL: function (a,
                                b, d) {
            var e = this.getHSL();
            e.h += a;
            e.s += b;
            e.l += d;
            this.setHSL(e.h, e.s, e.l);
            return this
        }, add: function (a) {
            this.r += a.r;
            this.g += a.g;
            this.b += a.b;
            return this
        }, addColors: function (a, b) {
            this.r = a.r + b.r;
            this.g = a.g + b.g;
            this.b = a.b + b.b;
            return this
        }, addScalar: function (a) {
            this.r += a;
            this.g += a;
            this.b += a;
            return this
        }, multiply: function (a) {
            this.r *= a.r;
            this.g *= a.g;
            this.b *= a.b;
            return this
        }, multiplyScalar: function (a) {
            this.r *= a;
            this.g *= a;
            this.b *= a;
            return this
        }, lerp: function (a, b) {
            this.r += (a.r - this.r) * b;
            this.g += (a.g - this.g) * b;
            this.b += (a.b - this.b) * b;
            return this
        }, equals: function (a) {
            return a.r === this.r && a.g === this.g && a.b === this.b
        }, fromArray: function (a) {
            this.r = a[0];
            this.g = a[1];
            this.b = a[2];
            return this
        }, toArray: function () {
            return [this.r, this.g, this.b]
        }, clone: function () {
            return (new THREE.Color).setRGB(this.r, this.g, this.b)
        }
    };
    THREE.ColorKeywords = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    };
    THREE.Quaternion = function (a, b, d, e) {
        this._x = a || 0;
        this._y = b || 0;
        this._z = d || 0;
        this._w = void 0 !== e ? e : 1
    };
    THREE.Quaternion.prototype = {
        constructor: THREE.Quaternion, _x: 0, _y: 0, _z: 0, _w: 0, get x() {
            return this._x
        }, set x(a) {
            this._x = a;
            this.onChangeCallback()
        }, get y() {
            return this._y
        }, set y(a) {
            this._y = a;
            this.onChangeCallback()
        }, get z() {
            return this._z
        }, set z(a) {
            this._z = a;
            this.onChangeCallback()
        }, get w() {
            return this._w
        }, set w(a) {
            this._w = a;
            this.onChangeCallback()
        }, set: function (a, b, d, e) {
            this._x = a;
            this._y = b;
            this._z = d;
            this._w = e;
            this.onChangeCallback();
            return this
        }, copy: function (a) {
            this._x = a.x;
            this._y = a.y;
            this._z = a.z;
            this._w = a.w;
            this.onChangeCallback();
            return this
        }, setFromEuler: function (a, b) {
            if (!1 === a instanceof THREE.Euler) throw Error("THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var d = Math.cos(a._x / 2), e = Math.cos(a._y / 2), f = Math.cos(a._z / 2), h = Math.sin(a._x / 2),
                g = Math.sin(a._y / 2), k = Math.sin(a._z / 2);
            "XYZ" === a.order ? (this._x = h * e * f + d * g * k, this._y = d * g * f - h * e * k, this._z = d * e * k + h * g * f, this._w = d * e * f - h * g * k) : "YXZ" === a.order ? (this._x = h * e * f + d * g * k, this._y = d * g * f - h * e * k, this._z =
                d * e * k - h * g * f, this._w = d * e * f + h * g * k) : "ZXY" === a.order ? (this._x = h * e * f - d * g * k, this._y = d * g * f + h * e * k, this._z = d * e * k + h * g * f, this._w = d * e * f - h * g * k) : "ZYX" === a.order ? (this._x = h * e * f - d * g * k, this._y = d * g * f + h * e * k, this._z = d * e * k - h * g * f, this._w = d * e * f + h * g * k) : "YZX" === a.order ? (this._x = h * e * f + d * g * k, this._y = d * g * f + h * e * k, this._z = d * e * k - h * g * f, this._w = d * e * f - h * g * k) : "XZY" === a.order && (this._x = h * e * f - d * g * k, this._y = d * g * f - h * e * k, this._z = d * e * k + h * g * f, this._w = d * e * f + h * g * k);
            if (!1 !== b) this.onChangeCallback();
            return this
        }, setFromAxisAngle: function (a,
                                       b) {
            var d = b / 2, e = Math.sin(d);
            this._x = a.x * e;
            this._y = a.y * e;
            this._z = a.z * e;
            this._w = Math.cos(d);
            this.onChangeCallback();
            return this
        }, setFromRotationMatrix: function (a) {
            var b = a.elements, d = b[0];
            a = b[4];
            var e = b[8], f = b[1], h = b[5], g = b[9], k = b[2], l = b[6], b = b[10], m = d + h + b;
            0 < m ? (d = .5 / Math.sqrt(m + 1), this._w = .25 / d, this._x = (l - g) * d, this._y = (e - k) * d, this._z = (f - a) * d) : d > h && d > b ? (d = 2 * Math.sqrt(1 + d - h - b), this._w = (l - g) / d, this._x = .25 * d, this._y = (a + f) / d, this._z = (e + k) / d) : h > b ? (d = 2 * Math.sqrt(1 + h - d - b), this._w = (e - k) / d, this._x = (a + f) / d, this._y =
                .25 * d, this._z = (g + l) / d) : (d = 2 * Math.sqrt(1 + b - d - h), this._w = (f - a) / d, this._x = (e + k) / d, this._y = (g + l) / d, this._z = .25 * d);
            this.onChangeCallback();
            return this
        }, setFromUnitVectors: function () {
            var a, b;
            return function (d, e) {
                void 0 === a && (a = new THREE.Vector3);
                b = d.dot(e) + 1;
                1E-6 > b ? (b = 0, Math.abs(d.x) > Math.abs(d.z) ? a.set(-d.y, d.x, 0) : a.set(0, -d.z, d.y)) : a.crossVectors(d, e);
                this._x = a.x;
                this._y = a.y;
                this._z = a.z;
                this._w = b;
                this.normalize();
                return this
            }
        }(), inverse: function () {
            this.conjugate().normalize();
            return this
        }, conjugate: function () {
            this._x *=
                -1;
            this._y *= -1;
            this._z *= -1;
            this.onChangeCallback();
            return this
        }, dot: function (a) {
            return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w
        }, lengthSq: function () {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        }, length: function () {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        }, normalize: function () {
            var a = this.length();
            0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, this._y *= a, this._z *= a, this._w *= a);
            this.onChangeCallback();
            return this
        },
        multiply: function (a, b) {
            return void 0 !== b ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a)
        }, multiplyQuaternions: function (a, b) {
            var d = a._x, e = a._y, f = a._z, h = a._w, g = b._x, k = b._y, l = b._z, m = b._w;
            this._x = d * m + h * g + e * l - f * k;
            this._y = e * m + h * k + f * g - d * l;
            this._z = f * m + h * l + d * k - e * g;
            this._w = h * m - d * g - e * k - f * l;
            this.onChangeCallback();
            return this
        }, multiplyVector3: function (a) {
            console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
            return a.applyQuaternion(this)
        }, slerp: function (a, b) {
            if (0 === b) return this;
            if (1 === b) return this.copy(a);
            var d = this._x, e = this._y, f = this._z, h = this._w, g = h * a._w + d * a._x + e * a._y + f * a._z;
            0 > g ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, g = -g) : this.copy(a);
            if (1 <= g) return this._w = h, this._x = d, this._y = e, this._z = f, this;
            var k = Math.acos(g), l = Math.sqrt(1 - g * g);
            if (.001 > Math.abs(l)) return this._w = .5 * (h + this._w), this._x = .5 * (d + this._x), this._y = .5 * (e + this._y), this._z = .5 * (f + this._z), this;
            g = Math.sin((1 - b) * k) / l;
            k =
                Math.sin(b * k) / l;
            this._w = h * g + this._w * k;
            this._x = d * g + this._x * k;
            this._y = e * g + this._y * k;
            this._z = f * g + this._z * k;
            this.onChangeCallback();
            return this
        }, equals: function (a) {
            return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w
        }, fromArray: function (a, b) {
            void 0 === b && (b = 0);
            this._x = a[b];
            this._y = a[b + 1];
            this._z = a[b + 2];
            this._w = a[b + 3];
            this.onChangeCallback();
            return this
        }, toArray: function (a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            a[b] = this._x;
            a[b + 1] = this._y;
            a[b + 2] = this._z;
            a[b + 3] = this._w;
            return a
        }, onChange: function (a) {
            this.onChangeCallback =
                a;
            return this
        }, onChangeCallback: function () {
        }, clone: function () {
            return new THREE.Quaternion(this._x, this._y, this._z, this._w)
        }
    };
    THREE.Quaternion.slerp = function (a, b, d, e) {
        return d.copy(a).slerp(b, e)
    };
    THREE.Vector2 = function (a, b) {
        this.x = a || 0;
        this.y = b || 0
    };
    THREE.Vector2.prototype = {
        constructor: THREE.Vector2, set: function (a, b) {
            this.x = a;
            this.y = b;
            return this
        }, setX: function (a) {
            this.x = a;
            return this
        }, setY: function (a) {
            this.y = a;
            return this
        }, setComponent: function (a, b) {
            switch (a) {
                case 0:
                    this.x = b;
                    break;
                case 1:
                    this.y = b;
                    break;
                default:
                    throw Error("index is out of range: " + a);
            }
        }, getComponent: function (a) {
            switch (a) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw Error("index is out of range: " + a);
            }
        }, copy: function (a) {
            this.x = a.x;
            this.y = a.y;
            return this
        }, add: function (a,
                          b) {
            if (void 0 !== b) return console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
            this.x += a.x;
            this.y += a.y;
            return this
        }, addVectors: function (a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            return this
        }, addScalar: function (a) {
            this.x += a;
            this.y += a;
            return this
        }, sub: function (a, b) {
            if (void 0 !== b) return console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
            this.x -= a.x;
            this.y -= a.y;
            return this
        },
        subVectors: function (a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            return this
        }, multiply: function (a) {
            this.x *= a.x;
            this.y *= a.y;
            return this
        }, multiplyScalar: function (a) {
            this.x *= a;
            this.y *= a;
            return this
        }, divide: function (a) {
            this.x /= a.x;
            this.y /= a.y;
            return this
        }, divideScalar: function (a) {
            0 !== a ? (a = 1 / a, this.x *= a, this.y *= a) : this.y = this.x = 0;
            return this
        }, min: function (a) {
            this.x > a.x && (this.x = a.x);
            this.y > a.y && (this.y = a.y);
            return this
        }, max: function (a) {
            this.x < a.x && (this.x = a.x);
            this.y < a.y && (this.y = a.y);
            return this
        }, clamp: function (a,
                            b) {
            this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
            this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
            return this
        }, clampScalar: function () {
            var a, b;
            return function (d, e) {
                void 0 === a && (a = new THREE.Vector2, b = new THREE.Vector2);
                a.set(d, d);
                b.set(e, e);
                return this.clamp(a, b)
            }
        }(), floor: function () {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            return this
        }, ceil: function () {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            return this
        }, round: function () {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this
        },
        roundToZero: function () {
            this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
            return this
        }, negate: function () {
            this.x = -this.x;
            this.y = -this.y;
            return this
        }, dot: function (a) {
            return this.x * a.x + this.y * a.y
        }, lengthSq: function () {
            return this.x * this.x + this.y * this.y
        }, length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        }, normalize: function () {
            return this.divideScalar(this.length())
        }, distanceTo: function (a) {
            return Math.sqrt(this.distanceToSquared(a))
        }, distanceToSquared: function (a) {
            var b =
                this.x - a.x;
            a = this.y - a.y;
            return b * b + a * a
        }, setLength: function (a) {
            var b = this.length();
            0 !== b && a !== b && this.multiplyScalar(a / b);
            return this
        }, lerp: function (a, b) {
            this.x += (a.x - this.x) * b;
            this.y += (a.y - this.y) * b;
            return this
        }, equals: function (a) {
            return a.x === this.x && a.y === this.y
        }, fromArray: function (a, b) {
            void 0 === b && (b = 0);
            this.x = a[b];
            this.y = a[b + 1];
            return this
        }, toArray: function (a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            a[b] = this.x;
            a[b + 1] = this.y;
            return a
        }, clone: function () {
            return new THREE.Vector2(this.x, this.y)
        }
    };
    THREE.Vector3 = function (a, b, d) {
        this.x = a || 0;
        this.y = b || 0;
        this.z = d || 0
    };
    THREE.Vector3.prototype = {
        constructor: THREE.Vector3, set: function (a, b, d) {
            this.x = a;
            this.y = b;
            this.z = d;
            return this
        }, setX: function (a) {
            this.x = a;
            return this
        }, setY: function (a) {
            this.y = a;
            return this
        }, setZ: function (a) {
            this.z = a;
            return this
        }, setComponent: function (a, b) {
            switch (a) {
                case 0:
                    this.x = b;
                    break;
                case 1:
                    this.y = b;
                    break;
                case 2:
                    this.z = b;
                    break;
                default:
                    throw Error("index is out of range: " + a);
            }
        }, getComponent: function (a) {
            switch (a) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw Error("index is out of range: " +
                        a);
            }
        }, copy: function (a) {
            this.x = a.x;
            this.y = a.y;
            this.z = a.z;
            return this
        }, add: function (a, b) {
            if (void 0 !== b) return console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
            this.x += a.x;
            this.y += a.y;
            this.z += a.z;
            return this
        }, addScalar: function (a) {
            this.x += a;
            this.y += a;
            this.z += a;
            return this
        }, addVectors: function (a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            return this
        }, sub: function (a, b) {
            if (void 0 !== b) return console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                this.subVectors(a, b);
            this.x -= a.x;
            this.y -= a.y;
            this.z -= a.z;
            return this
        }, subVectors: function (a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            return this
        }, multiply: function (a, b) {
            if (void 0 !== b) return console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(a, b);
            this.x *= a.x;
            this.y *= a.y;
            this.z *= a.z;
            return this
        }, multiplyScalar: function (a) {
            this.x *= a;
            this.y *= a;
            this.z *= a;
            return this
        }, multiplyVectors: function (a, b) {
            this.x = a.x * b.x;
            this.y =
                a.y * b.y;
            this.z = a.z * b.z;
            return this
        }, applyEuler: function () {
            var a;
            return function (b) {
                !1 === b instanceof THREE.Euler && console.error("THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.");
                void 0 === a && (a = new THREE.Quaternion);
                this.applyQuaternion(a.setFromEuler(b));
                return this
            }
        }(), applyAxisAngle: function () {
            var a;
            return function (b, d) {
                void 0 === a && (a = new THREE.Quaternion);
                this.applyQuaternion(a.setFromAxisAngle(b, d));
                return this
            }
        }(), applyMatrix3: function (a) {
            var b = this.x,
                d = this.y, e = this.z;
            a = a.elements;
            this.x = a[0] * b + a[3] * d + a[6] * e;
            this.y = a[1] * b + a[4] * d + a[7] * e;
            this.z = a[2] * b + a[5] * d + a[8] * e;
            return this
        }, applyMatrix4: function (a) {
            var b = this.x, d = this.y, e = this.z;
            a = a.elements;
            this.x = a[0] * b + a[4] * d + a[8] * e + a[12];
            this.y = a[1] * b + a[5] * d + a[9] * e + a[13];
            this.z = a[2] * b + a[6] * d + a[10] * e + a[14];
            return this
        }, applyProjection: function (a) {
            var b = this.x, d = this.y, e = this.z;
            a = a.elements;
            var f = 1 / (a[3] * b + a[7] * d + a[11] * e + a[15]);
            this.x = (a[0] * b + a[4] * d + a[8] * e + a[12]) * f;
            this.y = (a[1] * b + a[5] * d + a[9] * e + a[13]) * f;
            this.z =
                (a[2] * b + a[6] * d + a[10] * e + a[14]) * f;
            return this
        }, applyQuaternion: function (a) {
            var b = this.x, d = this.y, e = this.z, f = a.x, h = a.y, g = a.z;
            a = a.w;
            var k = a * b + h * e - g * d, l = a * d + g * b - f * e, m = a * e + f * d - h * b,
                b = -f * b - h * d - g * e;
            this.x = k * a + b * -f + l * -g - m * -h;
            this.y = l * a + b * -h + m * -f - k * -g;
            this.z = m * a + b * -g + k * -h - l * -f;
            return this
        }, project: function () {
            var a;
            return function (b) {
                void 0 === a && (a = new THREE.Matrix4);
                a.multiplyMatrices(b.projectionMatrix, a.getInverse(b.matrixWorld));
                return this.applyProjection(a)
            }
        }(), unproject: function () {
            var a;
            return function (b) {
                void 0 ===
                a && (a = new THREE.Matrix4);
                a.multiplyMatrices(b.matrixWorld, a.getInverse(b.projectionMatrix));
                return this.applyProjection(a)
            }
        }(), transformDirection: function (a) {
            var b = this.x, d = this.y, e = this.z;
            a = a.elements;
            this.x = a[0] * b + a[4] * d + a[8] * e;
            this.y = a[1] * b + a[5] * d + a[9] * e;
            this.z = a[2] * b + a[6] * d + a[10] * e;
            this.normalize();
            return this
        }, divide: function (a) {
            this.x /= a.x;
            this.y /= a.y;
            this.z /= a.z;
            return this
        }, divideScalar: function (a) {
            0 !== a ? (a = 1 / a, this.x *= a, this.y *= a, this.z *= a) : this.z = this.y = this.x = 0;
            return this
        }, min: function (a) {
            this.x >
            a.x && (this.x = a.x);
            this.y > a.y && (this.y = a.y);
            this.z > a.z && (this.z = a.z);
            return this
        }, max: function (a) {
            this.x < a.x && (this.x = a.x);
            this.y < a.y && (this.y = a.y);
            this.z < a.z && (this.z = a.z);
            return this
        }, clamp: function (a, b) {
            this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
            this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
            this.z < a.z ? this.z = a.z : this.z > b.z && (this.z = b.z);
            return this
        }, clampScalar: function () {
            var a, b;
            return function (d, e) {
                void 0 === a && (a = new THREE.Vector3, b = new THREE.Vector3);
                a.set(d, d, d);
                b.set(e, e, e);
                return this.clamp(a,
                    b)
            }
        }(), floor: function () {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.z = Math.floor(this.z);
            return this
        }, ceil: function () {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            this.z = Math.ceil(this.z);
            return this
        }, round: function () {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            this.z = Math.round(this.z);
            return this
        }, roundToZero: function () {
            this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
            this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
            return this
        }, negate: function () {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            return this
        }, dot: function (a) {
            return this.x * a.x + this.y * a.y + this.z * a.z
        }, lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z
        }, length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        }, lengthManhattan: function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        }, normalize: function () {
            return this.divideScalar(this.length())
        }, setLength: function (a) {
            var b = this.length();
            0 !== b && a !== b && this.multiplyScalar(a /
                b);
            return this
        }, lerp: function (a, b) {
            this.x += (a.x - this.x) * b;
            this.y += (a.y - this.y) * b;
            this.z += (a.z - this.z) * b;
            return this
        }, cross: function (a, b) {
            if (void 0 !== b) return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(a, b);
            var d = this.x, e = this.y, f = this.z;
            this.x = e * a.z - f * a.y;
            this.y = f * a.x - d * a.z;
            this.z = d * a.y - e * a.x;
            return this
        }, crossVectors: function (a, b) {
            var d = a.x, e = a.y, f = a.z, h = b.x, g = b.y, k = b.z;
            this.x = e * k - f * g;
            this.y = f * h - d * k;
            this.z = d * g - e * h;
            return this
        },
        projectOnVector: function () {
            var a, b;
            return function (d) {
                void 0 === a && (a = new THREE.Vector3);
                a.copy(d).normalize();
                b = this.dot(a);
                return this.copy(a).multiplyScalar(b)
            }
        }(), projectOnPlane: function () {
            var a;
            return function (b) {
                void 0 === a && (a = new THREE.Vector3);
                a.copy(this).projectOnVector(b);
                return this.sub(a)
            }
        }(), reflect: function () {
            var a;
            return function (b) {
                void 0 === a && (a = new THREE.Vector3);
                return this.sub(a.copy(b).multiplyScalar(2 * this.dot(b)))
            }
        }(), angleTo: function (a) {
            a = this.dot(a) / (this.length() * a.length());
            return Math.acos(THREE.Math.clamp(a, -1, 1))
        }, distanceTo: function (a) {
            return Math.sqrt(this.distanceToSquared(a))
        }, distanceToSquared: function (a) {
            var b = this.x - a.x, d = this.y - a.y;
            a = this.z - a.z;
            return b * b + d * d + a * a
        }, setEulerFromRotationMatrix: function (a, b) {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        }, setEulerFromQuaternion: function (a, b) {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        },
        getPositionFromMatrix: function (a) {
            console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
            return this.setFromMatrixPosition(a)
        }, getScaleFromMatrix: function (a) {
            console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
            return this.setFromMatrixScale(a)
        }, getColumnFromMatrix: function (a, b) {
            console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
            return this.setFromMatrixColumn(a,
                b)
        }, setFromMatrixPosition: function (a) {
            this.x = a.elements[12];
            this.y = a.elements[13];
            this.z = a.elements[14];
            return this
        }, setFromMatrixScale: function (a) {
            var b = this.set(a.elements[0], a.elements[1], a.elements[2]).length(),
                d = this.set(a.elements[4], a.elements[5], a.elements[6]).length();
            a = this.set(a.elements[8], a.elements[9], a.elements[10]).length();
            this.x = b;
            this.y = d;
            this.z = a;
            return this
        }, setFromMatrixColumn: function (a, b) {
            var d = 4 * a, e = b.elements;
            this.x = e[d];
            this.y = e[d + 1];
            this.z = e[d + 2];
            return this
        }, equals: function (a) {
            return a.x ===
                this.x && a.y === this.y && a.z === this.z
        }, fromArray: function (a, b) {
            void 0 === b && (b = 0);
            this.x = a[b];
            this.y = a[b + 1];
            this.z = a[b + 2];
            return this
        }, toArray: function (a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            a[b] = this.x;
            a[b + 1] = this.y;
            a[b + 2] = this.z;
            return a
        }, clone: function () {
            return new THREE.Vector3(this.x, this.y, this.z)
        }
    };
    THREE.Vector4 = function (a, b, d, e) {
        this.x = a || 0;
        this.y = b || 0;
        this.z = d || 0;
        this.w = void 0 !== e ? e : 1
    };
    THREE.Vector4.prototype = {
        constructor: THREE.Vector4, set: function (a, b, d, e) {
            this.x = a;
            this.y = b;
            this.z = d;
            this.w = e;
            return this
        }, setX: function (a) {
            this.x = a;
            return this
        }, setY: function (a) {
            this.y = a;
            return this
        }, setZ: function (a) {
            this.z = a;
            return this
        }, setW: function (a) {
            this.w = a;
            return this
        }, setComponent: function (a, b) {
            switch (a) {
                case 0:
                    this.x = b;
                    break;
                case 1:
                    this.y = b;
                    break;
                case 2:
                    this.z = b;
                    break;
                case 3:
                    this.w = b;
                    break;
                default:
                    throw Error("index is out of range: " + a);
            }
        }, getComponent: function (a) {
            switch (a) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw Error("index is out of range: " + a);
            }
        }, copy: function (a) {
            this.x = a.x;
            this.y = a.y;
            this.z = a.z;
            this.w = void 0 !== a.w ? a.w : 1;
            return this
        }, add: function (a, b) {
            if (void 0 !== b) return console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
            this.x += a.x;
            this.y += a.y;
            this.z += a.z;
            this.w += a.w;
            return this
        }, addScalar: function (a) {
            this.x += a;
            this.y += a;
            this.z += a;
            this.w += a;
            return this
        },
        addVectors: function (a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            this.w = a.w + b.w;
            return this
        }, sub: function (a, b) {
            if (void 0 !== b) return console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
            this.x -= a.x;
            this.y -= a.y;
            this.z -= a.z;
            this.w -= a.w;
            return this
        }, subVectors: function (a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            this.w = a.w - b.w;
            return this
        }, multiplyScalar: function (a) {
            this.x *= a;
            this.y *= a;
            this.z *= a;
            this.w *= a;
            return this
        }, applyMatrix4: function (a) {
            var b =
                this.x, d = this.y, e = this.z, f = this.w;
            a = a.elements;
            this.x = a[0] * b + a[4] * d + a[8] * e + a[12] * f;
            this.y = a[1] * b + a[5] * d + a[9] * e + a[13] * f;
            this.z = a[2] * b + a[6] * d + a[10] * e + a[14] * f;
            this.w = a[3] * b + a[7] * d + a[11] * e + a[15] * f;
            return this
        }, divideScalar: function (a) {
            0 !== a ? (a = 1 / a, this.x *= a, this.y *= a, this.z *= a, this.w *= a) : (this.z = this.y = this.x = 0, this.w = 1);
            return this
        }, setAxisAngleFromQuaternion: function (a) {
            this.w = 2 * Math.acos(a.w);
            var b = Math.sqrt(1 - a.w * a.w);
            1E-4 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b);
            return this
        },
        setAxisAngleFromRotationMatrix: function (a) {
            var b, d, e;
            a = a.elements;
            var f = a[0];
            e = a[4];
            var h = a[8], g = a[1], k = a[5], l = a[9];
            d = a[2];
            b = a[6];
            var m = a[10];
            if (.01 > Math.abs(e - g) && .01 > Math.abs(h - d) && .01 > Math.abs(l - b)) {
                if (.1 > Math.abs(e + g) && .1 > Math.abs(h + d) && .1 > Math.abs(l + b) && .1 > Math.abs(f + k + m - 3)) return this.set(1, 0, 0, 0), this;
                a = Math.PI;
                f = (f + 1) / 2;
                k = (k + 1) / 2;
                m = (m + 1) / 2;
                e = (e + g) / 4;
                h = (h + d) / 4;
                l = (l + b) / 4;
                f > k && f > m ? .01 > f ? (b = 0, e = d = .707106781) : (b = Math.sqrt(f), d = e / b, e = h / b) : k > m ? .01 > k ? (b = .707106781, d = 0, e = .707106781) : (d = Math.sqrt(k),
                    b = e / d, e = l / d) : .01 > m ? (d = b = .707106781, e = 0) : (e = Math.sqrt(m), b = h / e, d = l / e);
                this.set(b, d, e, a);
                return this
            }
            a = Math.sqrt((b - l) * (b - l) + (h - d) * (h - d) + (g - e) * (g - e));
            .001 > Math.abs(a) && (a = 1);
            this.x = (b - l) / a;
            this.y = (h - d) / a;
            this.z = (g - e) / a;
            this.w = Math.acos((f + k + m - 1) / 2);
            return this
        }, min: function (a) {
            this.x > a.x && (this.x = a.x);
            this.y > a.y && (this.y = a.y);
            this.z > a.z && (this.z = a.z);
            this.w > a.w && (this.w = a.w);
            return this
        }, max: function (a) {
            this.x < a.x && (this.x = a.x);
            this.y < a.y && (this.y = a.y);
            this.z < a.z && (this.z = a.z);
            this.w < a.w && (this.w = a.w);
            return this
        }, clamp: function (a, b) {
            this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
            this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
            this.z < a.z ? this.z = a.z : this.z > b.z && (this.z = b.z);
            this.w < a.w ? this.w = a.w : this.w > b.w && (this.w = b.w);
            return this
        }, clampScalar: function () {
            var a, b;
            return function (d, e) {
                void 0 === a && (a = new THREE.Vector4, b = new THREE.Vector4);
                a.set(d, d, d, d);
                b.set(e, e, e, e);
                return this.clamp(a, b)
            }
        }(), floor: function () {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.z = Math.floor(this.z);
            this.w = Math.floor(this.w);
            return this
        }, ceil: function () {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            this.z = Math.ceil(this.z);
            this.w = Math.ceil(this.w);
            return this
        }, round: function () {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            this.z = Math.round(this.z);
            this.w = Math.round(this.w);
            return this
        }, roundToZero: function () {
            this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
            this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
            this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w);
            return this
        }, negate: function () {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            this.w = -this.w;
            return this
        }, dot: function (a) {
            return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w
        }, lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        }, length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        }, lengthManhattan: function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        }, normalize: function () {
            return this.divideScalar(this.length())
        },
        setLength: function (a) {
            var b = this.length();
            0 !== b && a !== b && this.multiplyScalar(a / b);
            return this
        }, lerp: function (a, b) {
            this.x += (a.x - this.x) * b;
            this.y += (a.y - this.y) * b;
            this.z += (a.z - this.z) * b;
            this.w += (a.w - this.w) * b;
            return this
        }, equals: function (a) {
            return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w
        }, fromArray: function (a, b) {
            void 0 === b && (b = 0);
            this.x = a[b];
            this.y = a[b + 1];
            this.z = a[b + 2];
            this.w = a[b + 3];
            return this
        }, toArray: function (a, b) {
            void 0 === a && (a = []);
            void 0 === b && (b = 0);
            a[b] = this.x;
            a[b + 1] = this.y;
            a[b + 2] =
                this.z;
            a[b + 3] = this.w;
            return a
        }, clone: function () {
            return new THREE.Vector4(this.x, this.y, this.z, this.w)
        }
    };
    THREE.Euler = function (a, b, d, e) {
        this._x = a || 0;
        this._y = b || 0;
        this._z = d || 0;
        this._order = e || THREE.Euler.DefaultOrder
    };
    THREE.Euler.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" ");
    THREE.Euler.DefaultOrder = "XYZ";
    THREE.Euler.prototype = {
        constructor: THREE.Euler, _x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder, get x() {
            return this._x
        }, set x(a) {
            this._x = a;
            this.onChangeCallback()
        }, get y() {
            return this._y
        }, set y(a) {
            this._y = a;
            this.onChangeCallback()
        }, get z() {
            return this._z
        }, set z(a) {
            this._z = a;
            this.onChangeCallback()
        }, get order() {
            return this._order
        }, set order(a) {
            this._order = a;
            this.onChangeCallback()
        }, set: function (a, b, d, e) {
            this._x = a;
            this._y = b;
            this._z = d;
            this._order = e || this._order;
            this.onChangeCallback();
            return this
        }, copy: function (a) {
            this._x =
                a._x;
            this._y = a._y;
            this._z = a._z;
            this._order = a._order;
            this.onChangeCallback();
            return this
        }, setFromRotationMatrix: function (a, b) {
            var d = THREE.Math.clamp, e = a.elements, f = e[0], h = e[4], g = e[8], k = e[1], l = e[5], m = e[9],
                n = e[2], q = e[6], e = e[10];
            b = b || this._order;
            "XYZ" === b ? (this._y = Math.asin(d(g, -1, 1)), .99999 > Math.abs(g) ? (this._x = Math.atan2(-m, e), this._z = Math.atan2(-h, f)) : (this._x = Math.atan2(q, l), this._z = 0)) : "YXZ" === b ? (this._x = Math.asin(-d(m, -1, 1)), .99999 > Math.abs(m) ? (this._y = Math.atan2(g, e), this._z = Math.atan2(k, l)) : (this._y =
                Math.atan2(-n, f), this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(d(q, -1, 1)), .99999 > Math.abs(q) ? (this._y = Math.atan2(-n, e), this._z = Math.atan2(-h, l)) : (this._y = 0, this._z = Math.atan2(k, f))) : "ZYX" === b ? (this._y = Math.asin(-d(n, -1, 1)), .99999 > Math.abs(n) ? (this._x = Math.atan2(q, e), this._z = Math.atan2(k, f)) : (this._x = 0, this._z = Math.atan2(-h, l))) : "YZX" === b ? (this._z = Math.asin(d(k, -1, 1)), .99999 > Math.abs(k) ? (this._x = Math.atan2(-m, l), this._y = Math.atan2(-n, f)) : (this._x = 0, this._y = Math.atan2(g, e))) : "XZY" === b ? (this._z = Math.asin(-d(h,
                -1, 1)), .99999 > Math.abs(h) ? (this._x = Math.atan2(q, l), this._y = Math.atan2(g, f)) : (this._x = Math.atan2(-m, e), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + b);
            this._order = b;
            this.onChangeCallback();
            return this
        }, setFromQuaternion: function (a, b, d) {
            var e = THREE.Math.clamp, f = a.x * a.x, h = a.y * a.y, g = a.z * a.z, k = a.w * a.w;
            b = b || this._order;
            "XYZ" === b ? 0 === a.x && 0 === a.y && 0 === a.z && 1 === a.w ? this._z = this._y = this._x = 0 : (this._x = Math.atan2(2 * (a.x * a.w - a.y * a.z), k - f - h + g), this._y = Math.asin(e(2 *
                (a.x * a.z + a.y * a.w), -1, 1)), this._z = Math.atan2(2 * (a.z * a.w - a.x * a.y), k + f - h - g)) : "YXZ" === b ? (this._x = Math.asin(e(2 * (a.x * a.w - a.y * a.z), -1, 1)), this._y = Math.atan2(2 * (a.x * a.z + a.y * a.w), k - f - h + g), this._z = Math.atan2(2 * (a.x * a.y + a.z * a.w), k - f + h - g)) : "ZXY" === b ? (this._x = Math.asin(e(2 * (a.x * a.w + a.y * a.z), -1, 1)), this._y = Math.atan2(2 * (a.y * a.w - a.z * a.x), k - f - h + g), this._z = Math.atan2(2 * (a.z * a.w - a.x * a.y), k - f + h - g)) : "ZYX" === b ? (this._x = Math.atan2(2 * (a.x * a.w + a.z * a.y), k - f - h + g), this._y = Math.asin(e(2 * (a.y * a.w - a.x * a.z), -1, 1)), this._z = Math.atan2(2 *
                (a.x * a.y + a.z * a.w), k + f - h - g)) : "YZX" === b ? (this._x = Math.atan2(2 * (a.x * a.w - a.z * a.y), k - f + h - g), this._y = Math.atan2(2 * (a.y * a.w - a.x * a.z), k + f - h - g), this._z = Math.asin(e(2 * (a.x * a.y + a.z * a.w), -1, 1))) : "XZY" === b ? (this._x = Math.atan2(2 * (a.x * a.w + a.y * a.z), k - f + h - g), this._y = Math.atan2(2 * (a.x * a.z + a.y * a.w), k + f - h - g), this._z = Math.asin(e(2 * (a.z * a.w - a.x * a.y), -1, 1))) : console.warn("THREE.Euler: .setFromQuaternion() given unsupported order: " + b);
            this._order = b;
            if (!1 !== d) this.onChangeCallback();
            return this
        }, reorder: function () {
            var a =
                new THREE.Quaternion;
            return function (b) {
                a.setFromEuler(this);
                this.setFromQuaternion(a, b)
            }
        }(), equals: function (a) {
            return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order
        }, fromArray: function (a) {
            this._x = a[0];
            this._y = a[1];
            this._z = a[2];
            void 0 !== a[3] && (this._order = a[3]);
            this.onChangeCallback();
            return this
        }, toArray: function () {
            return [this._x, this._y, this._z, this._order]
        }, onChange: function (a) {
            this.onChangeCallback = a;
            return this
        }, onChangeCallback: function () {
        }, clone: function () {
            return new THREE.Euler(this._x,
                this._y, this._z, this._order)
        }
    };
    THREE.Line3 = function (a, b) {
        this.start = void 0 !== a ? a : new THREE.Vector3;
        this.end = void 0 !== b ? b : new THREE.Vector3
    };
    THREE.Line3.prototype = {
        constructor: THREE.Line3, set: function (a, b) {
            this.start.copy(a);
            this.end.copy(b);
            return this
        }, copy: function (a) {
            this.start.copy(a.start);
            this.end.copy(a.end);
            return this
        }, center: function (a) {
            return (a || new THREE.Vector3).addVectors(this.start, this.end).multiplyScalar(.5)
        }, delta: function (a) {
            return (a || new THREE.Vector3).subVectors(this.end, this.start)
        }, distanceSq: function () {
            return this.start.distanceToSquared(this.end)
        }, distance: function () {
            return this.start.distanceTo(this.end)
        }, at: function (a,
                         b) {
            var d = b || new THREE.Vector3;
            return this.delta(d).multiplyScalar(a).add(this.start)
        }, closestPointToPointParameter: function () {
            var a = new THREE.Vector3, b = new THREE.Vector3;
            return function (d, e) {
                a.subVectors(d, this.start);
                b.subVectors(this.end, this.start);
                var f = b.dot(b), f = b.dot(a) / f;
                e && (f = THREE.Math.clamp(f, 0, 1));
                return f
            }
        }(), closestPointToPoint: function (a, b, d) {
            a = this.closestPointToPointParameter(a, b);
            d = d || new THREE.Vector3;
            return this.delta(d).multiplyScalar(a).add(this.start)
        }, applyMatrix4: function (a) {
            this.start.applyMatrix4(a);
            this.end.applyMatrix4(a);
            return this
        }, equals: function (a) {
            return a.start.equals(this.start) && a.end.equals(this.end)
        }, clone: function () {
            return (new THREE.Line3).copy(this)
        }
    };
    THREE.Box2 = function (a, b) {
        this.min = void 0 !== a ? a : new THREE.Vector2(Infinity, Infinity);
        this.max = void 0 !== b ? b : new THREE.Vector2(-Infinity, -Infinity)
    };
    THREE.Box2.prototype = {
        constructor: THREE.Box2, set: function (a, b) {
            this.min.copy(a);
            this.max.copy(b);
            return this
        }, setFromPoints: function (a) {
            this.makeEmpty();
            for (var b = 0, d = a.length; b < d; b++) this.expandByPoint(a[b]);
            return this
        }, setFromCenterAndSize: function () {
            var a = new THREE.Vector2;
            return function (b, d) {
                var e = a.copy(d).multiplyScalar(.5);
                this.min.copy(b).sub(e);
                this.max.copy(b).add(e);
                return this
            }
        }(), copy: function (a) {
            this.min.copy(a.min);
            this.max.copy(a.max);
            return this
        }, makeEmpty: function () {
            this.min.x =
                this.min.y = Infinity;
            this.max.x = this.max.y = -Infinity;
            return this
        }, empty: function () {
            return this.max.x < this.min.x || this.max.y < this.min.y
        }, center: function (a) {
            return (a || new THREE.Vector2).addVectors(this.min, this.max).multiplyScalar(.5)
        }, size: function (a) {
            return (a || new THREE.Vector2).subVectors(this.max, this.min)
        }, expandByPoint: function (a) {
            this.min.min(a);
            this.max.max(a);
            return this
        }, expandByVector: function (a) {
            this.min.sub(a);
            this.max.add(a);
            return this
        }, expandByScalar: function (a) {
            this.min.addScalar(-a);
            this.max.addScalar(a);
            return this
        }, containsPoint: function (a) {
            return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y ? !1 : !0
        }, containsBox: function (a) {
            return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y ? !0 : !1
        }, getParameter: function (a, b) {
            return (b || new THREE.Vector2).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y))
        }, isIntersectionBox: function (a) {
            return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y >
            this.max.y ? !1 : !0
        }, clampPoint: function (a, b) {
            return (b || new THREE.Vector2).copy(a).clamp(this.min, this.max)
        }, distanceToPoint: function () {
            var a = new THREE.Vector2;
            return function (b) {
                return a.copy(b).clamp(this.min, this.max).sub(b).length()
            }
        }(), intersect: function (a) {
            this.min.max(a.min);
            this.max.min(a.max);
            return this
        }, union: function (a) {
            this.min.min(a.min);
            this.max.max(a.max);
            return this
        }, translate: function (a) {
            this.min.add(a);
            this.max.add(a);
            return this
        }, equals: function (a) {
            return a.min.equals(this.min) &&
                a.max.equals(this.max)
        }, clone: function () {
            return (new THREE.Box2).copy(this)
        }
    };
    THREE.Box3 = function (a, b) {
        this.min = void 0 !== a ? a : new THREE.Vector3(Infinity, Infinity, Infinity);
        this.max = void 0 !== b ? b : new THREE.Vector3(-Infinity, -Infinity, -Infinity)
    };
    THREE.Box3.prototype = {
        constructor: THREE.Box3, set: function (a, b) {
            this.min.copy(a);
            this.max.copy(b);
            return this
        }, setFromPoints: function (a) {
            this.makeEmpty();
            for (var b = 0, d = a.length; b < d; b++) this.expandByPoint(a[b]);
            return this
        }, setFromCenterAndSize: function () {
            var a = new THREE.Vector3;
            return function (b, d) {
                var e = a.copy(d).multiplyScalar(.5);
                this.min.copy(b).sub(e);
                this.max.copy(b).add(e);
                return this
            }
        }(), setFromObject: function () {
            var a = new THREE.Vector3;
            return function (b) {
                var d = this;
                b.updateMatrixWorld(!0);
                this.makeEmpty();
                b.traverse(function (b) {
                    var f = b.geometry;
                    if (void 0 !== f) if (f instanceof THREE.Geometry) for (var h = f.vertices, f = 0, g = h.length; f < g; f++) a.copy(h[f]), a.applyMatrix4(b.matrixWorld), d.expandByPoint(a); else if (f instanceof THREE.BufferGeometry && void 0 !== f.attributes.position) for (h = f.attributes.position.array, f = 0, g = h.length; f < g; f += 3) a.set(h[f], h[f + 1], h[f + 2]), a.applyMatrix4(b.matrixWorld), d.expandByPoint(a)
                });
                return this
            }
        }(), copy: function (a) {
            this.min.copy(a.min);
            this.max.copy(a.max);
            return this
        },
        makeEmpty: function () {
            this.min.x = this.min.y = this.min.z = Infinity;
            this.max.x = this.max.y = this.max.z = -Infinity;
            return this
        }, empty: function () {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        }, center: function (a) {
            return (a || new THREE.Vector3).addVectors(this.min, this.max).multiplyScalar(.5)
        }, size: function (a) {
            return (a || new THREE.Vector3).subVectors(this.max, this.min)
        }, expandByPoint: function (a) {
            this.min.min(a);
            this.max.max(a);
            return this
        }, expandByVector: function (a) {
            this.min.sub(a);
            this.max.add(a);
            return this
        }, expandByScalar: function (a) {
            this.min.addScalar(-a);
            this.max.addScalar(a);
            return this
        }, containsPoint: function (a) {
            return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z ? !1 : !0
        }, containsBox: function (a) {
            return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z ? !0 : !1
        }, getParameter: function (a, b) {
            return (b || new THREE.Vector3).set((a.x - this.min.x) / (this.max.x -
                this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z))
        }, isIntersectionBox: function (a) {
            return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z ? !1 : !0
        }, clampPoint: function (a, b) {
            return (b || new THREE.Vector3).copy(a).clamp(this.min, this.max)
        }, distanceToPoint: function () {
            var a = new THREE.Vector3;
            return function (b) {
                return a.copy(b).clamp(this.min, this.max).sub(b).length()
            }
        }(), getBoundingSphere: function () {
            var a =
                new THREE.Vector3;
            return function (b) {
                b = b || new THREE.Sphere;
                b.center = this.center();
                b.radius = .5 * this.size(a).length();
                return b
            }
        }(), intersect: function (a) {
            this.min.max(a.min);
            this.max.min(a.max);
            return this
        }, union: function (a) {
            this.min.min(a.min);
            this.max.max(a.max);
            return this
        }, applyMatrix4: function () {
            var a = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3];
            return function (b) {
                a[0].set(this.min.x, this.min.y,
                    this.min.z).applyMatrix4(b);
                a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b);
                a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b);
                a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b);
                a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b);
                a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b);
                a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b);
                a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b);
                this.makeEmpty();
                this.setFromPoints(a);
                return this
            }
        }(), translate: function (a) {
            this.min.add(a);
            this.max.add(a);
            return this
        }, equals: function (a) {
            return a.min.equals(this.min) && a.max.equals(this.max)
        }, clone: function () {
            return (new THREE.Box3).copy(this)
        }
    };
    THREE.Matrix3 = function () {
        this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
        0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    };
    THREE.Matrix3.prototype = {
        constructor: THREE.Matrix3, set: function (a, b, d, e, f, h, g, k, l) {
            var m = this.elements;
            m[0] = a;
            m[3] = b;
            m[6] = d;
            m[1] = e;
            m[4] = f;
            m[7] = h;
            m[2] = g;
            m[5] = k;
            m[8] = l;
            return this
        }, identity: function () {
            this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
            return this
        }, copy: function (a) {
            a = a.elements;
            this.set(a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]);
            return this
        }, multiplyVector3: function (a) {
            console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
            return a.applyMatrix3(this)
        },
        multiplyVector3Array: function (a) {
            console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.");
            return this.applyToVector3Array(a)
        }, applyToVector3Array: function () {
            var a = new THREE.Vector3;
            return function (b, d, e) {
                void 0 === d && (d = 0);
                void 0 === e && (e = b.length);
                for (var f = 0; f < e; f += 3, d += 3) a.x = b[d], a.y = b[d + 1], a.z = b[d + 2], a.applyMatrix3(this), b[d] = a.x, b[d + 1] = a.y, b[d + 2] = a.z;
                return b
            }
        }(), multiplyScalar: function (a) {
            var b = this.elements;
            b[0] *= a;
            b[3] *= a;
            b[6] *=
                a;
            b[1] *= a;
            b[4] *= a;
            b[7] *= a;
            b[2] *= a;
            b[5] *= a;
            b[8] *= a;
            return this
        }, determinant: function () {
            var a = this.elements, b = a[0], d = a[1], e = a[2], f = a[3], h = a[4], g = a[5], k = a[6], l = a[7],
                a = a[8];
            return b * h * a - b * g * l - d * f * a + d * g * k + e * f * l - e * h * k
        }, getInverse: function (a, b) {
            var d = a.elements, e = this.elements;
            e[0] = d[10] * d[5] - d[6] * d[9];
            e[1] = -d[10] * d[1] + d[2] * d[9];
            e[2] = d[6] * d[1] - d[2] * d[5];
            e[3] = -d[10] * d[4] + d[6] * d[8];
            e[4] = d[10] * d[0] - d[2] * d[8];
            e[5] = -d[6] * d[0] + d[2] * d[4];
            e[6] = d[9] * d[4] - d[5] * d[8];
            e[7] = -d[9] * d[0] + d[1] * d[8];
            e[8] = d[5] * d[0] - d[1] * d[4];
            d = d[0] * e[0] + d[1] * e[3] + d[2] * e[6];
            if (0 === d) {
                if (b) throw Error("Matrix3.getInverse(): can't invert matrix, determinant is 0");
                console.warn("Matrix3.getInverse(): can't invert matrix, determinant is 0");
                this.identity();
                return this
            }
            this.multiplyScalar(1 / d);
            return this
        }, transpose: function () {
            var a, b = this.elements;
            a = b[1];
            b[1] = b[3];
            b[3] = a;
            a = b[2];
            b[2] = b[6];
            b[6] = a;
            a = b[5];
            b[5] = b[7];
            b[7] = a;
            return this
        }, flattenToArrayOffset: function (a, b) {
            var d = this.elements;
            a[b] = d[0];
            a[b + 1] = d[1];
            a[b + 2] = d[2];
            a[b + 3] = d[3];
            a[b + 4] = d[4];
            a[b + 5] = d[5];
            a[b + 6] = d[6];
            a[b + 7] = d[7];
            a[b + 8] = d[8];
            return a
        }, getNormalMatrix: function (a) {
            this.getInverse(a).transpose();
            return this
        }, transposeIntoArray: function (a) {
            var b = this.elements;
            a[0] = b[0];
            a[1] = b[3];
            a[2] = b[6];
            a[3] = b[1];
            a[4] = b[4];
            a[5] = b[7];
            a[6] = b[2];
            a[7] = b[5];
            a[8] = b[8];
            return this
        }, fromArray: function (a) {
            this.elements.set(a);
            return this
        }, toArray: function () {
            var a = this.elements;
            return [a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]]
        }, clone: function () {
            return (new THREE.Matrix3).fromArray(this.elements)
        }
    };
    THREE.Matrix4 = function () {
        this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
        0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    };
    THREE.Matrix4.prototype = {
        constructor: THREE.Matrix4, set: function (a, b, d, e, f, h, g, k, l, m, n, q, p, r, v, u) {
            var x = this.elements;
            x[0] = a;
            x[4] = b;
            x[8] = d;
            x[12] = e;
            x[1] = f;
            x[5] = h;
            x[9] = g;
            x[13] = k;
            x[2] = l;
            x[6] = m;
            x[10] = n;
            x[14] = q;
            x[3] = p;
            x[7] = r;
            x[11] = v;
            x[15] = u;
            return this
        }, identity: function () {
            this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            return this
        }, copy: function (a) {
            this.elements.set(a.elements);
            return this
        }, extractPosition: function (a) {
            console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
            return this.copyPosition(a)
        },
        copyPosition: function (a) {
            var b = this.elements;
            a = a.elements;
            b[12] = a[12];
            b[13] = a[13];
            b[14] = a[14];
            return this
        }, extractRotation: function () {
            var a = new THREE.Vector3;
            return function (b) {
                var d = this.elements;
                b = b.elements;
                var e = 1 / a.set(b[0], b[1], b[2]).length(), f = 1 / a.set(b[4], b[5], b[6]).length(),
                    h = 1 / a.set(b[8], b[9], b[10]).length();
                d[0] = b[0] * e;
                d[1] = b[1] * e;
                d[2] = b[2] * e;
                d[4] = b[4] * f;
                d[5] = b[5] * f;
                d[6] = b[6] * f;
                d[8] = b[8] * h;
                d[9] = b[9] * h;
                d[10] = b[10] * h;
                return this
            }
        }(), makeRotationFromEuler: function (a) {
            !1 === a instanceof THREE.Euler &&
            console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var b = this.elements, d = a.x, e = a.y, f = a.z, h = Math.cos(d), d = Math.sin(d), g = Math.cos(e),
                e = Math.sin(e), k = Math.cos(f), f = Math.sin(f);
            if ("XYZ" === a.order) {
                a = h * k;
                var l = h * f, m = d * k, n = d * f;
                b[0] = g * k;
                b[4] = -g * f;
                b[8] = e;
                b[1] = l + m * e;
                b[5] = a - n * e;
                b[9] = -d * g;
                b[2] = n - a * e;
                b[6] = m + l * e;
                b[10] = h * g
            } else "YXZ" === a.order ? (a = g * k, l = g * f, m = e * k, n = e * f, b[0] = a + n * d, b[4] = m * d - l, b[8] = h * e, b[1] = h * f, b[5] = h * k, b[9] = -d, b[2] = l * d - m, b[6] = n + a * d,
                b[10] = h * g) : "ZXY" === a.order ? (a = g * k, l = g * f, m = e * k, n = e * f, b[0] = a - n * d, b[4] = -h * f, b[8] = m + l * d, b[1] = l + m * d, b[5] = h * k, b[9] = n - a * d, b[2] = -h * e, b[6] = d, b[10] = h * g) : "ZYX" === a.order ? (a = h * k, l = h * f, m = d * k, n = d * f, b[0] = g * k, b[4] = m * e - l, b[8] = a * e + n, b[1] = g * f, b[5] = n * e + a, b[9] = l * e - m, b[2] = -e, b[6] = d * g, b[10] = h * g) : "YZX" === a.order ? (a = h * g, l = h * e, m = d * g, n = d * e, b[0] = g * k, b[4] = n - a * f, b[8] = m * f + l, b[1] = f, b[5] = h * k, b[9] = -d * k, b[2] = -e * k, b[6] = l * f + m, b[10] = a - n * f) : "XZY" === a.order && (a = h * g, l = h * e, m = d * g, n = d * e, b[0] = g * k, b[4] = -f, b[8] = e * k, b[1] = a * f + n, b[5] = h * k, b[9] = l *
                f - m, b[2] = m * f - l, b[6] = d * k, b[10] = n * f + a);
            b[3] = 0;
            b[7] = 0;
            b[11] = 0;
            b[12] = 0;
            b[13] = 0;
            b[14] = 0;
            b[15] = 1;
            return this
        }, setRotationFromQuaternion: function (a) {
            console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
            return this.makeRotationFromQuaternion(a)
        }, makeRotationFromQuaternion: function (a) {
            var b = this.elements, d = a.x, e = a.y, f = a.z, h = a.w, g = d + d, k = e + e, l = f + f;
            a = d * g;
            var m = d * k, d = d * l, n = e * k, e = e * l, f = f * l, g = h * g, k = h * k, h = h * l;
            b[0] = 1 - (n + f);
            b[4] = m - h;
            b[8] = d + k;
            b[1] = m + h;
            b[5] = 1 -
                (a + f);
            b[9] = e - g;
            b[2] = d - k;
            b[6] = e + g;
            b[10] = 1 - (a + n);
            b[3] = 0;
            b[7] = 0;
            b[11] = 0;
            b[12] = 0;
            b[13] = 0;
            b[14] = 0;
            b[15] = 1;
            return this
        }, lookAt: function () {
            var a = new THREE.Vector3, b = new THREE.Vector3, d = new THREE.Vector3;
            return function (e, f, h) {
                var g = this.elements;
                d.subVectors(e, f).normalize();
                0 === d.length() && (d.z = 1);
                a.crossVectors(h, d).normalize();
                0 === a.length() && (d.x += 1E-4, a.crossVectors(h, d).normalize());
                b.crossVectors(d, a);
                g[0] = a.x;
                g[4] = b.x;
                g[8] = d.x;
                g[1] = a.y;
                g[5] = b.y;
                g[9] = d.y;
                g[2] = a.z;
                g[6] = b.z;
                g[10] = d.z;
                return this
            }
        }(),
        multiply: function (a, b) {
            return void 0 !== b ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a)
        }, multiplyMatrices: function (a, b) {
            var d = a.elements, e = b.elements, f = this.elements, h = d[0], g = d[4], k = d[8], l = d[12], m = d[1],
                n = d[5], q = d[9], p = d[13], r = d[2], v = d[6], u = d[10], x = d[14], w = d[3], z = d[7], F = d[11],
                d = d[15], B = e[0], H = e[4], E = e[8], I = e[12], A = e[1], N = e[5], G = e[9], D = e[13], Y = e[2],
                C = e[6], K = e[10], J = e[14], L = e[3],
                U = e[7], aa = e[11], e = e[15];
            f[0] = h * B + g * A + k * Y + l * L;
            f[4] = h * H + g * N + k * C + l * U;
            f[8] = h * E + g * G + k * K + l * aa;
            f[12] = h * I + g * D + k * J + l * e;
            f[1] = m * B + n * A + q * Y + p * L;
            f[5] = m * H + n * N + q * C + p * U;
            f[9] = m * E + n * G + q * K + p * aa;
            f[13] = m * I + n * D + q * J + p * e;
            f[2] = r * B + v * A + u * Y + x * L;
            f[6] = r * H + v * N + u * C + x * U;
            f[10] = r * E + v * G + u * K + x * aa;
            f[14] = r * I + v * D + u * J + x * e;
            f[3] = w * B + z * A + F * Y + d * L;
            f[7] = w * H + z * N + F * C + d * U;
            f[11] = w * E + z * G + F * K + d * aa;
            f[15] = w * I + z * D + F * J + d * e;
            return this
        }, multiplyToArray: function (a, b, d) {
            var e = this.elements;
            this.multiplyMatrices(a, b);
            d[0] = e[0];
            d[1] = e[1];
            d[2] = e[2];
            d[3] = e[3];
            d[4] = e[4];
            d[5] = e[5];
            d[6] = e[6];
            d[7] = e[7];
            d[8] = e[8];
            d[9] = e[9];
            d[10] = e[10];
            d[11] = e[11];
            d[12] = e[12];
            d[13] = e[13];
            d[14] = e[14];
            d[15] = e[15];
            return this
        }, multiplyScalar: function (a) {
            var b = this.elements;
            b[0] *= a;
            b[4] *= a;
            b[8] *= a;
            b[12] *= a;
            b[1] *= a;
            b[5] *= a;
            b[9] *= a;
            b[13] *= a;
            b[2] *= a;
            b[6] *= a;
            b[10] *= a;
            b[14] *= a;
            b[3] *= a;
            b[7] *= a;
            b[11] *= a;
            b[15] *= a;
            return this
        }, multiplyVector3: function (a) {
            console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.");
            return a.applyProjection(this)
        }, multiplyVector4: function (a) {
            console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
            return a.applyMatrix4(this)
        }, multiplyVector3Array: function (a) {
            console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.");
            return this.applyToVector3Array(a)
        }, applyToVector3Array: function () {
            var a = new THREE.Vector3;
            return function (b, d, e) {
                void 0 === d && (d = 0);
                void 0 === e && (e =
                    b.length);
                for (var f = 0; f < e; f += 3, d += 3) a.x = b[d], a.y = b[d + 1], a.z = b[d + 2], a.applyMatrix4(this), b[d] = a.x, b[d + 1] = a.y, b[d + 2] = a.z;
                return b
            }
        }(), rotateAxis: function (a) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
            a.transformDirection(this)
        }, crossVector: function (a) {
            console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
            return a.applyMatrix4(this)
        }, determinant: function () {
            var a = this.elements, b =
                    a[0], d = a[4], e = a[8], f = a[12], h = a[1], g = a[5], k = a[9], l = a[13], m = a[2], n = a[6],
                q = a[10], p = a[14];
            return a[3] * (+f * k * n - e * l * n - f * g * q + d * l * q + e * g * p - d * k * p) + a[7] * (+b * k * p - b * l * q + f * h * q - e * h * p + e * l * m - f * k * m) + a[11] * (+b * l * n - b * g * p - f * h * n + d * h * p + f * g * m - d * l * m) + a[15] * (-e * g * m - b * k * n + b * g * q + e * h * n - d * h * q + d * k * m)
        }, transpose: function () {
            var a = this.elements, b;
            b = a[1];
            a[1] = a[4];
            a[4] = b;
            b = a[2];
            a[2] = a[8];
            a[8] = b;
            b = a[6];
            a[6] = a[9];
            a[9] = b;
            b = a[3];
            a[3] = a[12];
            a[12] = b;
            b = a[7];
            a[7] = a[13];
            a[13] = b;
            b = a[11];
            a[11] = a[14];
            a[14] = b;
            return this
        }, flattenToArrayOffset: function (a,
                                           b) {
            var d = this.elements;
            a[b] = d[0];
            a[b + 1] = d[1];
            a[b + 2] = d[2];
            a[b + 3] = d[3];
            a[b + 4] = d[4];
            a[b + 5] = d[5];
            a[b + 6] = d[6];
            a[b + 7] = d[7];
            a[b + 8] = d[8];
            a[b + 9] = d[9];
            a[b + 10] = d[10];
            a[b + 11] = d[11];
            a[b + 12] = d[12];
            a[b + 13] = d[13];
            a[b + 14] = d[14];
            a[b + 15] = d[15];
            return a
        }, getPosition: function () {
            var a = new THREE.Vector3;
            return function () {
                console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
                var b = this.elements;
                return a.set(b[12], b[13], b[14])
            }
        }(), setPosition: function (a) {
            var b =
                this.elements;
            b[12] = a.x;
            b[13] = a.y;
            b[14] = a.z;
            return this
        }, getInverse: function (a, b) {
            var d = this.elements, e = a.elements, f = e[0], h = e[4], g = e[8], k = e[12], l = e[1], m = e[5],
                n = e[9], q = e[13], p = e[2], r = e[6], v = e[10], u = e[14], x = e[3], w = e[7], z = e[11], e = e[15];
            d[0] = n * u * w - q * v * w + q * r * z - m * u * z - n * r * e + m * v * e;
            d[4] = k * v * w - g * u * w - k * r * z + h * u * z + g * r * e - h * v * e;
            d[8] = g * q * w - k * n * w + k * m * z - h * q * z - g * m * e + h * n * e;
            d[12] = k * n * r - g * q * r - k * m * v + h * q * v + g * m * u - h * n * u;
            d[1] = q * v * x - n * u * x - q * p * z + l * u * z + n * p * e - l * v * e;
            d[5] = g * u * x - k * v * x + k * p * z - f * u * z - g * p * e + f * v * e;
            d[9] = k * n * x - g * q * x - k * l *
                z + f * q * z + g * l * e - f * n * e;
            d[13] = g * q * p - k * n * p + k * l * v - f * q * v - g * l * u + f * n * u;
            d[2] = m * u * x - q * r * x + q * p * w - l * u * w - m * p * e + l * r * e;
            d[6] = k * r * x - h * u * x - k * p * w + f * u * w + h * p * e - f * r * e;
            d[10] = h * q * x - k * m * x + k * l * w - f * q * w - h * l * e + f * m * e;
            d[14] = k * m * p - h * q * p - k * l * r + f * q * r + h * l * u - f * m * u;
            d[3] = n * r * x - m * v * x - n * p * w + l * v * w + m * p * z - l * r * z;
            d[7] = h * v * x - g * r * x + g * p * w - f * v * w - h * p * z + f * r * z;
            d[11] = g * m * x - h * n * x - g * l * w + f * n * w + h * l * z - f * m * z;
            d[15] = h * n * p - g * m * p + g * l * r - f * n * r - h * l * v + f * m * v;
            d = f * d[0] + l * d[4] + p * d[8] + x * d[12];
            if (0 == d) {
                if (b) throw Error("Matrix4.getInverse(): can't invert matrix, determinant is 0");
                console.warn("Matrix4.getInverse(): can't invert matrix, determinant is 0");
                this.identity();
                return this
            }
            this.multiplyScalar(1 / d);
            return this
        }, translate: function (a) {
            console.warn("THREE.Matrix4: .translate() has been removed.")
        }, rotateX: function (a) {
            console.warn("THREE.Matrix4: .rotateX() has been removed.")
        }, rotateY: function (a) {
            console.warn("THREE.Matrix4: .rotateY() has been removed.")
        }, rotateZ: function (a) {
            console.warn("THREE.Matrix4: .rotateZ() has been removed.")
        }, rotateByAxis: function (a, b) {
            console.warn("THREE.Matrix4: .rotateByAxis() has been removed.")
        },
        scale: function (a) {
            var b = this.elements, d = a.x, e = a.y;
            a = a.z;
            b[0] *= d;
            b[4] *= e;
            b[8] *= a;
            b[1] *= d;
            b[5] *= e;
            b[9] *= a;
            b[2] *= d;
            b[6] *= e;
            b[10] *= a;
            b[3] *= d;
            b[7] *= e;
            b[11] *= a;
            return this
        }, getMaxScaleOnAxis: function () {
            var a = this.elements;
            return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], Math.max(a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10])))
        }, makeTranslation: function (a, b, d) {
            this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, d, 0, 0, 0, 1);
            return this
        }, makeRotationX: function (a) {
            var b = Math.cos(a);
            a = Math.sin(a);
            this.set(1,
                0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1);
            return this
        }, makeRotationY: function (a) {
            var b = Math.cos(a);
            a = Math.sin(a);
            this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1);
            return this
        }, makeRotationZ: function (a) {
            var b = Math.cos(a);
            a = Math.sin(a);
            this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            return this
        }, makeRotationAxis: function (a, b) {
            var d = Math.cos(b), e = Math.sin(b), f = 1 - d, h = a.x, g = a.y, k = a.z, l = f * h, m = f * g;
            this.set(l * h + d, l * g - e * k, l * k + e * g, 0, l * g + e * k, m * g + d, m * k - e * h, 0, l * k - e * g, m * k + e * h, f * k * k + d, 0, 0, 0, 0, 1);
            return this
        }, makeScale: function (a, b, d) {
            this.set(a,
                0, 0, 0, 0, b, 0, 0, 0, 0, d, 0, 0, 0, 0, 1);
            return this
        }, compose: function (a, b, d) {
            this.makeRotationFromQuaternion(b);
            this.scale(d);
            this.setPosition(a);
            return this
        }, decompose: function () {
            var a = new THREE.Vector3, b = new THREE.Matrix4;
            return function (d, e, f) {
                var h = this.elements, g = a.set(h[0], h[1], h[2]).length(), k = a.set(h[4], h[5], h[6]).length(),
                    l = a.set(h[8], h[9], h[10]).length();
                0 > this.determinant() && (g = -g);
                d.x = h[12];
                d.y = h[13];
                d.z = h[14];
                b.elements.set(this.elements);
                d = 1 / g;
                var h = 1 / k, m = 1 / l, n = b.elements;
                n[0] *= d;
                n[1] *= d;
                n[2] *=
                    d;
                n[4] *= h;
                n[5] *= h;
                n[6] *= h;
                n[8] *= m;
                n[9] *= m;
                n[10] *= m;
                e.setFromRotationMatrix(b);
                f.x = g;
                f.y = k;
                f.z = l;
                return this
            }
        }(), makeFrustum: function (a, b, d, e, f, h) {
            var g = this.elements;
            g[0] = 2 * f / (b - a);
            g[4] = 0;
            g[8] = (b + a) / (b - a);
            g[12] = 0;
            g[1] = 0;
            g[5] = 2 * f / (e - d);
            g[9] = (e + d) / (e - d);
            g[13] = 0;
            g[2] = 0;
            g[6] = 0;
            g[10] = -(h + f) / (h - f);
            g[14] = -2 * h * f / (h - f);
            g[3] = 0;
            g[7] = 0;
            g[11] = -1;
            g[15] = 0;
            return this
        }, makePerspective: function (a, b, d, e) {
            a = d * Math.tan(THREE.Math.degToRad(.5 * a));
            var f = -a;
            return this.makeFrustum(f * b, a * b, f, a, d, e)
        }, makeOrthographic: function (a,
                                       b, d, e, f, h) {
            var g = this.elements, k = b - a, l = d - e, m = h - f;
            g[0] = 2 / k;
            g[4] = 0;
            g[8] = 0;
            g[12] = -((b + a) / k);
            g[1] = 0;
            g[5] = 2 / l;
            g[9] = 0;
            g[13] = -((d + e) / l);
            g[2] = 0;
            g[6] = 0;
            g[10] = -2 / m;
            g[14] = -((h + f) / m);
            g[3] = 0;
            g[7] = 0;
            g[11] = 0;
            g[15] = 1;
            return this
        }, fromArray: function (a) {
            this.elements.set(a);
            return this
        }, toArray: function () {
            var a = this.elements;
            return [a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]]
        }, clone: function () {
            return (new THREE.Matrix4).fromArray(this.elements)
        }
    };
    THREE.Ray = function (a, b) {
        this.origin = void 0 !== a ? a : new THREE.Vector3;
        this.direction = void 0 !== b ? b : new THREE.Vector3
    };
    THREE.Ray.prototype = {
        constructor: THREE.Ray, set: function (a, b) {
            this.origin.copy(a);
            this.direction.copy(b);
            return this
        }, copy: function (a) {
            this.origin.copy(a.origin);
            this.direction.copy(a.direction);
            return this
        }, at: function (a, b) {
            return (b || new THREE.Vector3).copy(this.direction).multiplyScalar(a).add(this.origin)
        }, recast: function () {
            var a = new THREE.Vector3;
            return function (b) {
                this.origin.copy(this.at(b, a));
                return this
            }
        }(), closestPointToPoint: function (a, b) {
            var d = b || new THREE.Vector3;
            d.subVectors(a, this.origin);
            var e = d.dot(this.direction);
            return 0 > e ? d.copy(this.origin) : d.copy(this.direction).multiplyScalar(e).add(this.origin)
        }, distanceToPoint: function () {
            var a = new THREE.Vector3;
            return function (b) {
                var d = a.subVectors(b, this.origin).dot(this.direction);
                if (0 > d) return this.origin.distanceTo(b);
                a.copy(this.direction).multiplyScalar(d).add(this.origin);
                return a.distanceTo(b)
            }
        }(), distanceSqToSegment: function (a, b, d, e) {
            var f = a.clone().add(b).multiplyScalar(.5), h = b.clone().sub(a).normalize(), g = .5 * a.distanceTo(b), k =
                this.origin.clone().sub(f);
            a = -this.direction.dot(h);
            b = k.dot(this.direction);
            var l = -k.dot(h), m = k.lengthSq(), n = Math.abs(1 - a * a), q, p;
            0 <= n ? (k = a * l - b, q = a * b - l, p = g * n, 0 <= k ? q >= -p ? q <= p ? (g = 1 / n, k *= g, q *= g, a = k * (k + a * q + 2 * b) + q * (a * k + q + 2 * l) + m) : (q = g, k = Math.max(0, -(a * q + b)), a = -k * k + q * (q + 2 * l) + m) : (q = -g, k = Math.max(0, -(a * q + b)), a = -k * k + q * (q + 2 * l) + m) : q <= -p ? (k = Math.max(0, -(-a * g + b)), q = 0 < k ? -g : Math.min(Math.max(-g, -l), g), a = -k * k + q * (q + 2 * l) + m) : q <= p ? (k = 0, q = Math.min(Math.max(-g, -l), g), a = q * (q + 2 * l) + m) : (k = Math.max(0, -(a * g + b)), q = 0 < k ? g : Math.min(Math.max(-g,
                -l), g), a = -k * k + q * (q + 2 * l) + m)) : (q = 0 < a ? -g : g, k = Math.max(0, -(a * q + b)), a = -k * k + q * (q + 2 * l) + m);
            d && d.copy(this.direction.clone().multiplyScalar(k).add(this.origin));
            e && e.copy(h.clone().multiplyScalar(q).add(f));
            return a
        }, isIntersectionSphere: function (a) {
            return this.distanceToPoint(a.center) <= a.radius
        }, intersectSphere: function () {
            var a = new THREE.Vector3;
            return function (b, d) {
                a.subVectors(b.center, this.origin);
                var e = a.dot(this.direction), f = a.dot(a) - e * e, h = b.radius * b.radius;
                if (f > h) return null;
                h = Math.sqrt(h - f);
                f = e - h;
                e += h;
                return 0 > f && 0 > e ? null : 0 > f ? this.at(e, d) : this.at(f, d)
            }
        }(), isIntersectionPlane: function (a) {
            var b = a.distanceToPoint(this.origin);
            return 0 === b || 0 > a.normal.dot(this.direction) * b ? !0 : !1
        }, distanceToPlane: function (a) {
            var b = a.normal.dot(this.direction);
            if (0 == b) return 0 == a.distanceToPoint(this.origin) ? 0 : null;
            a = -(this.origin.dot(a.normal) + a.constant) / b;
            return 0 <= a ? a : null
        }, intersectPlane: function (a, b) {
            var d = this.distanceToPlane(a);
            return null === d ? null : this.at(d, b)
        }, isIntersectionBox: function () {
            var a = new THREE.Vector3;
            return function (b) {
                return null !== this.intersectBox(b, a)
            }
        }(), intersectBox: function (a, b) {
            var d, e, f, h, g;
            e = 1 / this.direction.x;
            h = 1 / this.direction.y;
            g = 1 / this.direction.z;
            var k = this.origin;
            0 <= e ? (d = (a.min.x - k.x) * e, e *= a.max.x - k.x) : (d = (a.max.x - k.x) * e, e *= a.min.x - k.x);
            0 <= h ? (f = (a.min.y - k.y) * h, h *= a.max.y - k.y) : (f = (a.max.y - k.y) * h, h *= a.min.y - k.y);
            if (d > h || f > e) return null;
            if (f > d || d !== d) d = f;
            if (h < e || e !== e) e = h;
            0 <= g ? (f = (a.min.z - k.z) * g, g *= a.max.z - k.z) : (f = (a.max.z - k.z) * g, g *= a.min.z - k.z);
            if (d > g || f > e) return null;
            if (f > d || d !==
                d) d = f;
            if (g < e || e !== e) e = g;
            return 0 > e ? null : this.at(0 <= d ? d : e, b)
        }, intersectTriangle: function () {
            var a = new THREE.Vector3, b = new THREE.Vector3, d = new THREE.Vector3, e = new THREE.Vector3;
            return function (f, h, g, k, l) {
                b.subVectors(h, f);
                d.subVectors(g, f);
                e.crossVectors(b, d);
                h = this.direction.dot(e);
                if (0 < h) {
                    if (k) return null;
                    k = 1
                } else if (0 > h) k = -1, h = -h; else return null;
                a.subVectors(this.origin, f);
                f = k * this.direction.dot(d.crossVectors(a, d));
                if (0 > f) return null;
                g = k * this.direction.dot(b.cross(a));
                if (0 > g || f + g > h) return null;
                f = -k * a.dot(e);
                return 0 > f ? null : this.at(f / h, l)
            }
        }(), applyMatrix4: function (a) {
            this.direction.add(this.origin).applyMatrix4(a);
            this.origin.applyMatrix4(a);
            this.direction.sub(this.origin);
            this.direction.normalize();
            return this
        }, equals: function (a) {
            return a.origin.equals(this.origin) && a.direction.equals(this.direction)
        }, clone: function () {
            return (new THREE.Ray).copy(this)
        }
    };
    THREE.Sphere = function (a, b) {
        this.center = void 0 !== a ? a : new THREE.Vector3;
        this.radius = void 0 !== b ? b : 0
    };
    THREE.Sphere.prototype = {
        constructor: THREE.Sphere, set: function (a, b) {
            this.center.copy(a);
            this.radius = b;
            return this
        }, setFromPoints: function () {
            var a = new THREE.Box3;
            return function (b, d) {
                var e = this.center;
                void 0 !== d ? e.copy(d) : a.setFromPoints(b).center(e);
                for (var f = 0, h = 0, g = b.length; h < g; h++) f = Math.max(f, e.distanceToSquared(b[h]));
                this.radius = Math.sqrt(f);
                return this
            }
        }(), copy: function (a) {
            this.center.copy(a.center);
            this.radius = a.radius;
            return this
        }, empty: function () {
            return 0 >= this.radius
        }, containsPoint: function (a) {
            return a.distanceToSquared(this.center) <=
                this.radius * this.radius
        }, distanceToPoint: function (a) {
            return a.distanceTo(this.center) - this.radius
        }, intersectsSphere: function (a) {
            var b = this.radius + a.radius;
            return a.center.distanceToSquared(this.center) <= b * b
        }, clampPoint: function (a, b) {
            var d = this.center.distanceToSquared(a), e = b || new THREE.Vector3;
            e.copy(a);
            d > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center));
            return e
        }, getBoundingBox: function (a) {
            a = a || new THREE.Box3;
            a.set(this.center, this.center);
            a.expandByScalar(this.radius);
            return a
        }, applyMatrix4: function (a) {
            this.center.applyMatrix4(a);
            this.radius *= a.getMaxScaleOnAxis();
            return this
        }, translate: function (a) {
            this.center.add(a);
            return this
        }, equals: function (a) {
            return a.center.equals(this.center) && a.radius === this.radius
        }, clone: function () {
            return (new THREE.Sphere).copy(this)
        }
    };
    THREE.Frustum = function (a, b, d, e, f, h) {
        this.planes = [void 0 !== a ? a : new THREE.Plane, void 0 !== b ? b : new THREE.Plane, void 0 !== d ? d : new THREE.Plane, void 0 !== e ? e : new THREE.Plane, void 0 !== f ? f : new THREE.Plane, void 0 !== h ? h : new THREE.Plane]
    };
    THREE.Frustum.prototype = {
        constructor: THREE.Frustum, set: function (a, b, d, e, f, h) {
            var g = this.planes;
            g[0].copy(a);
            g[1].copy(b);
            g[2].copy(d);
            g[3].copy(e);
            g[4].copy(f);
            g[5].copy(h);
            return this
        }, copy: function (a) {
            for (var b = this.planes, d = 0; 6 > d; d++) b[d].copy(a.planes[d]);
            return this
        }, setFromMatrix: function (a) {
            var b = this.planes, d = a.elements;
            a = d[0];
            var e = d[1], f = d[2], h = d[3], g = d[4], k = d[5], l = d[6], m = d[7], n = d[8], q = d[9], p = d[10],
                r = d[11], v = d[12], u = d[13], x = d[14], d = d[15];
            b[0].setComponents(h - a, m - g, r - n, d - v).normalize();
            b[1].setComponents(h +
                a, m + g, r + n, d + v).normalize();
            b[2].setComponents(h + e, m + k, r + q, d + u).normalize();
            b[3].setComponents(h - e, m - k, r - q, d - u).normalize();
            b[4].setComponents(h - f, m - l, r - p, d - x).normalize();
            b[5].setComponents(h + f, m + l, r + p, d + x).normalize();
            return this
        }, intersectsObject: function () {
            var a = new THREE.Sphere;
            return function (b) {
                var d = b.geometry;
                null === d.boundingSphere && d.computeBoundingSphere();
                a.copy(d.boundingSphere);
                a.applyMatrix4(b.matrixWorld);
                return this.intersectsSphere(a)
            }
        }(), intersectsSphere: function (a) {
            var b = this.planes,
                d = a.center;
            a = -a.radius;
            for (var e = 0; 6 > e; e++) if (b[e].distanceToPoint(d) < a) return !1;
            return !0
        }, intersectsBox: function () {
            var a = new THREE.Vector3, b = new THREE.Vector3;
            return function (d) {
                for (var e = this.planes, f = 0; 6 > f; f++) {
                    var h = e[f];
                    a.x = 0 < h.normal.x ? d.min.x : d.max.x;
                    b.x = 0 < h.normal.x ? d.max.x : d.min.x;
                    a.y = 0 < h.normal.y ? d.min.y : d.max.y;
                    b.y = 0 < h.normal.y ? d.max.y : d.min.y;
                    a.z = 0 < h.normal.z ? d.min.z : d.max.z;
                    b.z = 0 < h.normal.z ? d.max.z : d.min.z;
                    var g = h.distanceToPoint(a), h = h.distanceToPoint(b);
                    if (0 > g && 0 > h) return !1
                }
                return !0
            }
        }(),
        containsPoint: function (a) {
            for (var b = this.planes, d = 0; 6 > d; d++) if (0 > b[d].distanceToPoint(a)) return !1;
            return !0
        }, clone: function () {
            return (new THREE.Frustum).copy(this)
        }
    };
    THREE.Plane = function (a, b) {
        this.normal = void 0 !== a ? a : new THREE.Vector3(1, 0, 0);
        this.constant = void 0 !== b ? b : 0
    };
    THREE.Plane.prototype = {
        constructor: THREE.Plane, set: function (a, b) {
            this.normal.copy(a);
            this.constant = b;
            return this
        }, setComponents: function (a, b, d, e) {
            this.normal.set(a, b, d);
            this.constant = e;
            return this
        }, setFromNormalAndCoplanarPoint: function (a, b) {
            this.normal.copy(a);
            this.constant = -b.dot(this.normal);
            return this
        }, setFromCoplanarPoints: function () {
            var a = new THREE.Vector3, b = new THREE.Vector3;
            return function (d, e, f) {
                e = a.subVectors(f, e).cross(b.subVectors(d, e)).normalize();
                this.setFromNormalAndCoplanarPoint(e,
                    d);
                return this
            }
        }(), copy: function (a) {
            this.normal.copy(a.normal);
            this.constant = a.constant;
            return this
        }, normalize: function () {
            var a = 1 / this.normal.length();
            this.normal.multiplyScalar(a);
            this.constant *= a;
            return this
        }, negate: function () {
            this.constant *= -1;
            this.normal.negate();
            return this
        }, distanceToPoint: function (a) {
            return this.normal.dot(a) + this.constant
        }, distanceToSphere: function (a) {
            return this.distanceToPoint(a.center) - a.radius
        }, projectPoint: function (a, b) {
            return this.orthoPoint(a, b).sub(a).negate()
        }, orthoPoint: function (a,
                                 b) {
            var d = this.distanceToPoint(a);
            return (b || new THREE.Vector3).copy(this.normal).multiplyScalar(d)
        }, isIntersectionLine: function (a) {
            var b = this.distanceToPoint(a.start);
            a = this.distanceToPoint(a.end);
            return 0 > b && 0 < a || 0 > a && 0 < b
        }, intersectLine: function () {
            var a = new THREE.Vector3;
            return function (b, d) {
                var e = d || new THREE.Vector3, f = b.delta(a), h = this.normal.dot(f);
                if (0 == h) {
                    if (0 == this.distanceToPoint(b.start)) return e.copy(b.start)
                } else return h = -(b.start.dot(this.normal) + this.constant) / h, 0 > h || 1 < h ? void 0 : e.copy(f).multiplyScalar(h).add(b.start)
            }
        }(),
        coplanarPoint: function (a) {
            return (a || new THREE.Vector3).copy(this.normal).multiplyScalar(-this.constant)
        }, applyMatrix4: function () {
            var a = new THREE.Vector3, b = new THREE.Vector3, d = new THREE.Matrix3;
            return function (e, f) {
                var h = f || d.getNormalMatrix(e), h = a.copy(this.normal).applyMatrix3(h), g = this.coplanarPoint(b);
                g.applyMatrix4(e);
                this.setFromNormalAndCoplanarPoint(h, g);
                return this
            }
        }(), translate: function (a) {
            this.constant -= a.dot(this.normal);
            return this
        }, equals: function (a) {
            return a.normal.equals(this.normal) &&
                a.constant == this.constant
        }, clone: function () {
            return (new THREE.Plane).copy(this)
        }
    };
    THREE.Math = {
        generateUUID: function () {
            var a = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), b = Array(36), d = 0, e;
            return function () {
                for (var f = 0; 36 > f; f++) 8 == f || 13 == f || 18 == f || 23 == f ? b[f] = "-" : 14 == f ? b[f] = "4" : (2 >= d && (d = 33554432 + 16777216 * Math.random() | 0), e = d & 15, d >>= 4, b[f] = a[19 == f ? e & 3 | 8 : e]);
                return b.join("")
            }
        }(), clamp: function (a, b, d) {
            return a < b ? b : a > d ? d : a
        }, clampBottom: function (a, b) {
            return a < b ? b : a
        }, mapLinear: function (a, b, d, e, f) {
            return e + (a - b) * (f - e) / (d - b)
        }, smoothstep: function (a, b, d) {
            if (a <=
                b) return 0;
            if (a >= d) return 1;
            a = (a - b) / (d - b);
            return a * a * (3 - 2 * a)
        }, smootherstep: function (a, b, d) {
            if (a <= b) return 0;
            if (a >= d) return 1;
            a = (a - b) / (d - b);
            return a * a * a * (a * (6 * a - 15) + 10)
        }, random16: function () {
            return (65280 * Math.random() + 255 * Math.random()) / 65535
        }, randInt: function (a, b) {
            return a + Math.floor(Math.random() * (b - a + 1))
        }, randFloat: function (a, b) {
            return a + Math.random() * (b - a)
        }, randFloatSpread: function (a) {
            return a * (.5 - Math.random())
        }, degToRad: function () {
            var a = Math.PI / 180;
            return function (b) {
                return b * a
            }
        }(), radToDeg: function () {
            var a =
                180 / Math.PI;
            return function (b) {
                return b * a
            }
        }(), isPowerOfTwo: function (a) {
            return 0 === (a & a - 1) && 0 !== a
        }
    };
    THREE.Spline = function (a) {
        function b(a, b, d, e, g, h, f) {
            a = .5 * (d - a);
            e = .5 * (e - b);
            return (2 * (b - d) + a + e) * f + (-3 * (b - d) - 2 * a - e) * h + a * g + b
        }

        this.points = a;
        var d = [], e = {x: 0, y: 0, z: 0}, f, h, g, k, l, m, n, q, p;
        this.initFromArray = function (a) {
            this.points = [];
            for (var b = 0; b < a.length; b++) this.points[b] = {x: a[b][0], y: a[b][1], z: a[b][2]}
        };
        this.getPoint = function (a) {
            f = (this.points.length - 1) * a;
            h = Math.floor(f);
            g = f - h;
            d[0] = 0 === h ? h : h - 1;
            d[1] = h;
            d[2] = h > this.points.length - 2 ? this.points.length - 1 : h + 1;
            d[3] = h > this.points.length - 3 ? this.points.length - 1 : h +
                2;
            m = this.points[d[0]];
            n = this.points[d[1]];
            q = this.points[d[2]];
            p = this.points[d[3]];
            k = g * g;
            l = g * k;
            e.x = b(m.x, n.x, q.x, p.x, g, k, l);
            e.y = b(m.y, n.y, q.y, p.y, g, k, l);
            e.z = b(m.z, n.z, q.z, p.z, g, k, l);
            return e
        };
        this.getControlPointsArray = function () {
            var a, b, d = this.points.length, e = [];
            for (a = 0; a < d; a++) b = this.points[a], e[a] = [b.x, b.y, b.z];
            return e
        };
        this.getLength = function (a) {
            var b, d, e, g = b = b = 0, h = new THREE.Vector3, f = new THREE.Vector3, k = [], l = 0;
            k[0] = 0;
            a || (a = 100);
            d = this.points.length * a;
            h.copy(this.points[0]);
            for (a = 1; a < d; a++) b =
                a / d, e = this.getPoint(b), f.copy(e), l += f.distanceTo(h), h.copy(e), b *= this.points.length - 1, b = Math.floor(b), b != g && (k[b] = l, g = b);
            k[k.length] = l;
            return {chunks: k, total: l}
        };
        this.reparametrizeByArcLength = function (a) {
            var b, d, e, g, h, f, k = [], l = new THREE.Vector3, m = this.getLength();
            k.push(l.copy(this.points[0]).clone());
            for (b = 1; b < this.points.length; b++) {
                d = m.chunks[b] - m.chunks[b - 1];
                f = Math.ceil(a * d / m.total);
                g = (b - 1) / (this.points.length - 1);
                h = b / (this.points.length - 1);
                for (d = 1; d < f - 1; d++) e = g + 1 / f * d * (h - g), e = this.getPoint(e), k.push(l.copy(e).clone());
                k.push(l.copy(this.points[b]).clone())
            }
            this.points = k
        }
    };
    THREE.Triangle = function (a, b, d) {
        this.a = void 0 !== a ? a : new THREE.Vector3;
        this.b = void 0 !== b ? b : new THREE.Vector3;
        this.c = void 0 !== d ? d : new THREE.Vector3
    };
    THREE.Triangle.normal = function () {
        var a = new THREE.Vector3;
        return function (b, d, e, f) {
            f = f || new THREE.Vector3;
            f.subVectors(e, d);
            a.subVectors(b, d);
            f.cross(a);
            b = f.lengthSq();
            return 0 < b ? f.multiplyScalar(1 / Math.sqrt(b)) : f.set(0, 0, 0)
        }
    }();
    THREE.Triangle.barycoordFromPoint = function () {
        var a = new THREE.Vector3, b = new THREE.Vector3, d = new THREE.Vector3;
        return function (e, f, h, g, k) {
            a.subVectors(g, f);
            b.subVectors(h, f);
            d.subVectors(e, f);
            e = a.dot(a);
            f = a.dot(b);
            h = a.dot(d);
            var l = b.dot(b);
            g = b.dot(d);
            var m = e * l - f * f;
            k = k || new THREE.Vector3;
            if (0 == m) return k.set(-2, -1, -1);
            m = 1 / m;
            l = (l * h - f * g) * m;
            e = (e * g - f * h) * m;
            return k.set(1 - l - e, e, l)
        }
    }();
    THREE.Triangle.containsPoint = function () {
        var a = new THREE.Vector3;
        return function (b, d, e, f) {
            b = THREE.Triangle.barycoordFromPoint(b, d, e, f, a);
            return 0 <= b.x && 0 <= b.y && 1 >= b.x + b.y
        }
    }();
    THREE.Triangle.prototype = {
        constructor: THREE.Triangle, set: function (a, b, d) {
            this.a.copy(a);
            this.b.copy(b);
            this.c.copy(d);
            return this
        }, setFromPointsAndIndices: function (a, b, d, e) {
            this.a.copy(a[b]);
            this.b.copy(a[d]);
            this.c.copy(a[e]);
            return this
        }, copy: function (a) {
            this.a.copy(a.a);
            this.b.copy(a.b);
            this.c.copy(a.c);
            return this
        }, area: function () {
            var a = new THREE.Vector3, b = new THREE.Vector3;
            return function () {
                a.subVectors(this.c, this.b);
                b.subVectors(this.a, this.b);
                return .5 * a.cross(b).length()
            }
        }(), midpoint: function (a) {
            return (a ||
                new THREE.Vector3).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        }, normal: function (a) {
            return THREE.Triangle.normal(this.a, this.b, this.c, a)
        }, plane: function (a) {
            return (a || new THREE.Plane).setFromCoplanarPoints(this.a, this.b, this.c)
        }, barycoordFromPoint: function (a, b) {
            return THREE.Triangle.barycoordFromPoint(a, this.a, this.b, this.c, b)
        }, containsPoint: function (a) {
            return THREE.Triangle.containsPoint(a, this.a, this.b, this.c)
        }, equals: function (a) {
            return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c)
        },
        clone: function () {
            return (new THREE.Triangle).copy(this)
        }
    };
    THREE.Clock = function (a) {
        this.autoStart = void 0 !== a ? a : !0;
        this.elapsedTime = this.oldTime = this.startTime = 0;
        this.running = !1
    };
    THREE.Clock.prototype = {
        constructor: THREE.Clock, start: function () {
            this.oldTime = this.startTime = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now();
            this.running = !0
        }, stop: function () {
            this.getElapsedTime();
            this.running = !1
        }, getElapsedTime: function () {
            this.getDelta();
            return this.elapsedTime
        }, getDelta: function () {
            var a = 0;
            this.autoStart && !this.running && this.start();
            if (this.running) {
                var b = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now(),
                    a = .001 * (b - this.oldTime);
                this.oldTime = b;
                this.elapsedTime += a
            }
            return a
        }
    };
    THREE.EventDispatcher = function () {
    };
    THREE.EventDispatcher.prototype = {
        constructor: THREE.EventDispatcher, apply: function (a) {
            a.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
            a.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
            a.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
            a.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent
        }, addEventListener: function (a, b) {
            void 0 === this._listeners && (this._listeners = {});
            var d = this._listeners;
            void 0 === d[a] && (d[a] = []);
            -1 === d[a].indexOf(b) &&
            d[a].push(b)
        }, hasEventListener: function (a, b) {
            if (void 0 === this._listeners) return !1;
            var d = this._listeners;
            return void 0 !== d[a] && -1 !== d[a].indexOf(b) ? !0 : !1
        }, removeEventListener: function (a, b) {
            if (void 0 !== this._listeners) {
                var d = this._listeners[a];
                if (void 0 !== d) {
                    var e = d.indexOf(b);
                    -1 !== e && d.splice(e, 1)
                }
            }
        }, dispatchEvent: function (a) {
            if (void 0 !== this._listeners) {
                var b = this._listeners[a.type];
                if (void 0 !== b) {
                    a.target = this;
                    for (var d = [], e = b.length, f = 0; f < e; f++) d[f] = b[f];
                    for (f = 0; f < e; f++) d[f].call(this, a)
                }
            }
        }
    };
    (function (a) {
        a.Raycaster = function (b, d, h, g) {
            this.ray = new a.Ray(b, d);
            this.near = h || 0;
            this.far = g || Infinity;
            this.params = {Sprite: {}, Mesh: {}, PointCloud: {threshold: 1}, LOD: {}, Line: {}}
        };
        var b = function (a, b) {
            return a.distance - b.distance
        }, d = function (a, b, h, g) {
            a.raycast(b, h);
            if (!0 === g) {
                a = a.children;
                g = 0;
                for (var k = a.length; g < k; g++) d(a[g], b, h, !0)
            }
        };
        a.Raycaster.prototype = {
            constructor: a.Raycaster, precision: 1E-4, linePrecision: 1, set: function (a, b) {
                this.ray.set(a, b)
            }, intersectObject: function (a, f) {
                var h = [];
                d(a, this, h, f);
                h.sort(b);
                return h
            }, intersectObjects: function (a, f) {
                var h = [];
                if (!1 === a instanceof Array) return console.log("THREE.Raycaster.intersectObjects: objects is not an Array."), h;
                for (var g = 0, k = a.length; g < k; g++) d(a[g], this, h, f);
                h.sort(b);
                return h
            }
        }
    })(THREE);
    THREE.Object3D = function () {
        Object.defineProperty(this, "id", {value: THREE.Object3DIdCount++});
        this.uuid = THREE.Math.generateUUID();
        this.name = "";
        this.type = "Object3D";
        this.parent = void 0;
        this.children = [];
        this.up = THREE.Object3D.DefaultUp.clone();
        var a = new THREE.Vector3, b = new THREE.Euler, d = new THREE.Quaternion, e = new THREE.Vector3(1, 1, 1);
        b.onChange(function () {
            d.setFromEuler(b, !1)
        });
        d.onChange(function () {
            b.setFromQuaternion(d, void 0, !1)
        });
        Object.defineProperties(this, {
            position: {enumerable: !0, value: a}, rotation: {
                enumerable: !0,
                value: b
            }, quaternion: {enumerable: !0, value: d}, scale: {enumerable: !0, value: e}
        });
        this.renderDepth = null;
        this.rotationAutoUpdate = !0;
        this.matrix = new THREE.Matrix4;
        this.matrixWorld = new THREE.Matrix4;
        this.matrixAutoUpdate = !0;
        this.matrixWorldNeedsUpdate = !1;
        this.visible = !0;
        this.receiveShadow = this.castShadow = !1;
        this.frustumCulled = !0;
        this.userData = {}
    };
    THREE.Object3D.DefaultUp = new THREE.Vector3(0, 1, 0);
    THREE.Object3D.prototype = {
        constructor: THREE.Object3D, get eulerOrder() {
            console.warn("THREE.Object3D: .eulerOrder has been moved to .rotation.order.");
            return this.rotation.order
        }, set eulerOrder(a) {
            console.warn("THREE.Object3D: .eulerOrder has been moved to .rotation.order.");
            this.rotation.order = a
        }, get useQuaternion() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
        }, set useQuaternion(a) {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
        },
        applyMatrix: function (a) {
            this.matrix.multiplyMatrices(a, this.matrix);
            this.matrix.decompose(this.position, this.quaternion, this.scale)
        }, setRotationFromAxisAngle: function (a, b) {
            this.quaternion.setFromAxisAngle(a, b)
        }, setRotationFromEuler: function (a) {
            this.quaternion.setFromEuler(a, !0)
        }, setRotationFromMatrix: function (a) {
            this.quaternion.setFromRotationMatrix(a)
        }, setRotationFromQuaternion: function (a) {
            this.quaternion.copy(a)
        }, rotateOnAxis: function () {
            var a = new THREE.Quaternion;
            return function (b, d) {
                a.setFromAxisAngle(b,
                    d);
                this.quaternion.multiply(a);
                return this
            }
        }(), rotateX: function () {
            var a = new THREE.Vector3(1, 0, 0);
            return function (b) {
                return this.rotateOnAxis(a, b)
            }
        }(), rotateY: function () {
            var a = new THREE.Vector3(0, 1, 0);
            return function (b) {
                return this.rotateOnAxis(a, b)
            }
        }(), rotateZ: function () {
            var a = new THREE.Vector3(0, 0, 1);
            return function (b) {
                return this.rotateOnAxis(a, b)
            }
        }(), translateOnAxis: function () {
            var a = new THREE.Vector3;
            return function (b, d) {
                a.copy(b).applyQuaternion(this.quaternion);
                this.position.add(a.multiplyScalar(d));
                return this
            }
        }(), translate: function (a, b) {
            console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
            return this.translateOnAxis(b, a)
        }, translateX: function () {
            var a = new THREE.Vector3(1, 0, 0);
            return function (b) {
                return this.translateOnAxis(a, b)
            }
        }(), translateY: function () {
            var a = new THREE.Vector3(0, 1, 0);
            return function (b) {
                return this.translateOnAxis(a, b)
            }
        }(), translateZ: function () {
            var a = new THREE.Vector3(0, 0, 1);
            return function (b) {
                return this.translateOnAxis(a,
                    b)
            }
        }(), localToWorld: function (a) {
            return a.applyMatrix4(this.matrixWorld)
        }, worldToLocal: function () {
            var a = new THREE.Matrix4;
            return function (b) {
                return b.applyMatrix4(a.getInverse(this.matrixWorld))
            }
        }(), lookAt: function () {
            var a = new THREE.Matrix4;
            return function (b) {
                a.lookAt(b, this.position, this.up);
                this.quaternion.setFromRotationMatrix(a)
            }
        }(), add: function (a) {
            if (1 < arguments.length) {
                for (var b = 0; b < arguments.length; b++) this.add(arguments[b]);
                return this
            }
            if (a === this) return console.error("THREE.Object3D.add:",
                a, "can't be added as a child of itself."), this;
            a instanceof THREE.Object3D ? (void 0 !== a.parent && a.parent.remove(a), a.parent = this, a.dispatchEvent({type: "added"}), this.children.push(a)) : console.error("THREE.Object3D.add:", a, "is not an instance of THREE.Object3D.");
            return this
        }, remove: function (a) {
            if (1 < arguments.length) for (var b = 0; b < arguments.length; b++) this.remove(arguments[b]);
            b = this.children.indexOf(a);
            -1 !== b && (a.parent = void 0, a.dispatchEvent({type: "removed"}), this.children.splice(b, 1))
        }, getChildByName: function (a,
                                     b) {
            console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
            return this.getObjectByName(a, b)
        }, getObjectById: function (a, b) {
            if (this.id === a) return this;
            for (var d = 0, e = this.children.length; d < e; d++) {
                var f = this.children[d].getObjectById(a, b);
                if (void 0 !== f) return f
            }
        }, getObjectByName: function (a, b) {
            if (this.name === a) return this;
            for (var d = 0, e = this.children.length; d < e; d++) {
                var f = this.children[d].getObjectByName(a, b);
                if (void 0 !== f) return f
            }
        }, getWorldPosition: function (a) {
            a = a || new THREE.Vector3;
            this.updateMatrixWorld(!0);
            return a.setFromMatrixPosition(this.matrixWorld)
        }, getWorldQuaternion: function () {
            var a = new THREE.Vector3, b = new THREE.Vector3;
            return function (d) {
                d = d || new THREE.Quaternion;
                this.updateMatrixWorld(!0);
                this.matrixWorld.decompose(a, d, b);
                return d
            }
        }(), getWorldRotation: function () {
            var a = new THREE.Quaternion;
            return function (b) {
                b = b || new THREE.Euler;
                this.getWorldQuaternion(a);
                return b.setFromQuaternion(a, this.rotation.order, !1)
            }
        }(), getWorldScale: function () {
            var a = new THREE.Vector3, b = new THREE.Quaternion;
            return function (d) {
                d = d || new THREE.Vector3;
                this.updateMatrixWorld(!0);
                this.matrixWorld.decompose(a, b, d);
                return d
            }
        }(), getWorldDirection: function () {
            var a = new THREE.Quaternion;
            return function (b) {
                b = b || new THREE.Vector3;
                this.getWorldQuaternion(a);
                return b.set(0, 0, 1).applyQuaternion(a)
            }
        }(), raycast: function () {
        }, traverse: function (a) {
            a(this);
            for (var b = 0, d = this.children.length; b < d; b++) this.children[b].traverse(a)
        }, traverseVisible: function (a) {
            if (!1 !== this.visible) {
                a(this);
                for (var b = 0, d = this.children.length; b <
                d; b++) this.children[b].traverseVisible(a)
            }
        }, updateMatrix: function () {
            this.matrix.compose(this.position, this.quaternion, this.scale);
            this.matrixWorldNeedsUpdate = !0
        }, updateMatrixWorld: function (a) {
            !0 === this.matrixAutoUpdate && this.updateMatrix();
            if (!0 === this.matrixWorldNeedsUpdate || !0 === a) void 0 === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0;
            for (var b = 0, d = this.children.length; b < d; b++) this.children[b].updateMatrixWorld(a)
        },
        toJSON: function () {
            var a = {metadata: {version: 4.3, type: "Object", generator: "ObjectExporter"}}, b = {}, d = function (d) {
                void 0 === a.geometries && (a.geometries = []);
                if (void 0 === b[d.uuid]) {
                    var e = d.toJSON();
                    delete e.metadata;
                    b[d.uuid] = e;
                    a.geometries.push(e)
                }
                return d.uuid
            }, e = {}, f = function (b) {
                void 0 === a.materials && (a.materials = []);
                if (void 0 === e[b.uuid]) {
                    var d = b.toJSON();
                    delete d.metadata;
                    e[b.uuid] = d;
                    a.materials.push(d)
                }
                return b.uuid
            }, h = function (a) {
                var b = {};
                b.uuid = a.uuid;
                b.type = a.type;
                "" !== a.name && (b.name = a.name);
                "{}" !==
                JSON.stringify(a.userData) && (b.userData = a.userData);
                !0 !== a.visible && (b.visible = a.visible);
                a instanceof THREE.PerspectiveCamera ? (b.fov = a.fov, b.aspect = a.aspect, b.near = a.near, b.far = a.far) : a instanceof THREE.OrthographicCamera ? (b.left = a.left, b.right = a.right, b.top = a.top, b.bottom = a.bottom, b.near = a.near, b.far = a.far) : a instanceof THREE.AmbientLight ? b.color = a.color.getHex() : a instanceof THREE.DirectionalLight ? (b.color = a.color.getHex(), b.intensity = a.intensity) : a instanceof THREE.PointLight ? (b.color = a.color.getHex(),
                    b.intensity = a.intensity, b.distance = a.distance) : a instanceof THREE.SpotLight ? (b.color = a.color.getHex(), b.intensity = a.intensity, b.distance = a.distance, b.angle = a.angle, b.exponent = a.exponent) : a instanceof THREE.HemisphereLight ? (b.color = a.color.getHex(), b.groundColor = a.groundColor.getHex()) : a instanceof THREE.Mesh ? (b.geometry = d(a.geometry), b.material = f(a.material)) : a instanceof THREE.Line ? (b.geometry = d(a.geometry), b.material = f(a.material)) : a instanceof THREE.Sprite && (b.material = f(a.material));
                b.matrix =
                    a.matrix.toArray();
                if (0 < a.children.length) {
                    b.children = [];
                    for (var e = 0; e < a.children.length; e++) b.children.push(h(a.children[e]))
                }
                return b
            };
            a.object = h(this);
            return a
        }, clone: function (a, b) {
            void 0 === a && (a = new THREE.Object3D);
            void 0 === b && (b = !0);
            a.name = this.name;
            a.up.copy(this.up);
            a.position.copy(this.position);
            a.quaternion.copy(this.quaternion);
            a.scale.copy(this.scale);
            a.renderDepth = this.renderDepth;
            a.rotationAutoUpdate = this.rotationAutoUpdate;
            a.matrix.copy(this.matrix);
            a.matrixWorld.copy(this.matrixWorld);
            a.matrixAutoUpdate = this.matrixAutoUpdate;
            a.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;
            a.visible = this.visible;
            a.castShadow = this.castShadow;
            a.receiveShadow = this.receiveShadow;
            a.frustumCulled = this.frustumCulled;
            a.userData = JSON.parse(JSON.stringify(this.userData));
            if (!0 === b) for (var d = 0; d < this.children.length; d++) a.add(this.children[d].clone());
            return a
        }
    };
    THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);
    THREE.Object3DIdCount = 0;
    THREE.Projector = function () {
        console.warn("THREE.Projector has been moved to /examples/renderers/Projector.js.");
        this.projectVector = function (a, b) {
            console.warn("THREE.Projector: .projectVector() is now vector.project().");
            a.project(b)
        };
        this.unprojectVector = function (a, b) {
            console.warn("THREE.Projector: .unprojectVector() is now vector.unproject().");
            a.unproject(b)
        };
        this.pickingRay = function (a, b) {
            console.error("THREE.Projector: .pickingRay() has been removed.")
        }
    };
    THREE.Face3 = function (a, b, d, e, f, h) {
        this.a = a;
        this.b = b;
        this.c = d;
        this.normal = e instanceof THREE.Vector3 ? e : new THREE.Vector3;
        this.vertexNormals = e instanceof Array ? e : [];
        this.color = f instanceof THREE.Color ? f : new THREE.Color;
        this.vertexColors = f instanceof Array ? f : [];
        this.vertexTangents = [];
        this.materialIndex = void 0 !== h ? h : 0
    };
    THREE.Face3.prototype = {
        constructor: THREE.Face3, clone: function () {
            var a = new THREE.Face3(this.a, this.b, this.c);
            a.normal.copy(this.normal);
            a.color.copy(this.color);
            a.materialIndex = this.materialIndex;
            for (var b = 0, d = this.vertexNormals.length; b < d; b++) a.vertexNormals[b] = this.vertexNormals[b].clone();
            b = 0;
            for (d = this.vertexColors.length; b < d; b++) a.vertexColors[b] = this.vertexColors[b].clone();
            b = 0;
            for (d = this.vertexTangents.length; b < d; b++) a.vertexTangents[b] = this.vertexTangents[b].clone();
            return a
        }
    };
    THREE.Face4 = function (a, b, d, e, f, h, g) {
        console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");
        return new THREE.Face3(a, b, d, f, h, g)
    };
    THREE.BufferAttribute = function (a, b) {
        this.array = a;
        this.itemSize = b;
        this.needsUpdate = !1
    };
    THREE.BufferAttribute.prototype = {
        constructor: THREE.BufferAttribute, get length() {
            return this.array.length
        }, copyAt: function (a, b, d) {
            a *= this.itemSize;
            d *= b.itemSize;
            for (var e = 0, f = this.itemSize; e < f; e++) this.array[a + e] = b.array[d + e]
        }, set: function (a) {
            this.array.set(a);
            return this
        }, setX: function (a, b) {
            this.array[a * this.itemSize] = b;
            return this
        }, setY: function (a, b) {
            this.array[a * this.itemSize + 1] = b;
            return this
        }, setZ: function (a, b) {
            this.array[a * this.itemSize + 2] = b;
            return this
        }, setXY: function (a, b, d) {
            a *= this.itemSize;
            this.array[a] = b;
            this.array[a + 1] = d;
            return this
        }, setXYZ: function (a, b, d, e) {
            a *= this.itemSize;
            this.array[a] = b;
            this.array[a + 1] = d;
            this.array[a + 2] = e;
            return this
        }, setXYZW: function (a, b, d, e, f) {
            a *= this.itemSize;
            this.array[a] = b;
            this.array[a + 1] = d;
            this.array[a + 2] = e;
            this.array[a + 3] = f;
            return this
        }, clone: function () {
            return new THREE.BufferAttribute(new this.array.constructor(this.array), this.itemSize)
        }
    };
    THREE.Int8Attribute = function (a, b) {
        console.warn("THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
        return new THREE.BufferAttribute(a, b)
    };
    THREE.Uint8Attribute = function (a, b) {
        console.warn("THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
        return new THREE.BufferAttribute(a, b)
    };
    THREE.Uint8ClampedAttribute = function (a, b) {
        console.warn("THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
        return new THREE.BufferAttribute(a, b)
    };
    THREE.Int16Attribute = function (a, b) {
        console.warn("THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
        return new THREE.BufferAttribute(a, b)
    };
    THREE.Uint16Attribute = function (a, b) {
        console.warn("THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
        return new THREE.BufferAttribute(a, b)
    };
    THREE.Int32Attribute = function (a, b) {
        console.warn("THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
        return new THREE.BufferAttribute(a, b)
    };
    THREE.Uint32Attribute = function (a, b) {
        console.warn("THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
        return new THREE.BufferAttribute(a, b)
    };
    THREE.Float32Attribute = function (a, b) {
        console.warn("THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
        return new THREE.BufferAttribute(a, b)
    };
    THREE.Float64Attribute = function (a, b) {
        console.warn("THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
        return new THREE.BufferAttribute(a, b)
    };
    THREE.BufferGeometry = function () {
        Object.defineProperty(this, "id", {value: THREE.GeometryIdCount++});
        this.uuid = THREE.Math.generateUUID();
        this.name = "";
        this.type = "BufferGeometry";
        this.attributes = {};
        this.attributesKeys = [];
        this.offsets = this.drawcalls = [];
        this.boundingSphere = this.boundingBox = null
    };
    THREE.BufferGeometry.prototype = {
        constructor: THREE.BufferGeometry, addAttribute: function (a, b, d) {
            !1 === b instanceof THREE.BufferAttribute ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.attributes[a] = {
                array: b,
                itemSize: d
            }) : (this.attributes[a] = b, this.attributesKeys = Object.keys(this.attributes))
        }, getAttribute: function (a) {
            return this.attributes[a]
        }, addDrawCall: function (a, b, d) {
            this.drawcalls.push({start: a, count: b, index: void 0 !== d ? d : 0})
        }, applyMatrix: function (a) {
            var b =
                this.attributes.position;
            void 0 !== b && (a.applyToVector3Array(b.array), b.needsUpdate = !0);
            b = this.attributes.normal;
            void 0 !== b && ((new THREE.Matrix3).getNormalMatrix(a).applyToVector3Array(b.array), b.needsUpdate = !0)
        }, center: function () {
        }, fromGeometry: function (a, b) {
            b = b || {vertexColors: THREE.NoColors};
            var d = a.vertices, e = a.faces, f = a.faceVertexUvs, h = b.vertexColors, g = 0 < f[0].length,
                k = 3 == e[0].vertexNormals.length, l = new Float32Array(9 * e.length);
            this.addAttribute("position", new THREE.BufferAttribute(l, 3));
            var m =
                new Float32Array(9 * e.length);
            this.addAttribute("normal", new THREE.BufferAttribute(m, 3));
            if (h !== THREE.NoColors) {
                var n = new Float32Array(9 * e.length);
                this.addAttribute("color", new THREE.BufferAttribute(n, 3))
            }
            if (!0 === g) {
                var q = new Float32Array(6 * e.length);
                this.addAttribute("uv", new THREE.BufferAttribute(q, 2))
            }
            for (var p = 0, r = 0, v = 0; p < e.length; p++, r += 6, v += 9) {
                var u = e[p], x = d[u.a], w = d[u.b], z = d[u.c];
                l[v] = x.x;
                l[v + 1] = x.y;
                l[v + 2] = x.z;
                l[v + 3] = w.x;
                l[v + 4] = w.y;
                l[v + 5] = w.z;
                l[v + 6] = z.x;
                l[v + 7] = z.y;
                l[v + 8] = z.z;
                !0 === k ? (x = u.vertexNormals[0],
                    w = u.vertexNormals[1], z = u.vertexNormals[2], m[v] = x.x, m[v + 1] = x.y, m[v + 2] = x.z, m[v + 3] = w.x, m[v + 4] = w.y, m[v + 5] = w.z, m[v + 6] = z.x, m[v + 7] = z.y, m[v + 8] = z.z) : (x = u.normal, m[v] = x.x, m[v + 1] = x.y, m[v + 2] = x.z, m[v + 3] = x.x, m[v + 4] = x.y, m[v + 5] = x.z, m[v + 6] = x.x, m[v + 7] = x.y, m[v + 8] = x.z);
                h === THREE.FaceColors ? (u = u.color, n[v] = u.r, n[v + 1] = u.g, n[v + 2] = u.b, n[v + 3] = u.r, n[v + 4] = u.g, n[v + 5] = u.b, n[v + 6] = u.r, n[v + 7] = u.g, n[v + 8] = u.b) : h === THREE.VertexColors && (x = u.vertexColors[0], w = u.vertexColors[1], u = u.vertexColors[2], n[v] = x.r, n[v + 1] = x.g, n[v + 2] = x.b, n[v + 3] =
                    w.r, n[v + 4] = w.g, n[v + 5] = w.b, n[v + 6] = u.r, n[v + 7] = u.g, n[v + 8] = u.b);
                !0 === g && (u = f[0][p][0], x = f[0][p][1], w = f[0][p][2], q[r] = u.x, q[r + 1] = u.y, q[r + 2] = x.x, q[r + 3] = x.y, q[r + 4] = w.x, q[r + 5] = w.y)
            }
            this.computeBoundingSphere();
            return this
        }, computeBoundingBox: function () {
            var a = new THREE.Vector3;
            return function () {
                null === this.boundingBox && (this.boundingBox = new THREE.Box3);
                var b = this.attributes.position.array;
                if (b) {
                    var d = this.boundingBox;
                    d.makeEmpty();
                    for (var e = 0, f = b.length; e < f; e += 3) a.set(b[e], b[e + 1], b[e + 2]), d.expandByPoint(a)
                }
                if (void 0 ===
                    b || 0 === b.length) this.boundingBox.min.set(0, 0, 0), this.boundingBox.max.set(0, 0, 0);
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.')
            }
        }(), computeBoundingSphere: function () {
            var a = new THREE.Box3, b = new THREE.Vector3;
            return function () {
                null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
                var d = this.attributes.position.array;
                if (d) {
                    a.makeEmpty();
                    for (var e = this.boundingSphere.center, f = 0, h = d.length; f < h; f += 3) b.set(d[f], d[f + 1], d[f + 2]), a.expandByPoint(b);
                    a.center(e);
                    for (var g = 0, f = 0, h = d.length; f < h; f += 3) b.set(d[f], d[f + 1], d[f + 2]), g = Math.max(g, e.distanceToSquared(b));
                    this.boundingSphere.radius = Math.sqrt(g);
                    isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.')
                }
            }
        }(), computeFaceNormals: function () {
        }, computeVertexNormals: function () {
            var a =
                this.attributes;
            if (a.position) {
                var b = a.position.array;
                if (void 0 === a.normal) this.addAttribute("normal", new THREE.BufferAttribute(new Float32Array(b.length), 3)); else for (var d = a.normal.array, e = 0, f = d.length; e < f; e++) d[e] = 0;
                var d = a.normal.array, h, g, k, l = new THREE.Vector3, m = new THREE.Vector3, n = new THREE.Vector3,
                    q = new THREE.Vector3, p = new THREE.Vector3;
                if (a.index) for (var r = a.index.array, v = 0 < this.offsets.length ? this.offsets : [{
                    start: 0,
                    count: r.length,
                    index: 0
                }], u = 0, x = v.length; u < x; ++u) {
                    f = v[u].start;
                    h = v[u].count;
                    for (var w = v[u].index, e = f, f = f + h; e < f; e += 3) h = 3 * (w + r[e]), g = 3 * (w + r[e + 1]), k = 3 * (w + r[e + 2]), l.fromArray(b, h), m.fromArray(b, g), n.fromArray(b, k), q.subVectors(n, m), p.subVectors(l, m), q.cross(p), d[h] += q.x, d[h + 1] += q.y, d[h + 2] += q.z, d[g] += q.x, d[g + 1] += q.y, d[g + 2] += q.z, d[k] += q.x, d[k + 1] += q.y, d[k + 2] += q.z
                } else for (e = 0, f = b.length; e < f; e += 9) l.fromArray(b, e), m.fromArray(b, e + 3), n.fromArray(b, e + 6), q.subVectors(n, m), p.subVectors(l, m), q.cross(p), d[e] = q.x, d[e + 1] = q.y, d[e + 2] = q.z, d[e + 3] = q.x, d[e + 4] = q.y, d[e + 5] = q.z, d[e + 6] = q.x, d[e + 7] = q.y,
                    d[e + 8] = q.z;
                this.normalizeNormals();
                a.normal.needsUpdate = !0
            }
        }, computeTangents: function () {
            function a(a, b, d) {
                q.fromArray(e, 3 * a);
                p.fromArray(e, 3 * b);
                r.fromArray(e, 3 * d);
                v.fromArray(h, 2 * a);
                u.fromArray(h, 2 * b);
                x.fromArray(h, 2 * d);
                w = p.x - q.x;
                z = r.x - q.x;
                F = p.y - q.y;
                B = r.y - q.y;
                H = p.z - q.z;
                E = r.z - q.z;
                I = u.x - v.x;
                A = x.x - v.x;
                N = u.y - v.y;
                G = x.y - v.y;
                D = 1 / (I * G - A * N);
                Y.set((G * w - N * z) * D, (G * F - N * B) * D, (G * H - N * E) * D);
                C.set((I * z - A * w) * D, (I * B - A * F) * D, (I * E - A * H) * D);
                l[a].add(Y);
                l[b].add(Y);
                l[d].add(Y);
                m[a].add(C);
                m[b].add(C);
                m[d].add(C)
            }

            function b(a) {
                ca.fromArray(f,
                    3 * a);
                M.copy(ca);
                ea = l[a];
                S.copy(ea);
                S.sub(ca.multiplyScalar(ca.dot(ea))).normalize();
                da.crossVectors(M, ea);
                ka = da.dot(m[a]);
                la = 0 > ka ? -1 : 1;
                k[4 * a] = S.x;
                k[4 * a + 1] = S.y;
                k[4 * a + 2] = S.z;
                k[4 * a + 3] = la
            }

            if (void 0 === this.attributes.index || void 0 === this.attributes.position || void 0 === this.attributes.normal || void 0 === this.attributes.uv) console.warn("Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()"); else {
                var d = this.attributes.index.array, e = this.attributes.position.array, f =
                    this.attributes.normal.array, h = this.attributes.uv.array, g = e.length / 3;
                void 0 === this.attributes.tangent && this.addAttribute("tangent", new THREE.BufferAttribute(new Float32Array(4 * g), 4));
                for (var k = this.attributes.tangent.array, l = [], m = [], n = 0; n < g; n++) l[n] = new THREE.Vector3, m[n] = new THREE.Vector3;
                var q = new THREE.Vector3, p = new THREE.Vector3, r = new THREE.Vector3, v = new THREE.Vector2,
                    u = new THREE.Vector2, x = new THREE.Vector2, w, z, F, B, H, E, I, A, N, G, D,
                    Y = new THREE.Vector3, C = new THREE.Vector3, K, J, L, U, aa;
                0 === this.drawcalls.length &&
                this.addDrawCall(0, d.length, 0);
                var Z = this.drawcalls, n = 0;
                for (J = Z.length; n < J; ++n) {
                    K = Z[n].start;
                    L = Z[n].count;
                    var P = Z[n].index, g = K;
                    for (K += L; g < K; g += 3) L = P + d[g], U = P + d[g + 1], aa = P + d[g + 2], a(L, U, aa)
                }
                var S = new THREE.Vector3, da = new THREE.Vector3, ca = new THREE.Vector3, M = new THREE.Vector3, la,
                    ea, ka, n = 0;
                for (J = Z.length; n < J; ++n) for (K = Z[n].start, L = Z[n].count, P = Z[n].index, g = K, K += L; g < K; g += 3) L = P + d[g], U = P + d[g + 1], aa = P + d[g + 2], b(L), b(U), b(aa)
            }
        }, computeOffsets: function (a) {
            var b = a;
            void 0 === a && (b = 65535);
            Date.now();
            a = this.attributes.index.array;
            for (var d = this.attributes.position.array, e = a.length / 3, f = new Uint16Array(a.length), h = 0, g = 0, k = [{
                start: 0,
                count: 0,
                index: 0
            }], l = k[0], m = 0, n = 0, q = new Int32Array(6), p = new Int32Array(d.length), r = new Int32Array(d.length), v = 0; v < d.length; v++) p[v] = -1, r[v] = -1;
            for (d = 0; d < e; d++) {
                for (var u = n = 0; 3 > u; u++) v = a[3 * d + u], -1 == p[v] ? (q[2 * u] = v, q[2 * u + 1] = -1, n++) : p[v] < l.index ? (q[2 * u] = v, q[2 * u + 1] = -1, m++) : (q[2 * u] = v, q[2 * u + 1] = p[v]);
                if (g + n > l.index + b) for (l = {
                    start: h,
                    count: 0,
                    index: g
                }, k.push(l), n = 0; 6 > n; n += 2) u = q[n + 1], -1 < u && u < l.index && (q[n + 1] =
                    -1);
                for (n = 0; 6 > n; n += 2) v = q[n], u = q[n + 1], -1 === u && (u = g++), p[v] = u, r[u] = v, f[h++] = u - l.index, l.count++
            }
            this.reorderBuffers(f, r, g);
            return this.offsets = k
        }, merge: function () {
            console.log("BufferGeometry.merge(): TODO")
        }, normalizeNormals: function () {
            for (var a = this.attributes.normal.array, b, d, e, f = 0, h = a.length; f < h; f += 3) b = a[f], d = a[f + 1], e = a[f + 2], b = 1 / Math.sqrt(b * b + d * d + e * e), a[f] *= b, a[f + 1] *= b, a[f + 2] *= b
        }, reorderBuffers: function (a, b, d) {
            var e = {}, f;
            for (f in this.attributes) "index" != f && (e[f] = new this.attributes[f].array.constructor(this.attributes[f].itemSize *
                d));
            for (var h = 0; h < d; h++) {
                var g = b[h];
                for (f in this.attributes) if ("index" != f) for (var k = this.attributes[f].array, l = this.attributes[f].itemSize, m = e[f], n = 0; n < l; n++) m[h * l + n] = k[g * l + n]
            }
            this.attributes.index.array = a;
            for (f in this.attributes) "index" != f && (this.attributes[f].array = e[f], this.attributes[f].numItems = this.attributes[f].itemSize * d)
        }, toJSON: function () {
            var a = {
                    metadata: {version: 4, type: "BufferGeometry", generator: "BufferGeometryExporter"},
                    uuid: this.uuid,
                    type: this.type,
                    data: {attributes: {}}
                }, b = this.attributes,
                d = this.offsets, e = this.boundingSphere, f;
            for (f in b) {
                for (var h = b[f], g = [], k = h.array, l = 0, m = k.length; l < m; l++) g[l] = k[l];
                a.data.attributes[f] = {itemSize: h.itemSize, type: h.array.constructor.name, array: g}
            }
            0 < d.length && (a.data.offsets = JSON.parse(JSON.stringify(d)));
            null !== e && (a.data.boundingSphere = {center: e.center.toArray(), radius: e.radius});
            return a
        }, clone: function () {
            var a = new THREE.BufferGeometry, b;
            for (b in this.attributes) a.addAttribute(b, this.attributes[b].clone());
            b = 0;
            for (var d = this.offsets.length; b < d; b++) {
                var e =
                    this.offsets[b];
                a.offsets.push({start: e.start, index: e.index, count: e.count})
            }
            return a
        }, dispose: function () {
            this.dispatchEvent({type: "dispose"})
        }
    };
    THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);
    THREE.Geometry = function () {
        Object.defineProperty(this, "id", {value: THREE.GeometryIdCount++});
        this.uuid = THREE.Math.generateUUID();
        this.name = "";
        this.type = "Geometry";
        this.vertices = [];
        this.colors = [];
        this.faces = [];
        this.faceVertexUvs = [[]];
        this.morphTargets = [];
        this.morphColors = [];
        this.morphNormals = [];
        this.skinWeights = [];
        this.skinIndices = [];
        this.lineDistances = [];
        this.boundingSphere = this.boundingBox = null;
        this.hasTangents = !1;
        this.dynamic = !0;
        this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate =
            this.tangentsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.elementsNeedUpdate = this.verticesNeedUpdate = !1
    };
    THREE.Geometry.prototype = {
        constructor: THREE.Geometry, applyMatrix: function (a) {
            for (var b = (new THREE.Matrix3).getNormalMatrix(a), d = 0, e = this.vertices.length; d < e; d++) this.vertices[d].applyMatrix4(a);
            d = 0;
            for (e = this.faces.length; d < e; d++) {
                a = this.faces[d];
                a.normal.applyMatrix3(b).normalize();
                for (var f = 0, h = a.vertexNormals.length; f < h; f++) a.vertexNormals[f].applyMatrix3(b).normalize()
            }
            this.boundingBox instanceof THREE.Box3 && this.computeBoundingBox();
            this.boundingSphere instanceof THREE.Sphere && this.computeBoundingSphere()
        },
        fromBufferGeometry: function (a) {
            for (var b = this, d = a.attributes, e = d.position.array, f = void 0 !== d.index ? d.index.array : void 0, h = void 0 !== d.normal ? d.normal.array : void 0, g = void 0 !== d.color ? d.color.array : void 0, k = void 0 !== d.uv ? d.uv.array : void 0, l = [], m = [], n = d = 0; d < e.length; d += 3, n += 2) b.vertices.push(new THREE.Vector3(e[d], e[d + 1], e[d + 2])), void 0 !== h && l.push(new THREE.Vector3(h[d], h[d + 1], h[d + 2])), void 0 !== g && b.colors.push(new THREE.Color(g[d], g[d + 1], g[d + 2])), void 0 !== k && m.push(new THREE.Vector2(k[n], k[n + 1]));
            k =
                function (a, d, e) {
                    var f = void 0 !== h ? [l[a].clone(), l[d].clone(), l[e].clone()] : [],
                        k = void 0 !== g ? [b.colors[a].clone(), b.colors[d].clone(), b.colors[e].clone()] : [];
                    b.faces.push(new THREE.Face3(a, d, e, f, k));
                    b.faceVertexUvs[0].push([m[a], m[d], m[e]])
                };
            if (void 0 !== f) for (d = 0; d < f.length; d += 3) k(f[d], f[d + 1], f[d + 2]); else for (d = 0; d < e.length / 3; d += 3) k(d, d + 1, d + 2);
            this.computeFaceNormals();
            null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
            null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
            return this
        }, center: function () {
            this.computeBoundingBox();
            var a = new THREE.Vector3;
            a.addVectors(this.boundingBox.min, this.boundingBox.max);
            a.multiplyScalar(-.5);
            this.applyMatrix((new THREE.Matrix4).makeTranslation(a.x, a.y, a.z));
            this.computeBoundingBox();
            return a
        }, computeFaceNormals: function () {
            for (var a = new THREE.Vector3, b = new THREE.Vector3, d = 0, e = this.faces.length; d < e; d++) {
                var f = this.faces[d], h = this.vertices[f.a], g = this.vertices[f.b];
                a.subVectors(this.vertices[f.c], g);
                b.subVectors(h, g);
                a.cross(b);
                a.normalize();
                f.normal.copy(a)
            }
        }, computeVertexNormals: function (a) {
            var b, d, e;
            e = Array(this.vertices.length);
            b = 0;
            for (d = this.vertices.length; b < d; b++) e[b] = new THREE.Vector3;
            if (a) {
                var f, h, g, k = new THREE.Vector3, l = new THREE.Vector3;
                new THREE.Vector3;
                new THREE.Vector3;
                new THREE.Vector3;
                a = 0;
                for (b = this.faces.length; a < b; a++) d = this.faces[a], f = this.vertices[d.a], h = this.vertices[d.b], g = this.vertices[d.c], k.subVectors(g, h), l.subVectors(f, h), k.cross(l), e[d.a].add(k), e[d.b].add(k), e[d.c].add(k)
            } else for (a = 0, b = this.faces.length; a <
            b; a++) d = this.faces[a], e[d.a].add(d.normal), e[d.b].add(d.normal), e[d.c].add(d.normal);
            b = 0;
            for (d = this.vertices.length; b < d; b++) e[b].normalize();
            a = 0;
            for (b = this.faces.length; a < b; a++) d = this.faces[a], d.vertexNormals[0] = e[d.a].clone(), d.vertexNormals[1] = e[d.b].clone(), d.vertexNormals[2] = e[d.c].clone()
        }, computeMorphNormals: function () {
            var a, b, d, e, f;
            d = 0;
            for (e = this.faces.length; d < e; d++) for (f = this.faces[d], f.__originalFaceNormal ? f.__originalFaceNormal.copy(f.normal) : f.__originalFaceNormal = f.normal.clone(), f.__originalVertexNormals ||
            (f.__originalVertexNormals = []), a = 0, b = f.vertexNormals.length; a < b; a++) f.__originalVertexNormals[a] ? f.__originalVertexNormals[a].copy(f.vertexNormals[a]) : f.__originalVertexNormals[a] = f.vertexNormals[a].clone();
            var h = new THREE.Geometry;
            h.faces = this.faces;
            a = 0;
            for (b = this.morphTargets.length; a < b; a++) {
                if (!this.morphNormals[a]) {
                    this.morphNormals[a] = {};
                    this.morphNormals[a].faceNormals = [];
                    this.morphNormals[a].vertexNormals = [];
                    f = this.morphNormals[a].faceNormals;
                    var g = this.morphNormals[a].vertexNormals, k, l;
                    d =
                        0;
                    for (e = this.faces.length; d < e; d++) k = new THREE.Vector3, l = {
                        a: new THREE.Vector3,
                        b: new THREE.Vector3,
                        c: new THREE.Vector3
                    }, f.push(k), g.push(l)
                }
                g = this.morphNormals[a];
                h.vertices = this.morphTargets[a].vertices;
                h.computeFaceNormals();
                h.computeVertexNormals();
                d = 0;
                for (e = this.faces.length; d < e; d++) f = this.faces[d], k = g.faceNormals[d], l = g.vertexNormals[d], k.copy(f.normal), l.a.copy(f.vertexNormals[0]), l.b.copy(f.vertexNormals[1]), l.c.copy(f.vertexNormals[2])
            }
            d = 0;
            for (e = this.faces.length; d < e; d++) f = this.faces[d], f.normal =
                f.__originalFaceNormal, f.vertexNormals = f.__originalVertexNormals
        }, computeTangents: function () {
            var a, b, d, e, f, h, g, k, l, m, n, q, p, r, v, u, x, w = [], z = [];
            d = new THREE.Vector3;
            var F = new THREE.Vector3, B = new THREE.Vector3, H = new THREE.Vector3, E = new THREE.Vector3;
            a = 0;
            for (b = this.vertices.length; a < b; a++) w[a] = new THREE.Vector3, z[a] = new THREE.Vector3;
            a = 0;
            for (b = this.faces.length; a < b; a++) f = this.faces[a], h = this.faceVertexUvs[0][a], e = f.a, x = f.b, f = f.c, g = this.vertices[e], k = this.vertices[x], l = this.vertices[f], m = h[0], n = h[1], q = h[2],
                h = k.x - g.x, p = l.x - g.x, r = k.y - g.y, v = l.y - g.y, k = k.z - g.z, g = l.z - g.z, l = n.x - m.x, u = q.x - m.x, n = n.y - m.y, m = q.y - m.y, q = 1 / (l * m - u * n), d.set((m * h - n * p) * q, (m * r - n * v) * q, (m * k - n * g) * q), F.set((l * p - u * h) * q, (l * v - u * r) * q, (l * g - u * k) * q), w[e].add(d), w[x].add(d), w[f].add(d), z[e].add(F), z[x].add(F), z[f].add(F);
            F = ["a", "b", "c", "d"];
            a = 0;
            for (b = this.faces.length; a < b; a++) for (f = this.faces[a], d = 0; d < Math.min(f.vertexNormals.length, 3); d++) E.copy(f.vertexNormals[d]), e = f[F[d]], x = w[e], B.copy(x), B.sub(E.multiplyScalar(E.dot(x))).normalize(), H.crossVectors(f.vertexNormals[d],
                x), e = H.dot(z[e]), e = 0 > e ? -1 : 1, f.vertexTangents[d] = new THREE.Vector4(B.x, B.y, B.z, e);
            this.hasTangents = !0
        }, computeLineDistances: function () {
            for (var a = 0, b = this.vertices, d = 0, e = b.length; d < e; d++) 0 < d && (a += b[d].distanceTo(b[d - 1])), this.lineDistances[d] = a
        }, computeBoundingBox: function () {
            null === this.boundingBox && (this.boundingBox = new THREE.Box3);
            this.boundingBox.setFromPoints(this.vertices)
        }, computeBoundingSphere: function () {
            null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
            this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function (a, b, d) {
            if (!1 === a instanceof THREE.Geometry) console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", a); else {
                var e, f = this.vertices.length, h = this.vertices, g = a.vertices, k = this.faces, l = a.faces,
                    m = this.faceVertexUvs[0];
                a = a.faceVertexUvs[0];
                void 0 === d && (d = 0);
                void 0 !== b && (e = (new THREE.Matrix3).getNormalMatrix(b));
                for (var n = 0, q = g.length; n < q; n++) {
                    var p = g[n].clone();
                    void 0 !== b && p.applyMatrix4(b);
                    h.push(p)
                }
                n = 0;
                for (q = l.length; n < q; n++) {
                    var g = l[n], r, v = g.vertexNormals, u =
                        g.vertexColors, p = new THREE.Face3(g.a + f, g.b + f, g.c + f);
                    p.normal.copy(g.normal);
                    void 0 !== e && p.normal.applyMatrix3(e).normalize();
                    b = 0;
                    for (h = v.length; b < h; b++) r = v[b].clone(), void 0 !== e && r.applyMatrix3(e).normalize(), p.vertexNormals.push(r);
                    p.color.copy(g.color);
                    b = 0;
                    for (h = u.length; b < h; b++) r = u[b], p.vertexColors.push(r.clone());
                    p.materialIndex = g.materialIndex + d;
                    k.push(p)
                }
                n = 0;
                for (q = a.length; n < q; n++) if (d = a[n], e = [], void 0 !== d) {
                    b = 0;
                    for (h = d.length; b < h; b++) e.push(new THREE.Vector2(d[b].x, d[b].y));
                    m.push(e)
                }
            }
        }, mergeVertices: function () {
            var a =
                {}, b = [], d = [], e, f = Math.pow(10, 4), h, g;
            h = 0;
            for (g = this.vertices.length; h < g; h++) e = this.vertices[h], e = Math.round(e.x * f) + "_" + Math.round(e.y * f) + "_" + Math.round(e.z * f), void 0 === a[e] ? (a[e] = h, b.push(this.vertices[h]), d[h] = b.length - 1) : d[h] = d[a[e]];
            a = [];
            h = 0;
            for (g = this.faces.length; h < g; h++) for (f = this.faces[h], f.a = d[f.a], f.b = d[f.b], f.c = d[f.c], f = [f.a, f.b, f.c], e = 0; 3 > e; e++) if (f[e] == f[(e + 1) % 3]) {
                a.push(h);
                break
            }
            for (h = a.length - 1; 0 <= h; h--) for (f = a[h], this.faces.splice(f, 1), d = 0, g = this.faceVertexUvs.length; d < g; d++) this.faceVertexUvs[d].splice(f,
                1);
            h = this.vertices.length - b.length;
            this.vertices = b;
            return h
        }, toJSON: function () {
            function a(a, b, d) {
                return d ? a | 1 << b : a & ~(1 << b)
            }

            function b(a) {
                var b = a.x.toString() + a.y.toString() + a.z.toString();
                if (void 0 !== m[b]) return m[b];
                m[b] = l.length / 3;
                l.push(a.x, a.y, a.z);
                return m[b]
            }

            function d(a) {
                var b = a.r.toString() + a.g.toString() + a.b.toString();
                if (void 0 !== q[b]) return q[b];
                q[b] = n.length;
                n.push(a.getHex());
                return q[b]
            }

            function e(a) {
                var b = a.x.toString() + a.y.toString();
                if (void 0 !== r[b]) return r[b];
                r[b] = p.length / 2;
                p.push(a.x,
                    a.y);
                return r[b]
            }

            var f = {
                metadata: {version: 4, type: "BufferGeometry", generator: "BufferGeometryExporter"},
                uuid: this.uuid,
                type: this.type
            };
            "" !== this.name && (f.name = this.name);
            if (void 0 !== this.parameters) {
                var h = this.parameters, g;
                for (g in h) void 0 !== h[g] && (f[g] = h[g]);
                return f
            }
            h = [];
            for (g = 0; g < this.vertices.length; g++) {
                var k = this.vertices[g];
                h.push(k.x, k.y, k.z)
            }
            var k = [], l = [], m = {}, n = [], q = {}, p = [], r = {};
            for (g = 0; g < this.faces.length; g++) {
                var v = this.faces[g], u = void 0 !== this.faceVertexUvs[0][g], x = 0 < v.normal.length(),
                    w = 0 < v.vertexNormals.length, z = 1 !== v.color.r || 1 !== v.color.g || 1 !== v.color.b,
                    F = 0 < v.vertexColors.length, B = 0, B = a(B, 0, 0), B = a(B, 1, !1), B = a(B, 2, !1),
                    B = a(B, 3, u), B = a(B, 4, x), B = a(B, 5, w), B = a(B, 6, z), B = a(B, 7, F);
                k.push(B);
                k.push(v.a, v.b, v.c);
                u && (u = this.faceVertexUvs[0][g], k.push(e(u[0]), e(u[1]), e(u[2])));
                x && k.push(b(v.normal));
                w && (x = v.vertexNormals, k.push(b(x[0]), b(x[1]), b(x[2])));
                z && k.push(d(v.color));
                F && (v = v.vertexColors, k.push(d(v[0]), d(v[1]), d(v[2])))
            }
            f.data = {};
            f.data.vertices = h;
            f.data.normals = l;
            0 < n.length && (f.data.colors =
                n);
            0 < p.length && (f.data.uvs = [p]);
            f.data.faces = k;
            return f
        }, clone: function () {
            for (var a = new THREE.Geometry, b = this.vertices, d = 0, e = b.length; d < e; d++) a.vertices.push(b[d].clone());
            b = this.faces;
            d = 0;
            for (e = b.length; d < e; d++) a.faces.push(b[d].clone());
            b = this.faceVertexUvs[0];
            d = 0;
            for (e = b.length; d < e; d++) {
                for (var f = b[d], h = [], g = 0, k = f.length; g < k; g++) h.push(new THREE.Vector2(f[g].x, f[g].y));
                a.faceVertexUvs[0].push(h)
            }
            return a
        }, dispose: function () {
            this.dispatchEvent({type: "dispose"})
        }
    };
    THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);
    THREE.GeometryIdCount = 0;
    THREE.Camera = function () {
        THREE.Object3D.call(this);
        this.type = "Camera";
        this.matrixWorldInverse = new THREE.Matrix4;
        this.projectionMatrix = new THREE.Matrix4
    };
    THREE.Camera.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Camera.prototype.getWorldDirection = function () {
        var a = new THREE.Quaternion;
        return function (b) {
            b = b || new THREE.Vector3;
            this.getWorldQuaternion(a);
            return b.set(0, 0, -1).applyQuaternion(a)
        }
    }();
    THREE.Camera.prototype.lookAt = function () {
        var a = new THREE.Matrix4;
        return function (b) {
            a.lookAt(this.position, b, this.up);
            this.quaternion.setFromRotationMatrix(a)
        }
    }();
    THREE.Camera.prototype.clone = function (a) {
        void 0 === a && (a = new THREE.Camera);
        THREE.Object3D.prototype.clone.call(this, a);
        a.matrixWorldInverse.copy(this.matrixWorldInverse);
        a.projectionMatrix.copy(this.projectionMatrix);
        return a
    };
    THREE.CubeCamera = function (a, b, d) {
        THREE.Object3D.call(this);
        this.type = "CubeCamera";
        var e = new THREE.PerspectiveCamera(90, 1, a, b);
        e.up.set(0, -1, 0);
        e.lookAt(new THREE.Vector3(1, 0, 0));
        this.add(e);
        var f = new THREE.PerspectiveCamera(90, 1, a, b);
        f.up.set(0, -1, 0);
        f.lookAt(new THREE.Vector3(-1, 0, 0));
        this.add(f);
        var h = new THREE.PerspectiveCamera(90, 1, a, b);
        h.up.set(0, 0, 1);
        h.lookAt(new THREE.Vector3(0, 1, 0));
        this.add(h);
        var g = new THREE.PerspectiveCamera(90, 1, a, b);
        g.up.set(0, 0, -1);
        g.lookAt(new THREE.Vector3(0, -1, 0));
        this.add(g);
        var k = new THREE.PerspectiveCamera(90, 1, a, b);
        k.up.set(0, -1, 0);
        k.lookAt(new THREE.Vector3(0, 0, 1));
        this.add(k);
        var l = new THREE.PerspectiveCamera(90, 1, a, b);
        l.up.set(0, -1, 0);
        l.lookAt(new THREE.Vector3(0, 0, -1));
        this.add(l);
        this.renderTarget = new THREE.WebGLRenderTargetCube(d, d, {
            format: THREE.RGBFormat,
            magFilter: THREE.LinearFilter,
            minFilter: THREE.LinearFilter
        });
        this.updateCubeMap = function (a, b) {
            var d = this.renderTarget, p = d.generateMipmaps;
            d.generateMipmaps = !1;
            d.activeCubeFace = 0;
            a.render(b, e, d);
            d.activeCubeFace =
                1;
            a.render(b, f, d);
            d.activeCubeFace = 2;
            a.render(b, h, d);
            d.activeCubeFace = 3;
            a.render(b, g, d);
            d.activeCubeFace = 4;
            a.render(b, k, d);
            d.generateMipmaps = p;
            d.activeCubeFace = 5;
            a.render(b, l, d)
        }
    };
    THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype);
    THREE.OrthographicCamera = function (a, b, d, e, f, h) {
        THREE.Camera.call(this);
        this.type = "OrthographicCamera";
        this.zoom = 1;
        this.left = a;
        this.right = b;
        this.top = d;
        this.bottom = e;
        this.near = void 0 !== f ? f : .1;
        this.far = void 0 !== h ? h : 2E3;
        this.updateProjectionMatrix()
    };
    THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype);
    THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {
        var a = (this.right - this.left) / (2 * this.zoom), b = (this.top - this.bottom) / (2 * this.zoom),
            d = (this.right + this.left) / 2, e = (this.top + this.bottom) / 2;
        this.projectionMatrix.makeOrthographic(d - a, d + a, e + b, e - b, this.near, this.far)
    };
    THREE.OrthographicCamera.prototype.clone = function () {
        var a = new THREE.OrthographicCamera;
        THREE.Camera.prototype.clone.call(this, a);
        a.zoom = this.zoom;
        a.left = this.left;
        a.right = this.right;
        a.top = this.top;
        a.bottom = this.bottom;
        a.near = this.near;
        a.far = this.far;
        a.projectionMatrix.copy(this.projectionMatrix);
        return a
    };
    THREE.PerspectiveCamera = function (a, b, d, e) {
        THREE.Camera.call(this);
        this.type = "PerspectiveCamera";
        this.zoom = 1;
        this.fov = void 0 !== a ? a : 50;
        this.aspect = void 0 !== b ? b : 1;
        this.near = void 0 !== d ? d : .1;
        this.far = void 0 !== e ? e : 2E3;
        this.updateProjectionMatrix()
    };
    THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);
    THREE.PerspectiveCamera.prototype.setLens = function (a, b) {
        void 0 === b && (b = 24);
        this.fov = 2 * THREE.Math.radToDeg(Math.atan(b / (2 * a)));
        this.updateProjectionMatrix()
    };
    THREE.PerspectiveCamera.prototype.setViewOffset = function (a, b, d, e, f, h) {
        this.fullWidth = a;
        this.fullHeight = b;
        this.x = d;
        this.y = e;
        this.width = f;
        this.height = h;
        this.updateProjectionMatrix()
    };
    THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {
        var a = THREE.Math.radToDeg(2 * Math.atan(Math.tan(.5 * THREE.Math.degToRad(this.fov)) / this.zoom));
        if (this.fullWidth) {
            var b = this.fullWidth / this.fullHeight, a = Math.tan(THREE.Math.degToRad(.5 * a)) * this.near, d = -a,
                e = b * d, b = Math.abs(b * a - e), d = Math.abs(a - d);
            this.projectionMatrix.makeFrustum(e + this.x * b / this.fullWidth, e + (this.x + this.width) * b / this.fullWidth, a - (this.y + this.height) * d / this.fullHeight, a - this.y * d / this.fullHeight, this.near, this.far)
        } else this.projectionMatrix.makePerspective(a,
            this.aspect, this.near, this.far)
    };
    THREE.PerspectiveCamera.prototype.clone = function () {
        var a = new THREE.PerspectiveCamera;
        THREE.Camera.prototype.clone.call(this, a);
        a.zoom = this.zoom;
        a.fov = this.fov;
        a.aspect = this.aspect;
        a.near = this.near;
        a.far = this.far;
        a.projectionMatrix.copy(this.projectionMatrix);
        return a
    };
    THREE.Light = function (a) {
        THREE.Object3D.call(this);
        this.type = "Light";
        this.color = new THREE.Color(a)
    };
    THREE.Light.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Light.prototype.clone = function (a) {
        void 0 === a && (a = new THREE.Light);
        THREE.Object3D.prototype.clone.call(this, a);
        a.color.copy(this.color);
        return a
    };
    THREE.AmbientLight = function (a) {
        THREE.Light.call(this, a);
        this.type = "AmbientLight"
    };
    THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);
    THREE.AmbientLight.prototype.clone = function () {
        var a = new THREE.AmbientLight;
        THREE.Light.prototype.clone.call(this, a);
        return a
    };
    THREE.AreaLight = function (a, b) {
        THREE.Light.call(this, a);
        this.type = "AreaLight";
        this.normal = new THREE.Vector3(0, -1, 0);
        this.right = new THREE.Vector3(1, 0, 0);
        this.intensity = void 0 !== b ? b : 1;
        this.height = this.width = 1;
        this.constantAttenuation = 1.5;
        this.linearAttenuation = .5;
        this.quadraticAttenuation = .1
    };
    THREE.AreaLight.prototype = Object.create(THREE.Light.prototype);
    THREE.DirectionalLight = function (a, b) {
        THREE.Light.call(this, a);
        this.type = "DirectionalLight";
        this.position.set(0, 1, 0);
        this.target = new THREE.Object3D;
        this.intensity = void 0 !== b ? b : 1;
        this.onlyShadow = this.castShadow = !1;
        this.shadowCameraNear = 50;
        this.shadowCameraFar = 5E3;
        this.shadowCameraLeft = -500;
        this.shadowCameraTop = this.shadowCameraRight = 500;
        this.shadowCameraBottom = -500;
        this.shadowCameraVisible = !1;
        this.shadowBias = 0;
        this.shadowDarkness = .5;
        this.shadowMapHeight = this.shadowMapWidth = 512;
        this.shadowCascade = !1;
        this.shadowCascadeOffset = new THREE.Vector3(0, 0, -1E3);
        this.shadowCascadeCount = 2;
        this.shadowCascadeBias = [0, 0, 0];
        this.shadowCascadeWidth = [512, 512, 512];
        this.shadowCascadeHeight = [512, 512, 512];
        this.shadowCascadeNearZ = [-1, .99, .998];
        this.shadowCascadeFarZ = [.99, .998, 1];
        this.shadowCascadeArray = [];
        this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null
    };
    THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);
    THREE.DirectionalLight.prototype.clone = function () {
        var a = new THREE.DirectionalLight;
        THREE.Light.prototype.clone.call(this, a);
        a.target = this.target.clone();
        a.intensity = this.intensity;
        a.castShadow = this.castShadow;
        a.onlyShadow = this.onlyShadow;
        a.shadowCameraNear = this.shadowCameraNear;
        a.shadowCameraFar = this.shadowCameraFar;
        a.shadowCameraLeft = this.shadowCameraLeft;
        a.shadowCameraRight = this.shadowCameraRight;
        a.shadowCameraTop = this.shadowCameraTop;
        a.shadowCameraBottom = this.shadowCameraBottom;
        a.shadowCameraVisible =
            this.shadowCameraVisible;
        a.shadowBias = this.shadowBias;
        a.shadowDarkness = this.shadowDarkness;
        a.shadowMapWidth = this.shadowMapWidth;
        a.shadowMapHeight = this.shadowMapHeight;
        a.shadowCascade = this.shadowCascade;
        a.shadowCascadeOffset.copy(this.shadowCascadeOffset);
        a.shadowCascadeCount = this.shadowCascadeCount;
        a.shadowCascadeBias = this.shadowCascadeBias.slice(0);
        a.shadowCascadeWidth = this.shadowCascadeWidth.slice(0);
        a.shadowCascadeHeight = this.shadowCascadeHeight.slice(0);
        a.shadowCascadeNearZ = this.shadowCascadeNearZ.slice(0);
        a.shadowCascadeFarZ = this.shadowCascadeFarZ.slice(0);
        return a
    };
    THREE.HemisphereLight = function (a, b, d) {
        THREE.Light.call(this, a);
        this.type = "HemisphereLight";
        this.position.set(0, 100, 0);
        this.groundColor = new THREE.Color(b);
        this.intensity = void 0 !== d ? d : 1
    };
    THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype);
    THREE.HemisphereLight.prototype.clone = function () {
        var a = new THREE.HemisphereLight;
        THREE.Light.prototype.clone.call(this, a);
        a.groundColor.copy(this.groundColor);
        a.intensity = this.intensity;
        return a
    };
    THREE.PointLight = function (a, b, d) {
        THREE.Light.call(this, a);
        this.type = "PointLight";
        this.intensity = void 0 !== b ? b : 1;
        this.distance = void 0 !== d ? d : 0
    };
    THREE.PointLight.prototype = Object.create(THREE.Light.prototype);
    THREE.PointLight.prototype.clone = function () {
        var a = new THREE.PointLight;
        THREE.Light.prototype.clone.call(this, a);
        a.intensity = this.intensity;
        a.distance = this.distance;
        return a
    };
    THREE.SpotLight = function (a, b, d, e, f) {
        THREE.Light.call(this, a);
        this.type = "SpotLight";
        this.position.set(0, 1, 0);
        this.target = new THREE.Object3D;
        this.intensity = void 0 !== b ? b : 1;
        this.distance = void 0 !== d ? d : 0;
        this.angle = void 0 !== e ? e : Math.PI / 3;
        this.exponent = void 0 !== f ? f : 10;
        this.onlyShadow = this.castShadow = !1;
        this.shadowCameraNear = 50;
        this.shadowCameraFar = 5E3;
        this.shadowCameraFov = 50;
        this.shadowCameraVisible = !1;
        this.shadowBias = 0;
        this.shadowDarkness = .5;
        this.shadowMapHeight = this.shadowMapWidth = 512;
        this.shadowMatrix =
            this.shadowCamera = this.shadowMapSize = this.shadowMap = null
    };
    THREE.SpotLight.prototype = Object.create(THREE.Light.prototype);
    THREE.SpotLight.prototype.clone = function () {
        var a = new THREE.SpotLight;
        THREE.Light.prototype.clone.call(this, a);
        a.target = this.target.clone();
        a.intensity = this.intensity;
        a.distance = this.distance;
        a.angle = this.angle;
        a.exponent = this.exponent;
        a.castShadow = this.castShadow;
        a.onlyShadow = this.onlyShadow;
        a.shadowCameraNear = this.shadowCameraNear;
        a.shadowCameraFar = this.shadowCameraFar;
        a.shadowCameraFov = this.shadowCameraFov;
        a.shadowCameraVisible = this.shadowCameraVisible;
        a.shadowBias = this.shadowBias;
        a.shadowDarkness =
            this.shadowDarkness;
        a.shadowMapWidth = this.shadowMapWidth;
        a.shadowMapHeight = this.shadowMapHeight;
        return a
    };
    THREE.Cache = function () {
        this.files = {}
    };
    THREE.Cache.prototype = {
        constructor: THREE.Cache, add: function (a, b) {
            this.files[a] = b
        }, get: function (a) {
            return this.files[a]
        }, remove: function (a) {
            delete this.files[a]
        }, clear: function () {
            this.files = {}
        }
    };
    THREE.Loader = function (a) {
        this.statusDomElement = (this.showStatus = a) ? THREE.Loader.prototype.addStatusElement() : null;
        this.imageLoader = new THREE.ImageLoader;
        this.onLoadStart = function () {
        };
        this.onLoadProgress = function () {
        };
        this.onLoadComplete = function () {
        }
    };
    THREE.Loader.prototype = {
        constructor: THREE.Loader, crossOrigin: void 0, addStatusElement: function () {
            var a = document.createElement("div");
            a.style.position = "absolute";
            a.style.right = "0px";
            a.style.top = "0px";
            a.style.fontSize = "0.8em";
            a.style.textAlign = "left";
            a.style.background = "rgba(0,0,0,0.25)";
            a.style.color = "#fff";
            a.style.width = "120px";
            a.style.padding = "0.5em 0.5em 0.5em 0.5em";
            a.style.zIndex = 1E3;
            a.innerHTML = "Loading ...";
            return a
        }, updateProgress: function (a) {
            var b = "Loaded ", b = a.total ? b + ((100 * a.loaded / a.total).toFixed(0) +
                "%") : b + ((a.loaded / 1024).toFixed(2) + " KB");
            this.statusDomElement.innerHTML = b
        }, extractUrlBase: function (a) {
            a = a.split("/");
            if (1 === a.length) return "./";
            a.pop();
            return a.join("/") + "/"
        }, initMaterials: function (a, b) {
            for (var d = [], e = 0; e < a.length; ++e) d[e] = this.createMaterial(a[e], b);
            return d
        }, needsTangents: function (a) {
            for (var b = 0, d = a.length; b < d; b++) if (a[b] instanceof THREE.ShaderMaterial) return !0;
            return !1
        }, createMaterial: function (a, b) {
            function d(a) {
                a = Math.log(a) / Math.LN2;
                return Math.pow(2, Math.round(a))
            }

            function e(a,
                       e, g, f, k, l, u) {
                var x = b + g, w, z = THREE.Loader.Handlers.get(x);
                null !== z ? w = z.load(x) : (w = new THREE.Texture, z = h.imageLoader, z.crossOrigin = h.crossOrigin, w._loadingimage = z.load(x, function (a) {
                    w._loadingimage = null;
                    if (!1 === THREE.Math.isPowerOfTwo(a.width) || !1 === THREE.Math.isPowerOfTwo(a.height)) {
                        var b = d(a.width), e = d(a.height), h = document.createElement("canvas");
                        h.width = b;
                        h.height = e;
                        h.getContext("2d").drawImage(a, 0, 0, b, e);
                        w.image = h
                    } else w.image = a;
                    w.needsUpdate = !0
                }, void 0, function (a) {
                    w._loadingimage = null
                }));
                w.sourceFile =
                    g;
                f && (w.repeat.set(f[0], f[1]), 1 !== f[0] && (w.wrapS = THREE.RepeatWrapping), 1 !== f[1] && (w.wrapT = THREE.RepeatWrapping));
                k && w.offset.set(k[0], k[1]);
                l && (g = {
                    repeat: THREE.RepeatWrapping,
                    mirror: THREE.MirroredRepeatWrapping
                }, void 0 !== g[l[0]] && (w.wrapS = g[l[0]]), void 0 !== g[l[1]] && (w.wrapT = g[l[1]]));
                u && (w.anisotropy = u);
                a[e] = w
            }

            function f(a) {
                return (255 * a[0] << 16) + (255 * a[1] << 8) + 255 * a[2]
            }

            var h = this, g = "MeshLambertMaterial", k = {
                color: 15658734,
                opacity: 1,
                map: null,
                lightMap: null,
                normalMap: null,
                bumpMap: null,
                wireframe: !1
            };
            if (a.shading) {
                var l =
                    a.shading.toLowerCase();
                "phong" === l ? g = "MeshPhongMaterial" : "basic" === l && (g = "MeshBasicMaterial")
            }
            void 0 !== a.blending && void 0 !== THREE[a.blending] && (k.blending = THREE[a.blending]);
            if (void 0 !== a.transparent || 1 > a.opacity) k.transparent = a.transparent;
            void 0 !== a.depthTest && (k.depthTest = a.depthTest);
            void 0 !== a.depthWrite && (k.depthWrite = a.depthWrite);
            void 0 !== a.visible && (k.visible = a.visible);
            void 0 !== a.flipSided && (k.side = THREE.BackSide);
            void 0 !== a.doubleSided && (k.side = THREE.DoubleSide);
            void 0 !== a.wireframe &&
            (k.wireframe = a.wireframe);
            void 0 !== a.vertexColors && ("face" === a.vertexColors ? k.vertexColors = THREE.FaceColors : a.vertexColors && (k.vertexColors = THREE.VertexColors));
            a.colorDiffuse ? k.color = f(a.colorDiffuse) : a.DbgColor && (k.color = a.DbgColor);
            a.colorSpecular && (k.specular = f(a.colorSpecular));
            a.colorAmbient && (k.ambient = f(a.colorAmbient));
            a.colorEmissive && (k.emissive = f(a.colorEmissive));
            a.transparency && (k.opacity = a.transparency);
            a.specularCoef && (k.shininess = a.specularCoef);
            a.mapDiffuse && b && e(k, "map", a.mapDiffuse,
                a.mapDiffuseRepeat, a.mapDiffuseOffset, a.mapDiffuseWrap, a.mapDiffuseAnisotropy);
            a.mapLight && b && e(k, "lightMap", a.mapLight, a.mapLightRepeat, a.mapLightOffset, a.mapLightWrap, a.mapLightAnisotropy);
            a.mapBump && b && e(k, "bumpMap", a.mapBump, a.mapBumpRepeat, a.mapBumpOffset, a.mapBumpWrap, a.mapBumpAnisotropy);
            a.mapNormal && b && e(k, "normalMap", a.mapNormal, a.mapNormalRepeat, a.mapNormalOffset, a.mapNormalWrap, a.mapNormalAnisotropy);
            a.mapSpecular && b && e(k, "specularMap", a.mapSpecular, a.mapSpecularRepeat, a.mapSpecularOffset,
                a.mapSpecularWrap, a.mapSpecularAnisotropy);
            a.mapAlpha && b && e(k, "alphaMap", a.mapAlpha, a.mapAlphaRepeat, a.mapAlphaOffset, a.mapAlphaWrap, a.mapAlphaAnisotropy);
            a.mapBumpScale && (k.bumpScale = a.mapBumpScale);
            a.mapNormal ? (g = THREE.ShaderLib.normalmap, l = THREE.UniformsUtils.clone(g.uniforms), l.tNormal.value = k.normalMap, a.mapNormalFactor && l.uNormalScale.value.set(a.mapNormalFactor, a.mapNormalFactor), k.map && (l.tDiffuse.value = k.map, l.enableDiffuse.value = !0), k.specularMap && (l.tSpecular.value = k.specularMap, l.enableSpecular.value =
                !0), k.lightMap && (l.tAO.value = k.lightMap, l.enableAO.value = !0), l.diffuse.value.setHex(k.color), l.specular.value.setHex(k.specular), l.ambient.value.setHex(k.ambient), l.shininess.value = k.shininess, void 0 !== k.opacity && (l.opacity.value = k.opacity), g = new THREE.ShaderMaterial({
                fragmentShader: g.fragmentShader,
                vertexShader: g.vertexShader,
                uniforms: l,
                lights: !0,
                fog: !0
            }), k.transparent && (g.transparent = !0)) : g = new THREE[g](k);
            void 0 !== a.DbgName && (g.name = a.DbgName);
            return g
        }
    };
    THREE.Loader.Handlers = {
        handlers: [], add: function (a, b) {
            this.handlers.push(a, b)
        }, get: function (a) {
            for (var b = 0, d = this.handlers.length; b < d; b += 2) {
                var e = this.handlers[b + 1];
                if (this.handlers[b].test(a)) return e
            }
            return null
        }
    };
    THREE.XHRLoader = function (a) {
        this.cache = new THREE.Cache;
        this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
    };
    THREE.XHRLoader.prototype = {
        constructor: THREE.XHRLoader, load: function (a, b, d, e) {
            var f = this, h = f.cache.get(a);
            void 0 !== h ? b && b(h) : (h = new XMLHttpRequest, h.open("GET", a, !0), h.addEventListener("load", function (d) {
                f.cache.add(a, this.response);
                b && b(this.response);
                f.manager.itemEnd(a)
            }, !1), void 0 !== d && h.addEventListener("progress", function (a) {
                d(a)
            }, !1), void 0 !== e && h.addEventListener("error", function (a) {
                e(a)
            }, !1), void 0 !== this.crossOrigin && (h.crossOrigin = this.crossOrigin), void 0 !== this.responseType && (h.responseType =
                this.responseType), h.send(null), f.manager.itemStart(a))
        }, setResponseType: function (a) {
            this.responseType = a
        }, setCrossOrigin: function (a) {
            this.crossOrigin = a
        }
    };
    THREE.ImageLoader = function (a) {
        this.cache = new THREE.Cache;
        this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
    };
    THREE.ImageLoader.prototype = {
        constructor: THREE.ImageLoader, load: function (a, b, d, e) {
            var f = this, h = f.cache.get(a);
            if (void 0 !== h) b(h); else return h = document.createElement("img"), void 0 !== b && h.addEventListener("load", function (d) {
                f.cache.add(a, this);
                b(this);
                f.manager.itemEnd(a)
            }, !1), void 0 !== d && h.addEventListener("progress", function (a) {
                d(a)
            }, !1), void 0 !== e && h.addEventListener("error", function (a) {
                e(a)
            }, !1), void 0 !== this.crossOrigin && (h.crossOrigin = this.crossOrigin), h.src = a, f.manager.itemStart(a), h
        }, setCrossOrigin: function (a) {
            this.crossOrigin =
                a
        }
    };
    THREE.JSONLoader = function (a) {
        THREE.Loader.call(this, a);
        this.withCredentials = !1
    };
    THREE.JSONLoader.prototype = Object.create(THREE.Loader.prototype);
    THREE.JSONLoader.prototype.load = function (a, b, d) {
        d = d && "string" === typeof d ? d : this.extractUrlBase(a);
        this.onLoadStart();
        this.loadAjaxJSON(this, a, b, d)
    };
    THREE.JSONLoader.prototype.loadAjaxJSON = function (a, b, d, e, f) {
        var h = new XMLHttpRequest, g = 0;
        h.onreadystatechange = function () {
            if (h.readyState === h.DONE) if (200 === h.status || 0 === h.status) {
                if (h.responseText) {
                    var k = JSON.parse(h.responseText);
                    if (void 0 !== k.metadata && "scene" === k.metadata.type) {
                        console.error('THREE.JSONLoader: "' + b + '" seems to be a Scene. Use THREE.SceneLoader instead.');
                        return
                    }
                    k = a.parse(k, e);
                    d(k.geometry, k.materials)
                } else console.error('THREE.JSONLoader: "' + b + '" seems to be unreachable or the file is empty.');
                a.onLoadComplete()
            } else console.error("THREE.JSONLoader: Couldn't load \"" + b + '" (' + h.status + ")"); else h.readyState === h.LOADING ? f && (0 === g && (g = h.getResponseHeader("Content-Length")), f({
                total: g,
                loaded: h.responseText.length
            })) : h.readyState === h.HEADERS_RECEIVED && void 0 !== f && (g = h.getResponseHeader("Content-Length"))
        };
        h.open("GET", b, !0);
        h.withCredentials = this.withCredentials;
        h.send(null)
    };
    THREE.JSONLoader.prototype.parse = function (a, b) {
        var d = new THREE.Geometry, e = void 0 !== a.scale ? 1 / a.scale : 1;
        (function (b) {
            var e, g, k, l, m, n, q, p, r, v, u, x, w, z = a.faces;
            n = a.vertices;
            var F = a.normals, B = a.colors, H = 0;
            if (void 0 !== a.uvs) {
                for (e = 0; e < a.uvs.length; e++) a.uvs[e].length && H++;
                for (e = 0; e < H; e++) d.faceVertexUvs[e] = []
            }
            l = 0;
            for (m = n.length; l < m;) e = new THREE.Vector3, e.x = n[l++] * b, e.y = n[l++] * b, e.z = n[l++] * b, d.vertices.push(e);
            l = 0;
            for (m = z.length; l < m;) if (b = z[l++], r = b & 1, k = b & 2, e = b & 8, q = b & 16, v = b & 32, n = b & 64, b &= 128, r) {
                r = new THREE.Face3(z[l],
                    z[l + 1], z[l + 3]);
                u = new THREE.Face3(z[l + 1], z[l + 2], z[l + 3]);
                l += 4;
                k && (k = z[l++], r.materialIndex = k, u.materialIndex = k);
                k = d.faces.length;
                if (e) for (e = 0; e < H; e++) for (x = a.uvs[e], d.faceVertexUvs[e][k] = [], d.faceVertexUvs[e][k + 1] = [], g = 0; 4 > g; g++) p = z[l++], w = x[2 * p], p = x[2 * p + 1], w = new THREE.Vector2(w, p), 2 !== g && d.faceVertexUvs[e][k].push(w), 0 !== g && d.faceVertexUvs[e][k + 1].push(w);
                q && (q = 3 * z[l++], r.normal.set(F[q++], F[q++], F[q]), u.normal.copy(r.normal));
                if (v) for (e = 0; 4 > e; e++) q = 3 * z[l++], v = new THREE.Vector3(F[q++], F[q++], F[q]),
                2 !== e && r.vertexNormals.push(v), 0 !== e && u.vertexNormals.push(v);
                n && (n = z[l++], n = B[n], r.color.setHex(n), u.color.setHex(n));
                if (b) for (e = 0; 4 > e; e++) n = z[l++], n = B[n], 2 !== e && r.vertexColors.push(new THREE.Color(n)), 0 !== e && u.vertexColors.push(new THREE.Color(n));
                d.faces.push(r);
                d.faces.push(u)
            } else {
                r = new THREE.Face3(z[l], z[l + 1], z[l + 2]);
                l += 3;
                k && (k = z[l++], r.materialIndex = k);
                k = d.faces.length;
                if (e) for (e = 0; e < H; e++) for (x = a.uvs[e], d.faceVertexUvs[e][k] = [], g = 0; 3 > g; g++) p = z[l++], w = x[2 * p], p = x[2 * p + 1], w = new THREE.Vector2(w,
                    p), d.faceVertexUvs[e][k].push(w);
                q && (q = 3 * z[l++], r.normal.set(F[q++], F[q++], F[q]));
                if (v) for (e = 0; 3 > e; e++) q = 3 * z[l++], v = new THREE.Vector3(F[q++], F[q++], F[q]), r.vertexNormals.push(v);
                n && (n = z[l++], r.color.setHex(B[n]));
                if (b) for (e = 0; 3 > e; e++) n = z[l++], r.vertexColors.push(new THREE.Color(B[n]));
                d.faces.push(r)
            }
        })(e);
        (function () {
            var b = void 0 !== a.influencesPerVertex ? a.influencesPerVertex : 2;
            if (a.skinWeights) for (var e = 0, g = a.skinWeights.length; e < g; e += b) d.skinWeights.push(new THREE.Vector4(a.skinWeights[e], 1 < b ? a.skinWeights[e +
            1] : 0, 2 < b ? a.skinWeights[e + 2] : 0, 3 < b ? a.skinWeights[e + 3] : 0));
            if (a.skinIndices) for (e = 0, g = a.skinIndices.length; e < g; e += b) d.skinIndices.push(new THREE.Vector4(a.skinIndices[e], 1 < b ? a.skinIndices[e + 1] : 0, 2 < b ? a.skinIndices[e + 2] : 0, 3 < b ? a.skinIndices[e + 3] : 0));
            d.bones = a.bones;
            d.bones && 0 < d.bones.length && (d.skinWeights.length !== d.skinIndices.length || d.skinIndices.length !== d.vertices.length) && console.warn("When skinning, number of vertices (" + d.vertices.length + "), skinIndices (" + d.skinIndices.length + "), and skinWeights (" +
                d.skinWeights.length + ") should match.");
            d.animation = a.animation;
            d.animations = a.animations
        })();
        (function (b) {
            if (void 0 !== a.morphTargets) {
                var e, g, k, l, m, n;
                e = 0;
                for (g = a.morphTargets.length; e < g; e++) for (d.morphTargets[e] = {}, d.morphTargets[e].name = a.morphTargets[e].name, d.morphTargets[e].vertices = [], m = d.morphTargets[e].vertices, n = a.morphTargets[e].vertices, k = 0, l = n.length; k < l; k += 3) {
                    var q = new THREE.Vector3;
                    q.x = n[k] * b;
                    q.y = n[k + 1] * b;
                    q.z = n[k + 2] * b;
                    m.push(q)
                }
            }
            if (void 0 !== a.morphColors) for (e = 0, g = a.morphColors.length; e <
            g; e++) for (d.morphColors[e] = {}, d.morphColors[e].name = a.morphColors[e].name, d.morphColors[e].colors = [], l = d.morphColors[e].colors, m = a.morphColors[e].colors, b = 0, k = m.length; b < k; b += 3) n = new THREE.Color(16755200), n.setRGB(m[b], m[b + 1], m[b + 2]), l.push(n)
        })(e);
        d.computeFaceNormals();
        d.computeBoundingSphere();
        if (void 0 === a.materials || 0 === a.materials.length) return {geometry: d};
        e = this.initMaterials(a.materials, b);
        this.needsTangents(e) && d.computeTangents();
        return {geometry: d, materials: e}
    };
    THREE.LoadingManager = function (a, b, d) {
        var e = this, f = 0, h = 0;
        this.onLoad = a;
        this.onProgress = b;
        this.onError = d;
        this.itemStart = function (a) {
            h++
        };
        this.itemEnd = function (a) {
            f++;
            if (void 0 !== e.onProgress) e.onProgress(a, f, h);
            if (f === h && void 0 !== e.onLoad) e.onLoad()
        }
    };
    THREE.DefaultLoadingManager = new THREE.LoadingManager;
    THREE.BufferGeometryLoader = function (a) {
        this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
    };
    THREE.BufferGeometryLoader.prototype = {
        constructor: THREE.BufferGeometryLoader, load: function (a, b, d, e) {
            var f = this, h = new THREE.XHRLoader;
            h.setCrossOrigin(this.crossOrigin);
            h.load(a, function (a) {
                b(f.parse(JSON.parse(a)))
            }, d, e)
        }, setCrossOrigin: function (a) {
            this.crossOrigin = a
        }, parse: function (a) {
            var b = new THREE.BufferGeometry, d = a.attributes, e;
            for (e in d) {
                var f = d[e], h = new self[f.type](f.array);
                b.addAttribute(e, new THREE.BufferAttribute(h, f.itemSize))
            }
            d = a.offsets;
            void 0 !== d && (b.offsets = JSON.parse(JSON.stringify(d)));
            a = a.boundingSphere;
            void 0 !== a && (d = new THREE.Vector3, void 0 !== a.center && d.fromArray(a.center), b.boundingSphere = new THREE.Sphere(d, a.radius));
            return b
        }
    };
    THREE.MaterialLoader = function (a) {
        this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
    };
    THREE.MaterialLoader.prototype = {
        constructor: THREE.MaterialLoader, load: function (a, b, d, e) {
            var f = this, h = new THREE.XHRLoader;
            h.setCrossOrigin(this.crossOrigin);
            h.load(a, function (a) {
                b(f.parse(JSON.parse(a)))
            }, d, e)
        }, setCrossOrigin: function (a) {
            this.crossOrigin = a
        }, parse: function (a) {
            var b = new THREE[a.type];
            void 0 !== a.color && b.color.setHex(a.color);
            void 0 !== a.ambient && b.ambient.setHex(a.ambient);
            void 0 !== a.emissive && b.emissive.setHex(a.emissive);
            void 0 !== a.specular && b.specular.setHex(a.specular);
            void 0 !== a.shininess &&
            (b.shininess = a.shininess);
            void 0 !== a.uniforms && (b.uniforms = a.uniforms);
            void 0 !== a.vertexShader && (b.vertexShader = a.vertexShader);
            void 0 !== a.fragmentShader && (b.fragmentShader = a.fragmentShader);
            void 0 !== a.vertexColors && (b.vertexColors = a.vertexColors);
            void 0 !== a.shading && (b.shading = a.shading);
            void 0 !== a.blending && (b.blending = a.blending);
            void 0 !== a.side && (b.side = a.side);
            void 0 !== a.opacity && (b.opacity = a.opacity);
            void 0 !== a.transparent && (b.transparent = a.transparent);
            void 0 !== a.wireframe && (b.wireframe = a.wireframe);
            if (void 0 !== a.materials) for (var d = 0, e = a.materials.length; d < e; d++) b.materials.push(this.parse(a.materials[d]));
            return b
        }
    };
    THREE.ObjectLoader = function (a) {
        this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
    };
    THREE.ObjectLoader.prototype = {
        constructor: THREE.ObjectLoader, load: function (a, b, d, e) {
            var f = this, h = new THREE.XHRLoader(f.manager);
            h.setCrossOrigin(this.crossOrigin);
            h.load(a, function (a) {
                b(f.parse(JSON.parse(a)))
            }, d, e)
        }, setCrossOrigin: function (a) {
            this.crossOrigin = a
        }, parse: function (a) {
            var b = this.parseGeometries(a.geometries), d = this.parseMaterials(a.materials);
            return this.parseObject(a.object, b, d)
        }, parseGeometries: function (a) {
            var b = {};
            if (void 0 !== a) for (var d = new THREE.JSONLoader, e = new THREE.BufferGeometryLoader,
                                       f = 0, h = a.length; f < h; f++) {
                var g, k = a[f];
                switch (k.type) {
                    case "PlaneGeometry":
                        g = new THREE.PlaneGeometry(k.width, k.height, k.widthSegments, k.heightSegments);
                        break;
                    case "BoxGeometry":
                    case "CubeGeometry":
                        g = new THREE.BoxGeometry(k.width, k.height, k.depth, k.widthSegments, k.heightSegments, k.depthSegments);
                        break;
                    case "CircleGeometry":
                        g = new THREE.CircleGeometry(k.radius, k.segments);
                        break;
                    case "CylinderGeometry":
                        g = new THREE.CylinderGeometry(k.radiusTop, k.radiusBottom, k.height, k.radialSegments, k.heightSegments, k.openEnded);
                        break;
                    case "SphereGeometry":
                        g = new THREE.SphereGeometry(k.radius, k.widthSegments, k.heightSegments, k.phiStart, k.phiLength, k.thetaStart, k.thetaLength);
                        break;
                    case "IcosahedronGeometry":
                        g = new THREE.IcosahedronGeometry(k.radius, k.detail);
                        break;
                    case "TorusGeometry":
                        g = new THREE.TorusGeometry(k.radius, k.tube, k.radialSegments, k.tubularSegments, k.arc);
                        break;
                    case "TorusKnotGeometry":
                        g = new THREE.TorusKnotGeometry(k.radius, k.tube, k.radialSegments, k.tubularSegments, k.p, k.q, k.heightScale);
                        break;
                    case "BufferGeometry":
                        g =
                            e.parse(k.data);
                        break;
                    case "Geometry":
                        g = d.parse(k.data).geometry
                }
                g.uuid = k.uuid;
                void 0 !== k.name && (g.name = k.name);
                b[k.uuid] = g
            }
            return b
        }, parseMaterials: function (a) {
            var b = {};
            if (void 0 !== a) for (var d = new THREE.MaterialLoader, e = 0, f = a.length; e < f; e++) {
                var h = a[e], g = d.parse(h);
                g.uuid = h.uuid;
                void 0 !== h.name && (g.name = h.name);
                b[h.uuid] = g
            }
            return b
        }, parseObject: function () {
            var a = new THREE.Matrix4;
            return function (b, d, e) {
                var f;
                switch (b.type) {
                    case "Scene":
                        f = new THREE.Scene;
                        break;
                    case "PerspectiveCamera":
                        f = new THREE.PerspectiveCamera(b.fov,
                            b.aspect, b.near, b.far);
                        break;
                    case "OrthographicCamera":
                        f = new THREE.OrthographicCamera(b.left, b.right, b.top, b.bottom, b.near, b.far);
                        break;
                    case "AmbientLight":
                        f = new THREE.AmbientLight(b.color);
                        break;
                    case "DirectionalLight":
                        f = new THREE.DirectionalLight(b.color, b.intensity);
                        break;
                    case "PointLight":
                        f = new THREE.PointLight(b.color, b.intensity, b.distance);
                        break;
                    case "SpotLight":
                        f = new THREE.SpotLight(b.color, b.intensity, b.distance, b.angle, b.exponent);
                        break;
                    case "HemisphereLight":
                        f = new THREE.HemisphereLight(b.color,
                            b.groundColor, b.intensity);
                        break;
                    case "Mesh":
                        f = d[b.geometry];
                        var h = e[b.material];
                        void 0 === f && console.warn("THREE.ObjectLoader: Undefined geometry", b.geometry);
                        void 0 === h && console.warn("THREE.ObjectLoader: Undefined material", b.material);
                        f = new THREE.Mesh(f, h);
                        break;
                    case "Line":
                        f = d[b.geometry];
                        h = e[b.material];
                        void 0 === f && console.warn("THREE.ObjectLoader: Undefined geometry", b.geometry);
                        void 0 === h && console.warn("THREE.ObjectLoader: Undefined material", b.material);
                        f = new THREE.Line(f, h);
                        break;
                    case "Sprite":
                        h =
                            e[b.material];
                        void 0 === h && console.warn("THREE.ObjectLoader: Undefined material", b.material);
                        f = new THREE.Sprite(h);
                        break;
                    case "Group":
                        f = new THREE.Group;
                        break;
                    default:
                        f = new THREE.Object3D
                }
                f.uuid = b.uuid;
                void 0 !== b.name && (f.name = b.name);
                void 0 !== b.matrix ? (a.fromArray(b.matrix), a.decompose(f.position, f.quaternion, f.scale)) : (void 0 !== b.position && f.position.fromArray(b.position), void 0 !== b.rotation && f.rotation.fromArray(b.rotation), void 0 !== b.scale && f.scale.fromArray(b.scale));
                void 0 !== b.visible && (f.visible =
                    b.visible);
                void 0 !== b.userData && (f.userData = b.userData);
                if (void 0 !== b.children) for (var g in b.children) f.add(this.parseObject(b.children[g], d, e));
                return f
            }
        }()
    };
    THREE.TextureLoader = function (a) {
        this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
    };
    THREE.TextureLoader.prototype = {
        constructor: THREE.TextureLoader, load: function (a, b, d, e) {
            var f = new THREE.ImageLoader(this.manager);
            f.setCrossOrigin(this.crossOrigin);
            f.load(a, function (a) {
                a = new THREE.Texture(a);
                a.needsUpdate = !0;
                void 0 !== b && b(a)
            }, d, e)
        }, setCrossOrigin: function (a) {
            this.crossOrigin = a
        }
    };
    THREE.CompressedTextureLoader = function () {
        this._parser = null
    };
    THREE.CompressedTextureLoader.prototype = {
        constructor: THREE.CompressedTextureLoader, load: function (a, b, d) {
            var e = this, f = [], h = new THREE.CompressedTexture;
            h.image = f;
            var g = new THREE.XHRLoader;
            g.setResponseType("arraybuffer");
            if (a instanceof Array) {
                var k = 0;
                d = function (d) {
                    g.load(a[d], function (a) {
                        a = e._parser(a, !0);
                        f[d] = {width: a.width, height: a.height, format: a.format, mipmaps: a.mipmaps};
                        k += 1;
                        6 === k && (1 == a.mipmapCount && (h.minFilter = THREE.LinearFilter), h.format = a.format, h.needsUpdate = !0, b && b(h))
                    })
                };
                for (var l = 0, m =
                    a.length; l < m; ++l) d(l)
            } else g.load(a, function (a) {
                a = e._parser(a, !0);
                if (a.isCubemap) for (var d = a.mipmaps.length / a.mipmapCount, g = 0; g < d; g++) {
                    f[g] = {mipmaps: []};
                    for (var k = 0; k < a.mipmapCount; k++) f[g].mipmaps.push(a.mipmaps[g * a.mipmapCount + k]), f[g].format = a.format, f[g].width = a.width, f[g].height = a.height
                } else h.image.width = a.width, h.image.height = a.height, h.mipmaps = a.mipmaps;
                1 === a.mipmapCount && (h.minFilter = THREE.LinearFilter);
                h.format = a.format;
                h.needsUpdate = !0;
                b && b(h)
            });
            return h
        }
    };
    THREE.Material = function () {
        Object.defineProperty(this, "id", {value: THREE.MaterialIdCount++});
        this.uuid = THREE.Math.generateUUID();
        this.name = "";
        this.type = "Material";
        this.side = THREE.FrontSide;
        this.opacity = 1;
        this.transparent = !1;
        this.blending = THREE.NormalBlending;
        this.blendSrc = THREE.SrcAlphaFactor;
        this.blendDst = THREE.OneMinusSrcAlphaFactor;
        this.blendEquation = THREE.AddEquation;
        this.depthWrite = this.depthTest = !0;
        this.polygonOffset = !1;
        this.overdraw = this.alphaTest = this.polygonOffsetUnits = this.polygonOffsetFactor =
            0;
        this.needsUpdate = this.visible = !0
    };
    THREE.Material.prototype = {
        constructor: THREE.Material, setValues: function (a) {
            if (void 0 !== a) for (var b in a) {
                var d = a[b];
                if (void 0 === d) console.warn("THREE.Material: '" + b + "' parameter is undefined."); else if (b in this) {
                    var e = this[b];
                    e instanceof THREE.Color ? e.set(d) : e instanceof THREE.Vector3 && d instanceof THREE.Vector3 ? e.copy(d) : this[b] = "overdraw" == b ? Number(d) : d
                }
            }
        }, toJSON: function () {
            var a = {
                metadata: {version: 4.2, type: "material", generator: "MaterialExporter"},
                uuid: this.uuid,
                type: this.type
            };
            "" !== this.name &&
            (a.name = this.name);
            this instanceof THREE.MeshBasicMaterial ? (a.color = this.color.getHex(), this.vertexColors !== THREE.NoColors && (a.vertexColors = this.vertexColors), this.blending !== THREE.NormalBlending && (a.blending = this.blending), this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.MeshLambertMaterial ? (a.color = this.color.getHex(), a.ambient = this.ambient.getHex(), a.emissive = this.emissive.getHex(), this.vertexColors !== THREE.NoColors && (a.vertexColors = this.vertexColors), this.blending !== THREE.NormalBlending &&
            (a.blending = this.blending), this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.MeshPhongMaterial ? (a.color = this.color.getHex(), a.ambient = this.ambient.getHex(), a.emissive = this.emissive.getHex(), a.specular = this.specular.getHex(), a.shininess = this.shininess, this.vertexColors !== THREE.NoColors && (a.vertexColors = this.vertexColors), this.blending !== THREE.NormalBlending && (a.blending = this.blending), this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.MeshNormalMaterial ? (this.shading !==
            THREE.FlatShading && (a.shading = this.shading), this.blending !== THREE.NormalBlending && (a.blending = this.blending), this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.MeshDepthMaterial ? (this.blending !== THREE.NormalBlending && (a.blending = this.blending), this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.ShaderMaterial ? (a.uniforms = this.uniforms, a.vertexShader = this.vertexShader, a.fragmentShader = this.fragmentShader) : this instanceof THREE.SpriteMaterial && (a.color = this.color.getHex());
            1 > this.opacity && (a.opacity = this.opacity);
            !1 !== this.transparent && (a.transparent = this.transparent);
            !1 !== this.wireframe && (a.wireframe = this.wireframe);
            return a
        }, clone: function (a) {
            void 0 === a && (a = new THREE.Material);
            a.name = this.name;
            a.side = this.side;
            a.opacity = this.opacity;
            a.transparent = this.transparent;
            a.blending = this.blending;
            a.blendSrc = this.blendSrc;
            a.blendDst = this.blendDst;
            a.blendEquation = this.blendEquation;
            a.depthTest = this.depthTest;
            a.depthWrite = this.depthWrite;
            a.polygonOffset = this.polygonOffset;
            a.polygonOffsetFactor =
                this.polygonOffsetFactor;
            a.polygonOffsetUnits = this.polygonOffsetUnits;
            a.alphaTest = this.alphaTest;
            a.overdraw = this.overdraw;
            a.visible = this.visible;
            return a
        }, dispose: function () {
            this.dispatchEvent({type: "dispose"})
        }
    };
    THREE.EventDispatcher.prototype.apply(THREE.Material.prototype);
    THREE.MaterialIdCount = 0;
    THREE.LineBasicMaterial = function (a) {
        THREE.Material.call(this);
        this.type = "LineBasicMaterial";
        this.color = new THREE.Color(16777215);
        this.linewidth = 1;
        this.linejoin = this.linecap = "round";
        this.vertexColors = THREE.NoColors;
        this.fog = !0;
        this.setValues(a)
    };
    THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.LineBasicMaterial.prototype.clone = function () {
        var a = new THREE.LineBasicMaterial;
        THREE.Material.prototype.clone.call(this, a);
        a.color.copy(this.color);
        a.linewidth = this.linewidth;
        a.linecap = this.linecap;
        a.linejoin = this.linejoin;
        a.vertexColors = this.vertexColors;
        a.fog = this.fog;
        return a
    };
    THREE.LineDashedMaterial = function (a) {
        THREE.Material.call(this);
        this.type = "LineDashedMaterial";
        this.color = new THREE.Color(16777215);
        this.scale = this.linewidth = 1;
        this.dashSize = 3;
        this.gapSize = 1;
        this.vertexColors = !1;
        this.fog = !0;
        this.setValues(a)
    };
    THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.LineDashedMaterial.prototype.clone = function () {
        var a = new THREE.LineDashedMaterial;
        THREE.Material.prototype.clone.call(this, a);
        a.color.copy(this.color);
        a.linewidth = this.linewidth;
        a.scale = this.scale;
        a.dashSize = this.dashSize;
        a.gapSize = this.gapSize;
        a.vertexColors = this.vertexColors;
        a.fog = this.fog;
        return a
    };
    THREE.MeshBasicMaterial = function (a) {
        THREE.Material.call(this);
        this.type = "MeshBasicMaterial";
        this.color = new THREE.Color(16777215);
        this.envMap = this.alphaMap = this.specularMap = this.lightMap = this.map = null;
        this.combine = THREE.MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = .98;
        this.fog = !0;
        this.shading = THREE.SmoothShading;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.wireframeLinejoin = this.wireframeLinecap = "round";
        this.vertexColors = THREE.NoColors;
        this.morphTargets = this.skinning = !1;
        this.setValues(a)
    };
    THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshBasicMaterial.prototype.clone = function () {
        var a = new THREE.MeshBasicMaterial;
        THREE.Material.prototype.clone.call(this, a);
        a.color.copy(this.color);
        a.map = this.map;
        a.lightMap = this.lightMap;
        a.specularMap = this.specularMap;
        a.alphaMap = this.alphaMap;
        a.envMap = this.envMap;
        a.combine = this.combine;
        a.reflectivity = this.reflectivity;
        a.refractionRatio = this.refractionRatio;
        a.fog = this.fog;
        a.shading = this.shading;
        a.wireframe = this.wireframe;
        a.wireframeLinewidth = this.wireframeLinewidth;
        a.wireframeLinecap = this.wireframeLinecap;
        a.wireframeLinejoin = this.wireframeLinejoin;
        a.vertexColors = this.vertexColors;
        a.skinning = this.skinning;
        a.morphTargets = this.morphTargets;
        return a
    };
    THREE.MeshLambertMaterial = function (a) {
        THREE.Material.call(this);
        this.type = "MeshLambertMaterial";
        this.color = new THREE.Color(16777215);
        this.ambient = new THREE.Color(16777215);
        this.emissive = new THREE.Color(0);
        this.wrapAround = !1;
        this.wrapRGB = new THREE.Vector3(1, 1, 1);
        this.envMap = this.alphaMap = this.specularMap = this.lightMap = this.map = null;
        this.combine = THREE.MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = .98;
        this.fog = !0;
        this.shading = THREE.SmoothShading;
        this.wireframe = !1;
        this.wireframeLinewidth =
            1;
        this.wireframeLinejoin = this.wireframeLinecap = "round";
        this.vertexColors = THREE.NoColors;
        this.morphNormals = this.morphTargets = this.skinning = !1;
        this.setValues(a)
    };
    THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshLambertMaterial.prototype.clone = function () {
        var a = new THREE.MeshLambertMaterial;
        THREE.Material.prototype.clone.call(this, a);
        a.color.copy(this.color);
        a.ambient.copy(this.ambient);
        a.emissive.copy(this.emissive);
        a.wrapAround = this.wrapAround;
        a.wrapRGB.copy(this.wrapRGB);
        a.map = this.map;
        a.lightMap = this.lightMap;
        a.specularMap = this.specularMap;
        a.alphaMap = this.alphaMap;
        a.envMap = this.envMap;
        a.combine = this.combine;
        a.reflectivity = this.reflectivity;
        a.refractionRatio = this.refractionRatio;
        a.fog = this.fog;
        a.shading = this.shading;
        a.wireframe = this.wireframe;
        a.wireframeLinewidth = this.wireframeLinewidth;
        a.wireframeLinecap = this.wireframeLinecap;
        a.wireframeLinejoin = this.wireframeLinejoin;
        a.vertexColors = this.vertexColors;
        a.skinning = this.skinning;
        a.morphTargets = this.morphTargets;
        a.morphNormals = this.morphNormals;
        return a
    };
    THREE.MeshPhongMaterial = function (a) {
        THREE.Material.call(this);
        this.type = "MeshPhongMaterial";
        this.color = new THREE.Color(16777215);
        this.ambient = new THREE.Color(16777215);
        this.emissive = new THREE.Color(0);
        this.specular = new THREE.Color(1118481);
        this.shininess = 30;
        this.wrapAround = this.metal = !1;
        this.wrapRGB = new THREE.Vector3(1, 1, 1);
        this.bumpMap = this.lightMap = this.map = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalScale = new THREE.Vector2(1, 1);
        this.envMap = this.alphaMap = this.specularMap = null;
        this.combine =
            THREE.MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = .98;
        this.fog = !0;
        this.shading = THREE.SmoothShading;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.wireframeLinejoin = this.wireframeLinecap = "round";
        this.vertexColors = THREE.NoColors;
        this.morphNormals = this.morphTargets = this.skinning = !1;
        this.setValues(a)
    };
    THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshPhongMaterial.prototype.clone = function () {
        var a = new THREE.MeshPhongMaterial;
        THREE.Material.prototype.clone.call(this, a);
        a.color.copy(this.color);
        a.ambient.copy(this.ambient);
        a.emissive.copy(this.emissive);
        a.specular.copy(this.specular);
        a.shininess = this.shininess;
        a.metal = this.metal;
        a.wrapAround = this.wrapAround;
        a.wrapRGB.copy(this.wrapRGB);
        a.map = this.map;
        a.lightMap = this.lightMap;
        a.bumpMap = this.bumpMap;
        a.bumpScale = this.bumpScale;
        a.normalMap = this.normalMap;
        a.normalScale.copy(this.normalScale);
        a.specularMap = this.specularMap;
        a.alphaMap = this.alphaMap;
        a.envMap = this.envMap;
        a.combine = this.combine;
        a.reflectivity = this.reflectivity;
        a.refractionRatio = this.refractionRatio;
        a.fog = this.fog;
        a.shading = this.shading;
        a.wireframe = this.wireframe;
        a.wireframeLinewidth = this.wireframeLinewidth;
        a.wireframeLinecap = this.wireframeLinecap;
        a.wireframeLinejoin = this.wireframeLinejoin;
        a.vertexColors = this.vertexColors;
        a.skinning = this.skinning;
        a.morphTargets = this.morphTargets;
        a.morphNormals = this.morphNormals;
        return a
    };
    THREE.MeshDepthMaterial = function (a) {
        THREE.Material.call(this);
        this.type = "MeshDepthMaterial";
        this.wireframe = this.morphTargets = !1;
        this.wireframeLinewidth = 1;
        this.setValues(a)
    };
    THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshDepthMaterial.prototype.clone = function () {
        var a = new THREE.MeshDepthMaterial;
        THREE.Material.prototype.clone.call(this, a);
        a.wireframe = this.wireframe;
        a.wireframeLinewidth = this.wireframeLinewidth;
        return a
    };
    THREE.MeshNormalMaterial = function (a) {
        THREE.Material.call(this, a);
        this.type = "MeshNormalMaterial";
        this.shading = THREE.FlatShading;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.morphTargets = !1;
        this.setValues(a)
    };
    THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshNormalMaterial.prototype.clone = function () {
        var a = new THREE.MeshNormalMaterial;
        THREE.Material.prototype.clone.call(this, a);
        a.shading = this.shading;
        a.wireframe = this.wireframe;
        a.wireframeLinewidth = this.wireframeLinewidth;
        return a
    };
    THREE.MeshFaceMaterial = function (a) {
        this.uuid = THREE.Math.generateUUID();
        this.type = "MeshFaceMaterial";
        this.materials = a instanceof Array ? a : []
    };
    THREE.MeshFaceMaterial.prototype = {
        constructor: THREE.MeshFaceMaterial, toJSON: function () {
            for (var a = {
                metadata: {version: 4.2, type: "material", generator: "MaterialExporter"},
                uuid: this.uuid,
                type: this.type,
                materials: []
            }, b = 0, d = this.materials.length; b < d; b++) a.materials.push(this.materials[b].toJSON());
            return a
        }, clone: function () {
            for (var a = new THREE.MeshFaceMaterial, b = 0; b < this.materials.length; b++) a.materials.push(this.materials[b].clone());
            return a
        }
    };
    THREE.PointCloudMaterial = function (a) {
        THREE.Material.call(this);
        this.type = "PointCloudMaterial";
        this.color = new THREE.Color(16777215);
        this.map = null;
        this.size = 1;
        this.sizeAttenuation = !0;
        this.vertexColors = THREE.NoColors;
        this.fog = !0;
        this.setValues(a)
    };
    THREE.PointCloudMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.PointCloudMaterial.prototype.clone = function () {
        var a = new THREE.PointCloudMaterial;
        THREE.Material.prototype.clone.call(this, a);
        a.color.copy(this.color);
        a.map = this.map;
        a.size = this.size;
        a.sizeAttenuation = this.sizeAttenuation;
        a.vertexColors = this.vertexColors;
        a.fog = this.fog;
        return a
    };
    THREE.ParticleBasicMaterial = function (a) {
        console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial.");
        return new THREE.PointCloudMaterial(a)
    };
    THREE.ParticleSystemMaterial = function (a) {
        console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial.");
        return new THREE.PointCloudMaterial(a)
    };
    THREE.ShaderMaterial = function (a) {
        THREE.Material.call(this);
        this.type = "ShaderMaterial";
        this.defines = {};
        this.uniforms = {};
        this.attributes = null;
        this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
        this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
        this.shading = THREE.SmoothShading;
        this.linewidth = 1;
        this.wireframe = !1;
        this.wireframeLinewidth = 1;
        this.lights = this.fog = !1;
        this.vertexColors = THREE.NoColors;
        this.morphNormals =
            this.morphTargets = this.skinning = !1;
        this.defaultAttributeValues = {color: [1, 1, 1], uv: [0, 0], uv2: [0, 0]};
        this.index0AttributeName = void 0;
        this.setValues(a)
    };
    THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.ShaderMaterial.prototype.clone = function () {
        var a = new THREE.ShaderMaterial;
        THREE.Material.prototype.clone.call(this, a);
        a.fragmentShader = this.fragmentShader;
        a.vertexShader = this.vertexShader;
        a.uniforms = THREE.UniformsUtils.clone(this.uniforms);
        a.attributes = this.attributes;
        a.defines = this.defines;
        a.shading = this.shading;
        a.wireframe = this.wireframe;
        a.wireframeLinewidth = this.wireframeLinewidth;
        a.fog = this.fog;
        a.lights = this.lights;
        a.vertexColors = this.vertexColors;
        a.skinning = this.skinning;
        a.morphTargets =
            this.morphTargets;
        a.morphNormals = this.morphNormals;
        return a
    };
    THREE.RawShaderMaterial = function (a) {
        THREE.ShaderMaterial.call(this, a);
        this.type = "RawShaderMaterial"
    };
    THREE.RawShaderMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
    THREE.RawShaderMaterial.prototype.clone = function () {
        var a = new THREE.RawShaderMaterial;
        THREE.ShaderMaterial.prototype.clone.call(this, a);
        return a
    };
    THREE.SpriteMaterial = function (a) {
        THREE.Material.call(this);
        this.type = "SpriteMaterial";
        this.color = new THREE.Color(16777215);
        this.map = null;
        this.rotation = 0;
        this.fog = !1;
        this.setValues(a)
    };
    THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.SpriteMaterial.prototype.clone = function () {
        var a = new THREE.SpriteMaterial;
        THREE.Material.prototype.clone.call(this, a);
        a.color.copy(this.color);
        a.map = this.map;
        a.rotation = this.rotation;
        a.fog = this.fog;
        return a
    };
    THREE.Texture = function (a, b, d, e, f, h, g, k, l) {
        Object.defineProperty(this, "id", {value: THREE.TextureIdCount++});
        this.uuid = THREE.Math.generateUUID();
        this.name = "";
        this.image = void 0 !== a ? a : THREE.Texture.DEFAULT_IMAGE;
        this.mipmaps = [];
        this.mapping = void 0 !== b ? b : THREE.Texture.DEFAULT_MAPPING;
        this.wrapS = void 0 !== d ? d : THREE.ClampToEdgeWrapping;
        this.wrapT = void 0 !== e ? e : THREE.ClampToEdgeWrapping;
        this.magFilter = void 0 !== f ? f : THREE.LinearFilter;
        this.minFilter = void 0 !== h ? h : THREE.LinearMipMapLinearFilter;
        this.anisotropy =
            void 0 !== l ? l : 1;
        this.format = void 0 !== g ? g : THREE.RGBAFormat;
        this.type = void 0 !== k ? k : THREE.UnsignedByteType;
        this.offset = new THREE.Vector2(0, 0);
        this.repeat = new THREE.Vector2(1, 1);
        this.generateMipmaps = !0;
        this.premultiplyAlpha = !1;
        this.flipY = !0;
        this.unpackAlignment = 4;
        this._needsUpdate = !1;
        this.onUpdate = null
    };
    THREE.Texture.DEFAULT_IMAGE = void 0;
    THREE.Texture.DEFAULT_MAPPING = new THREE.UVMapping;
    THREE.Texture.prototype = {
        constructor: THREE.Texture, get needsUpdate() {
            return this._needsUpdate
        }, set needsUpdate(a) {
            !0 === a && this.update();
            this._needsUpdate = a
        }, clone: function (a) {
            void 0 === a && (a = new THREE.Texture);
            a.image = this.image;
            a.mipmaps = this.mipmaps.slice(0);
            a.mapping = this.mapping;
            a.wrapS = this.wrapS;
            a.wrapT = this.wrapT;
            a.magFilter = this.magFilter;
            a.minFilter = this.minFilter;
            a.anisotropy = this.anisotropy;
            a.format = this.format;
            a.type = this.type;
            a.offset.copy(this.offset);
            a.repeat.copy(this.repeat);
            a.generateMipmaps =
                this.generateMipmaps;
            a.premultiplyAlpha = this.premultiplyAlpha;
            a.flipY = this.flipY;
            a.unpackAlignment = this.unpackAlignment;
            return a
        }, update: function () {
            this.dispatchEvent({type: "update"})
        }, dispose: function () {
            this.dispatchEvent({type: "dispose"})
        }
    };
    THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);
    THREE.TextureIdCount = 0;
    THREE.CubeTexture = function (a, b, d, e, f, h, g, k, l) {
        THREE.Texture.call(this, a, b, d, e, f, h, g, k, l);
        this.images = a
    };
    THREE.CubeTexture.prototype = Object.create(THREE.Texture.prototype);
    THREE.CubeTexture.clone = function (a) {
        void 0 === a && (a = new THREE.CubeTexture);
        THREE.Texture.prototype.clone.call(this, a);
        a.images = this.images;
        return a
    };
    THREE.CompressedTexture = function (a, b, d, e, f, h, g, k, l, m, n) {
        THREE.Texture.call(this, null, h, g, k, l, m, e, f, n);
        this.image = {width: b, height: d};
        this.mipmaps = a;
        this.generateMipmaps = this.flipY = !1
    };
    THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype);
    THREE.CompressedTexture.prototype.clone = function () {
        var a = new THREE.CompressedTexture;
        THREE.Texture.prototype.clone.call(this, a);
        return a
    };
    THREE.DataTexture = function (a, b, d, e, f, h, g, k, l, m, n) {
        THREE.Texture.call(this, null, h, g, k, l, m, e, f, n);
        this.image = {data: a, width: b, height: d}
    };
    THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype);
    THREE.DataTexture.prototype.clone = function () {
        var a = new THREE.DataTexture;
        THREE.Texture.prototype.clone.call(this, a);
        return a
    };
    THREE.VideoTexture = function (a, b, d, e, f, h, g, k, l) {
        THREE.Texture.call(this, a, b, d, e, f, h, g, k, l);
        this.generateMipmaps = !1;
        var m = this, n = function () {
            requestAnimationFrame(n);
            a.readyState === a.HAVE_ENOUGH_DATA && (m.needsUpdate = !0)
        };
        n()
    };
    THREE.VideoTexture.prototype = Object.create(THREE.Texture.prototype);
    THREE.Group = function () {
        THREE.Object3D.call(this);
        this.type = "Group"
    };
    THREE.Group.prototype = Object.create(THREE.Object3D.prototype);
    THREE.PointCloud = function (a, b) {
        THREE.Object3D.call(this);
        this.type = "PointCloud";
        this.geometry = void 0 !== a ? a : new THREE.Geometry;
        this.material = void 0 !== b ? b : new THREE.PointCloudMaterial({color: 16777215 * Math.random()});
        this.sortParticles = !1
    };
    THREE.PointCloud.prototype = Object.create(THREE.Object3D.prototype);
    THREE.PointCloud.prototype.raycast = function () {
        var a = new THREE.Matrix4, b = new THREE.Ray;
        return function (d, e) {
            var f = this, h = f.geometry, g = d.params.PointCloud.threshold;
            a.getInverse(this.matrixWorld);
            b.copy(d.ray).applyMatrix4(a);
            if (null === h.boundingBox || !1 !== b.isIntersectionBox(h.boundingBox)) {
                var k = g / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = new THREE.Vector3,
                    g = function (a, g) {
                        var h = b.distanceToPoint(a);
                        if (h < k) {
                            var l = b.closestPointToPoint(a);
                            l.applyMatrix4(f.matrixWorld);
                            var m = d.ray.origin.distanceTo(l);
                            e.push({distance: m, distanceToRay: h, point: l.clone(), index: g, face: null, object: f})
                        }
                    };
                if (h instanceof THREE.BufferGeometry) {
                    var m = h.attributes, n = m.position.array;
                    if (void 0 !== m.index) {
                        var m = m.index.array, q = h.offsets;
                        0 === q.length && (q = [{start: 0, count: m.length, index: 0}]);
                        for (var p = 0, r = q.length; p < r; ++p) for (var v = q[p].start, u = q[p].index, h = v, v = v + q[p].count; h < v; h++) {
                            var x = u + m[h];
                            l.fromArray(n, 3 * x);
                            g(l, x)
                        }
                    } else for (m = n.length / 3, h = 0; h < m; h++) l.set(n[3 * h], n[3 * h + 1], n[3 * h + 2]), g(l, h)
                } else for (l = this.geometry.vertices,
                                h = 0; h < l.length; h++) g(l[h], h)
            }
        }
    }();
    THREE.PointCloud.prototype.clone = function (a) {
        void 0 === a && (a = new THREE.PointCloud(this.geometry, this.material));
        a.sortParticles = this.sortParticles;
        THREE.Object3D.prototype.clone.call(this, a);
        return a
    };
    THREE.ParticleSystem = function (a, b) {
        console.warn("THREE.ParticleSystem has been renamed to THREE.PointCloud.");
        return new THREE.PointCloud(a, b)
    };
    THREE.Line = function (a, b, d) {
        THREE.Object3D.call(this);
        this.type = "Line";
        this.geometry = void 0 !== a ? a : new THREE.Geometry;
        this.material = void 0 !== b ? b : new THREE.LineBasicMaterial({color: 16777215 * Math.random()});
        this.mode = void 0 !== d ? d : THREE.LineStrip
    };
    THREE.LineStrip = 0;
    THREE.LinePieces = 1;
    THREE.Line.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Line.prototype.raycast = function () {
        var a = new THREE.Matrix4, b = new THREE.Ray, d = new THREE.Sphere;
        return function (e, f) {
            var h = e.linePrecision, h = h * h, g = this.geometry;
            null === g.boundingSphere && g.computeBoundingSphere();
            d.copy(g.boundingSphere);
            d.applyMatrix4(this.matrixWorld);
            if (!1 !== e.ray.isIntersectionSphere(d) && (a.getInverse(this.matrixWorld), b.copy(e.ray).applyMatrix4(a), g instanceof THREE.Geometry)) for (var g = g.vertices, k = g.length, l = new THREE.Vector3, m = new THREE.Vector3, n = this.mode === THREE.LineStrip ?
                1 : 2, q = 0; q < k - 1; q += n) if (!(b.distanceSqToSegment(g[q], g[q + 1], m, l) > h)) {
                var p = b.origin.distanceTo(m);
                p < e.near || p > e.far || f.push({
                    distance: p,
                    point: l.clone().applyMatrix4(this.matrixWorld),
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        }
    }();
    THREE.Line.prototype.clone = function (a) {
        void 0 === a && (a = new THREE.Line(this.geometry, this.material, this.mode));
        THREE.Object3D.prototype.clone.call(this, a);
        return a
    };
    THREE.Mesh = function (a, b) {
        THREE.Object3D.call(this);
        this.type = "Mesh";
        this.geometry = void 0 !== a ? a : new THREE.Geometry;
        this.material = void 0 !== b ? b : new THREE.MeshBasicMaterial({color: 16777215 * Math.random()});
        this.updateMorphTargets()
    };
    THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Mesh.prototype.updateMorphTargets = function () {
        if (void 0 !== this.geometry.morphTargets && 0 < this.geometry.morphTargets.length) {
            this.morphTargetBase = -1;
            this.morphTargetForcedOrder = [];
            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};
            for (var a = 0, b = this.geometry.morphTargets.length; a < b; a++) this.morphTargetInfluences.push(0), this.morphTargetDictionary[this.geometry.morphTargets[a].name] = a
        }
    };
    THREE.Mesh.prototype.getMorphTargetIndexByName = function (a) {
        if (void 0 !== this.morphTargetDictionary[a]) return this.morphTargetDictionary[a];
        console.log("THREE.Mesh.getMorphTargetIndexByName: morph target " + a + " does not exist. Returning 0.");
        return 0
    };
    THREE.Mesh.prototype.raycast = function () {
        var a = new THREE.Matrix4, b = new THREE.Ray, d = new THREE.Sphere, e = new THREE.Vector3,
            f = new THREE.Vector3, h = new THREE.Vector3;
        return function (g, k) {
            var l = this.geometry;
            null === l.boundingSphere && l.computeBoundingSphere();
            d.copy(l.boundingSphere);
            d.applyMatrix4(this.matrixWorld);
            if (!1 !== g.ray.isIntersectionSphere(d) && (a.getInverse(this.matrixWorld), b.copy(g.ray).applyMatrix4(a), null === l.boundingBox || !1 !== b.isIntersectionBox(l.boundingBox))) if (l instanceof THREE.BufferGeometry) {
                var m =
                    this.material;
                if (void 0 !== m) {
                    var n = l.attributes, q, p, r = g.precision;
                    if (void 0 !== n.index) {
                        var v = n.index.array, u = n.position.array, x = l.offsets;
                        0 === x.length && (x = [{start: 0, count: v.length, index: 0}]);
                        for (var w = 0, z = x.length; w < z; ++w) for (var n = x[w].start, F = x[w].index, l = n, B = n + x[w].count; l < B; l += 3) {
                            n = F + v[l];
                            q = F + v[l + 1];
                            p = F + v[l + 2];
                            e.fromArray(u, 3 * n);
                            f.fromArray(u, 3 * q);
                            h.fromArray(u, 3 * p);
                            var H = m.side === THREE.BackSide ? b.intersectTriangle(h, f, e, !0) : b.intersectTriangle(e, f, h, m.side !== THREE.DoubleSide);
                            if (null !== H) {
                                H.applyMatrix4(this.matrixWorld);
                                var E = g.ray.origin.distanceTo(H);
                                E < r || E < g.near || E > g.far || k.push({
                                    distance: E,
                                    point: H,
                                    face: new THREE.Face3(n, q, p, THREE.Triangle.normal(e, f, h)),
                                    faceIndex: null,
                                    object: this
                                })
                            }
                        }
                    } else for (u = n.position.array, v = l = 0, B = u.length; l < B; l += 3, v += 9) n = l, q = l + 1, p = l + 2, e.fromArray(u, v), f.fromArray(u, v + 3), h.fromArray(u, v + 6), H = m.side === THREE.BackSide ? b.intersectTriangle(h, f, e, !0) : b.intersectTriangle(e, f, h, m.side !== THREE.DoubleSide), null !== H && (H.applyMatrix4(this.matrixWorld), E = g.ray.origin.distanceTo(H), E < r || E < g.near || E >
                    g.far || k.push({
                        distance: E,
                        point: H,
                        face: new THREE.Face3(n, q, p, THREE.Triangle.normal(e, f, h)),
                        faceIndex: null,
                        object: this
                    }))
                }
            } else if (l instanceof THREE.Geometry) for (v = this.material instanceof THREE.MeshFaceMaterial, u = !0 === v ? this.material.materials : null, r = g.precision, x = l.vertices, w = 0, z = l.faces.length; w < z; w++) if (F = l.faces[w], m = !0 === v ? u[F.materialIndex] : this.material, void 0 !== m) {
                n = x[F.a];
                q = x[F.b];
                p = x[F.c];
                if (!0 === m.morphTargets) {
                    H = l.morphTargets;
                    E = this.morphTargetInfluences;
                    e.set(0, 0, 0);
                    f.set(0, 0, 0);
                    h.set(0,
                        0, 0);
                    for (var B = 0, I = H.length; B < I; B++) {
                        var A = E[B];
                        if (0 !== A) {
                            var N = H[B].vertices;
                            e.x += (N[F.a].x - n.x) * A;
                            e.y += (N[F.a].y - n.y) * A;
                            e.z += (N[F.a].z - n.z) * A;
                            f.x += (N[F.b].x - q.x) * A;
                            f.y += (N[F.b].y - q.y) * A;
                            f.z += (N[F.b].z - q.z) * A;
                            h.x += (N[F.c].x - p.x) * A;
                            h.y += (N[F.c].y - p.y) * A;
                            h.z += (N[F.c].z - p.z) * A
                        }
                    }
                    e.add(n);
                    f.add(q);
                    h.add(p);
                    n = e;
                    q = f;
                    p = h
                }
                H = m.side === THREE.BackSide ? b.intersectTriangle(p, q, n, !0) : b.intersectTriangle(n, q, p, m.side !== THREE.DoubleSide);
                null !== H && (H.applyMatrix4(this.matrixWorld), E = g.ray.origin.distanceTo(H), E < r ||
                E < g.near || E > g.far || k.push({distance: E, point: H, face: F, faceIndex: w, object: this}))
            }
        }
    }();
    THREE.Mesh.prototype.clone = function (a, b) {
        void 0 === a && (a = new THREE.Mesh(this.geometry, this.material));
        THREE.Object3D.prototype.clone.call(this, a, b);
        return a
    };
    THREE.Bone = function (a) {
        THREE.Object3D.call(this);
        this.skin = a
    };
    THREE.Bone.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Skeleton = function (a, b, d) {
        this.useVertexTexture = void 0 !== d ? d : !0;
        this.identityMatrix = new THREE.Matrix4;
        a = a || [];
        this.bones = a.slice(0);
        this.useVertexTexture ? (this.boneTextureHeight = this.boneTextureWidth = a = 256 < this.bones.length ? 64 : 64 < this.bones.length ? 32 : 16 < this.bones.length ? 16 : 8, this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType),
            this.boneTexture.minFilter = THREE.NearestFilter, this.boneTexture.magFilter = THREE.NearestFilter, this.boneTexture.generateMipmaps = !1, this.boneTexture.flipY = !1) : this.boneMatrices = new Float32Array(16 * this.bones.length);
        if (void 0 === b) this.calculateInverses(); else if (this.bones.length === b.length) this.boneInverses = b.slice(0); else for (console.warn("THREE.Skeleton bonInverses is the wrong length."), this.boneInverses = [], b = 0, a = this.bones.length; b < a; b++) this.boneInverses.push(new THREE.Matrix4)
    };
    THREE.Skeleton.prototype.calculateInverses = function () {
        this.boneInverses = [];
        for (var a = 0, b = this.bones.length; a < b; a++) {
            var d = new THREE.Matrix4;
            this.bones[a] && d.getInverse(this.bones[a].matrixWorld);
            this.boneInverses.push(d)
        }
    };
    THREE.Skeleton.prototype.pose = function () {
        for (var a, b = 0, d = this.bones.length; b < d; b++) (a = this.bones[b]) && a.matrixWorld.getInverse(this.boneInverses[b]);
        b = 0;
        for (d = this.bones.length; b < d; b++) if (a = this.bones[b]) a.parent ? (a.matrix.getInverse(a.parent.matrixWorld), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale)
    };
    THREE.Skeleton.prototype.update = function () {
        var a = new THREE.Matrix4;
        return function () {
            for (var b = 0, d = this.bones.length; b < d; b++) a.multiplyMatrices(this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix, this.boneInverses[b]), a.flattenToArrayOffset(this.boneMatrices, 16 * b);
            this.useVertexTexture && (this.boneTexture.needsUpdate = !0)
        }
    }();
    THREE.SkinnedMesh = function (a, b, d) {
        THREE.Mesh.call(this, a, b);
        this.type = "SkinnedMesh";
        this.bindMode = "attached";
        this.bindMatrix = new THREE.Matrix4;
        this.bindMatrixInverse = new THREE.Matrix4;
        a = [];
        if (this.geometry && void 0 !== this.geometry.bones) {
            for (var e, f, h, g, k = 0, l = this.geometry.bones.length; k < l; ++k) e = this.geometry.bones[k], f = e.pos, h = e.rotq, g = e.scl, b = new THREE.Bone(this), a.push(b), b.name = e.name, b.position.set(f[0], f[1], f[2]), b.quaternion.set(h[0], h[1], h[2], h[3]), void 0 !== g ? b.scale.set(g[0], g[1], g[2]) : b.scale.set(1,
                1, 1);
            k = 0;
            for (l = this.geometry.bones.length; k < l; ++k) e = this.geometry.bones[k], -1 !== e.parent ? a[e.parent].add(a[k]) : this.add(a[k])
        }
        this.normalizeSkinWeights();
        this.updateMatrixWorld(!0);
        this.bind(new THREE.Skeleton(a, void 0, d))
    };
    THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype);
    THREE.SkinnedMesh.prototype.bind = function (a, b) {
        this.skeleton = a;
        void 0 === b && (this.updateMatrixWorld(!0), b = this.matrixWorld);
        this.bindMatrix.copy(b);
        this.bindMatrixInverse.getInverse(b)
    };
    THREE.SkinnedMesh.prototype.pose = function () {
        this.skeleton.pose()
    };
    THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {
        if (this.geometry instanceof THREE.Geometry) for (var a = 0; a < this.geometry.skinIndices.length; a++) {
            var b = this.geometry.skinWeights[a], d = 1 / b.lengthManhattan();
            Infinity !== d ? b.multiplyScalar(d) : b.set(1)
        }
    };
    THREE.SkinnedMesh.prototype.updateMatrixWorld = function (a) {
        THREE.Mesh.prototype.updateMatrixWorld.call(this, !0);
        "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh unreckognized bindMode: " + this.bindMode)
    };
    THREE.SkinnedMesh.prototype.clone = function (a) {
        void 0 === a && (a = new THREE.SkinnedMesh(this.geometry, this.material, this.useVertexTexture));
        THREE.Mesh.prototype.clone.call(this, a);
        return a
    };
    THREE.MorphAnimMesh = function (a, b) {
        THREE.Mesh.call(this, a, b);
        this.type = "MorphAnimMesh";
        this.duration = 1E3;
        this.mirroredLoop = !1;
        this.currentKeyframe = this.lastKeyframe = this.time = 0;
        this.direction = 1;
        this.directionBackwards = !1;
        this.setFrameRange(0, this.geometry.morphTargets.length - 1)
    };
    THREE.MorphAnimMesh.prototype = Object.create(THREE.Mesh.prototype);
    THREE.MorphAnimMesh.prototype.setFrameRange = function (a, b) {
        this.startKeyframe = a;
        this.endKeyframe = b;
        this.length = this.endKeyframe - this.startKeyframe + 1
    };
    THREE.MorphAnimMesh.prototype.setDirectionForward = function () {
        this.direction = 1;
        this.directionBackwards = !1
    };
    THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {
        this.direction = -1;
        this.directionBackwards = !0
    };
    THREE.MorphAnimMesh.prototype.parseAnimations = function () {
        var a = this.geometry;
        a.animations || (a.animations = {});
        for (var b, d = a.animations, e = /([a-z]+)_?(\d+)/, f = 0, h = a.morphTargets.length; f < h; f++) {
            var g = a.morphTargets[f].name.match(e);
            if (g && 1 < g.length) {
                g = g[1];
                d[g] || (d[g] = {start: Infinity, end: -Infinity});
                var k = d[g];
                f < k.start && (k.start = f);
                f > k.end && (k.end = f);
                b || (b = g)
            }
        }
        a.firstAnimation = b
    };
    THREE.MorphAnimMesh.prototype.setAnimationLabel = function (a, b, d) {
        this.geometry.animations || (this.geometry.animations = {});
        this.geometry.animations[a] = {start: b, end: d}
    };
    THREE.MorphAnimMesh.prototype.playAnimation = function (a, b) {
        var d = this.geometry.animations[a];
        d ? (this.setFrameRange(d.start, d.end), this.duration = (d.end - d.start) / b * 1E3, this.time = 0) : console.warn("animation[" + a + "] undefined")
    };
    THREE.MorphAnimMesh.prototype.updateAnimation = function (a) {
        var b = this.duration / this.length;
        this.time += this.direction * a;
        if (this.mirroredLoop) {
            if (this.time > this.duration || 0 > this.time) this.direction *= -1, this.time > this.duration && (this.time = this.duration, this.directionBackwards = !0), 0 > this.time && (this.time = 0, this.directionBackwards = !1)
        } else this.time %= this.duration, 0 > this.time && (this.time += this.duration);
        a = this.startKeyframe + THREE.Math.clamp(Math.floor(this.time / b), 0, this.length - 1);
        a !== this.currentKeyframe &&
        (this.morphTargetInfluences[this.lastKeyframe] = 0, this.morphTargetInfluences[this.currentKeyframe] = 1, this.morphTargetInfluences[a] = 0, this.lastKeyframe = this.currentKeyframe, this.currentKeyframe = a);
        b = this.time % b / b;
        this.directionBackwards && (b = 1 - b);
        this.morphTargetInfluences[this.currentKeyframe] = b;
        this.morphTargetInfluences[this.lastKeyframe] = 1 - b
    };
    THREE.MorphAnimMesh.prototype.interpolateTargets = function (a, b, d) {
        for (var e = this.morphTargetInfluences, f = 0, h = e.length; f < h; f++) e[f] = 0;
        -1 < a && (e[a] = 1 - d);
        -1 < b && (e[b] = d)
    };
    THREE.MorphAnimMesh.prototype.clone = function (a) {
        void 0 === a && (a = new THREE.MorphAnimMesh(this.geometry, this.material));
        a.duration = this.duration;
        a.mirroredLoop = this.mirroredLoop;
        a.time = this.time;
        a.lastKeyframe = this.lastKeyframe;
        a.currentKeyframe = this.currentKeyframe;
        a.direction = this.direction;
        a.directionBackwards = this.directionBackwards;
        THREE.Mesh.prototype.clone.call(this, a);
        return a
    };
    THREE.LOD = function () {
        THREE.Object3D.call(this);
        this.objects = []
    };
    THREE.LOD.prototype = Object.create(THREE.Object3D.prototype);
    THREE.LOD.prototype.addLevel = function (a, b) {
        void 0 === b && (b = 0);
        b = Math.abs(b);
        for (var d = 0; d < this.objects.length && !(b < this.objects[d].distance); d++) ;
        this.objects.splice(d, 0, {distance: b, object: a});
        this.add(a)
    };
    THREE.LOD.prototype.getObjectForDistance = function (a) {
        for (var b = 1, d = this.objects.length; b < d && !(a < this.objects[b].distance); b++) ;
        return this.objects[b - 1].object
    };
    THREE.LOD.prototype.raycast = function () {
        var a = new THREE.Vector3;
        return function (b, d) {
            a.setFromMatrixPosition(this.matrixWorld);
            var e = b.ray.origin.distanceTo(a);
            this.getObjectForDistance(e).raycast(b, d)
        }
    }();
    THREE.LOD.prototype.update = function () {
        var a = new THREE.Vector3, b = new THREE.Vector3;
        return function (d) {
            if (1 < this.objects.length) {
                a.setFromMatrixPosition(d.matrixWorld);
                b.setFromMatrixPosition(this.matrixWorld);
                d = a.distanceTo(b);
                this.objects[0].object.visible = !0;
                for (var e = 1, f = this.objects.length; e < f; e++) if (d >= this.objects[e].distance) this.objects[e - 1].object.visible = !1, this.objects[e].object.visible = !0; else break;
                for (; e < f; e++) this.objects[e].object.visible = !1
            }
        }
    }();
    THREE.LOD.prototype.clone = function (a) {
        void 0 === a && (a = new THREE.LOD);
        THREE.Object3D.prototype.clone.call(this, a);
        for (var b = 0, d = this.objects.length; b < d; b++) {
            var e = this.objects[b].object.clone();
            e.visible = 0 === b;
            a.addLevel(e, this.objects[b].distance)
        }
        return a
    };
    THREE.Sprite = function () {
        var a = new Uint16Array([0, 1, 2, 0, 2, 3]),
            b = new Float32Array([-.5, -.5, 0, .5, -.5, 0, .5, .5, 0, -.5, .5, 0]),
            d = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), e = new THREE.BufferGeometry;
        e.addAttribute("index", new THREE.BufferAttribute(a, 1));
        e.addAttribute("position", new THREE.BufferAttribute(b, 3));
        e.addAttribute("uv", new THREE.BufferAttribute(d, 2));
        return function (a) {
            THREE.Object3D.call(this);
            this.type = "Sprite";
            this.geometry = e;
            this.material = void 0 !== a ? a : new THREE.SpriteMaterial
        }
    }();
    THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Sprite.prototype.raycast = function () {
        var a = new THREE.Vector3;
        return function (b, d) {
            a.setFromMatrixPosition(this.matrixWorld);
            var e = b.ray.distanceToPoint(a);
            e > this.scale.x || d.push({distance: e, point: this.position, face: null, object: this})
        }
    }();
    THREE.Sprite.prototype.clone = function (a) {
        void 0 === a && (a = new THREE.Sprite(this.material));
        THREE.Object3D.prototype.clone.call(this, a);
        return a
    };
    THREE.Particle = THREE.Sprite;
    THREE.LensFlare = function (a, b, d, e, f) {
        THREE.Object3D.call(this);
        this.lensFlares = [];
        this.positionScreen = new THREE.Vector3;
        this.customUpdateCallback = void 0;
        void 0 !== a && this.add(a, b, d, e, f)
    };
    THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype);
    THREE.LensFlare.prototype.add = function (a, b, d, e, f, h) {
        void 0 === b && (b = -1);
        void 0 === d && (d = 0);
        void 0 === h && (h = 1);
        void 0 === f && (f = new THREE.Color(16777215));
        void 0 === e && (e = THREE.NormalBlending);
        d = Math.min(d, Math.max(0, d));
        this.lensFlares.push({
            texture: a,
            size: b,
            distance: d,
            x: 0,
            y: 0,
            z: 0,
            scale: 1,
            rotation: 1,
            opacity: h,
            color: f,
            blending: e
        })
    };
    THREE.LensFlare.prototype.updateLensFlares = function () {
        var a, b = this.lensFlares.length, d, e = 2 * -this.positionScreen.x, f = 2 * -this.positionScreen.y;
        for (a = 0; a < b; a++) d = this.lensFlares[a], d.x = this.positionScreen.x + e * d.distance, d.y = this.positionScreen.y + f * d.distance, d.wantedRotation = d.x * Math.PI * .25, d.rotation += .25 * (d.wantedRotation - d.rotation)
    };
    THREE.Scene = function () {
        THREE.Object3D.call(this);
        this.type = "Scene";
        this.overrideMaterial = this.fog = null;
        this.autoUpdate = !0
    };
    THREE.Scene.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Scene.prototype.clone = function (a) {
        void 0 === a && (a = new THREE.Scene);
        THREE.Object3D.prototype.clone.call(this, a);
        null !== this.fog && (a.fog = this.fog.clone());
        null !== this.overrideMaterial && (a.overrideMaterial = this.overrideMaterial.clone());
        a.autoUpdate = this.autoUpdate;
        a.matrixAutoUpdate = this.matrixAutoUpdate;
        return a
    };
    THREE.Fog = function (a, b, d) {
        this.name = "";
        this.color = new THREE.Color(a);
        this.near = void 0 !== b ? b : 1;
        this.far = void 0 !== d ? d : 1E3
    };
    THREE.Fog.prototype.clone = function () {
        return new THREE.Fog(this.color.getHex(), this.near, this.far)
    };
    THREE.FogExp2 = function (a, b) {
        this.name = "";
        this.color = new THREE.Color(a);
        this.density = void 0 !== b ? b : 2.5E-4
    };
    THREE.FogExp2.prototype.clone = function () {
        return new THREE.FogExp2(this.color.getHex(), this.density)
    };
    THREE.ShaderChunk = {};
    THREE.ShaderChunk.alphatest_fragment = "#ifdef ALPHATEST\n\n\tif ( gl_FragColor.a < ALPHATEST ) discard;\n\n#endif\n";
    THREE.ShaderChunk.lights_lambert_vertex = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n\tvLightBack = vec3( 0.0 );\n\n#endif\n\ntransformedNormal = normalize( transformedNormal );\n\n#if MAX_DIR_LIGHTS > 0\n\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n\tvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n\tvec3 dirVector = normalize( lDirection.xyz );\n\n\tfloat dotProduct = dot( transformedNormal, dirVector );\n\tvec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tvec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n\t\t#ifdef WRAP_AROUND\n\n\t\t\tvec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n\t\t#endif\n\n\t#endif\n\n\t#ifdef WRAP_AROUND\n\n\t\tvec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n\t\tdirectionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tdirectionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n\n\t\t#endif\n\n\t#endif\n\n\tvLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tvLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n\n\t#endif\n\n}\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n\tfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n\t\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n\t\tfloat lDistance = 1.0;\n\t\tif ( pointLightDistance[ i ] > 0.0 )\n\t\t\tlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\n\t\tlVector = normalize( lVector );\n\t\tfloat dotProduct = dot( transformedNormal, lVector );\n\n\t\tvec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n\t\t\t#ifdef WRAP_AROUND\n\n\t\t\t\tvec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n\t\t\t#endif\n\n\t\t#endif\n\n\t\t#ifdef WRAP_AROUND\n\n\t\t\tvec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n\t\t\tpointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\tpointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n\n\t\t\t#endif\n\n\t\t#endif\n\n\t\tvLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\n\n\t\t#endif\n\n\t}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\tfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n\t\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\n\n\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\n\n\t\t\tspotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n\t\t\tfloat lDistance = 1.0;\n\t\t\tif ( spotLightDistance[ i ] > 0.0 )\n\t\t\t\tlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n\n\t\t\tlVector = normalize( lVector );\n\n\t\t\tfloat dotProduct = dot( transformedNormal, lVector );\n\t\t\tvec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\tvec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n\t\t\t\t#ifdef WRAP_AROUND\n\n\t\t\t\t\tvec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\t#ifdef WRAP_AROUND\n\n\t\t\t\tvec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n\t\t\t\tspotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n\n\t\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\t\tspotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\tvLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\n\n\t\t\t#endif\n\n\t\t}\n\n\t}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n\t\tvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n\t\tvec3 lVector = normalize( lDirection.xyz );\n\n\t\tfloat dotProduct = dot( transformedNormal, lVector );\n\n\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\t\tfloat hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\n\n\t\tvLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n\t\t#endif\n\n\t}\n\n#endif\n\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\n\n#ifdef DOUBLE_SIDED\n\n\tvLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\n\n#endif";
    THREE.ShaderChunk.map_particle_pars_fragment = "#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif";
    THREE.ShaderChunk.default_vertex = "vec4 mvPosition;\n\n#ifdef USE_SKINNING\n\n\tmvPosition = modelViewMatrix * skinned;\n\n#endif\n\n#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\n\n\tmvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#endif\n\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\n\n\tmvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;";
    THREE.ShaderChunk.map_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n\tvarying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif";
    THREE.ShaderChunk.skinnormal_vertex = "#ifdef USE_SKINNING\n\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n\t#ifdef USE_MORPHNORMALS\n\n\tvec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n\t#else\n\n\tvec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n\t#endif\n\n#endif\n";
    THREE.ShaderChunk.logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth;\n\n\t#endif\n\n\tuniform float logDepthBufFC;\n\n#endif";
    THREE.ShaderChunk.lightmap_pars_vertex = "#ifdef USE_LIGHTMAP\n\n\tvarying vec2 vUv2;\n\n#endif";
    THREE.ShaderChunk.lights_phong_fragment = "vec3 normal = normalize( vNormal );\nvec3 viewPosition = normalize( vViewPosition );\n\n#ifdef DOUBLE_SIDED\n\n\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n\tvec3 pointDiffuse = vec3( 0.0 );\n\tvec3 pointSpecular = vec3( 0.0 );\n\n\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n\t\tfloat lDistance = 1.0;\n\t\tif ( pointLightDistance[ i ] > 0.0 )\n\t\t\tlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\n\t\tlVector = normalize( lVector );\n\n\t\t\t\t// diffuse\n\n\t\tfloat dotProduct = dot( normal, lVector );\n\n\t\t#ifdef WRAP_AROUND\n\n\t\t\tfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\n\t\t\tfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n\t\t\tvec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\n\t\t#else\n\n\t\t\tfloat pointDiffuseWeight = max( dotProduct, 0.0 );\n\n\t\t#endif\n\n\t\tpointDiffuse += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\n\n\t\t\t\t// specular\n\n\t\tvec3 pointHalfVector = normalize( lVector + viewPosition );\n\t\tfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n\t\tfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n\t\tpointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\n\n\t}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\tvec3 spotDiffuse = vec3( 0.0 );\n\tvec3 spotSpecular = vec3( 0.0 );\n\n\tfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n\t\tfloat lDistance = 1.0;\n\t\tif ( spotLightDistance[ i ] > 0.0 )\n\t\t\tlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n\n\t\tlVector = normalize( lVector );\n\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\n\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\n\n\t\t\tspotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n\t\t\t\t\t// diffuse\n\n\t\t\tfloat dotProduct = dot( normal, lVector );\n\n\t\t\t#ifdef WRAP_AROUND\n\n\t\t\t\tfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\n\t\t\t\tfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n\t\t\t\tvec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\n\t\t\t#else\n\n\t\t\t\tfloat spotDiffuseWeight = max( dotProduct, 0.0 );\n\n\t\t\t#endif\n\n\t\t\tspotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\n\n\t\t\t\t\t// specular\n\n\t\t\tvec3 spotHalfVector = normalize( lVector + viewPosition );\n\t\t\tfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n\t\t\tfloat spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\n\t\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n\t\t\tspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\n\n\t\t}\n\n\t}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n\tvec3 dirDiffuse = vec3( 0.0 );\n\tvec3 dirSpecular = vec3( 0.0 );\n\n\tfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n\t\tvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n\t\tvec3 dirVector = normalize( lDirection.xyz );\n\n\t\t\t\t// diffuse\n\n\t\tfloat dotProduct = dot( normal, dirVector );\n\n\t\t#ifdef WRAP_AROUND\n\n\t\t\tfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\n\t\t\tfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n\t\t\tvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\n\t\t#else\n\n\t\t\tfloat dirDiffuseWeight = max( dotProduct, 0.0 );\n\n\t\t#endif\n\n\t\tdirDiffuse += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\n\n\t\t// specular\n\n\t\tvec3 dirHalfVector = normalize( dirVector + viewPosition );\n\t\tfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n\t\tfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\n\t\t/*\n\t\t// fresnel term from skin shader\n\t\tconst float F0 = 0.128;\n\n\t\tfloat base = 1.0 - dot( viewPosition, dirHalfVector );\n\t\tfloat exponential = pow( base, 5.0 );\n\n\t\tfloat fresnel = exponential + F0 * ( 1.0 - exponential );\n\t\t*/\n\n\t\t/*\n\t\t// fresnel term from fresnel shader\n\t\tconst float mFresnelBias = 0.08;\n\t\tconst float mFresnelScale = 0.3;\n\t\tconst float mFresnelPower = 5.0;\n\n\t\tfloat fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\n\t\t*/\n\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n\t\t// \t\tdirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\n\n\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n\t\tdirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\n\n\t}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\tvec3 hemiDiffuse = vec3( 0.0 );\n\tvec3 hemiSpecular = vec3( 0.0 );\n\n\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n\t\tvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n\t\tvec3 lVector = normalize( lDirection.xyz );\n\n\t\t// diffuse\n\n\t\tfloat dotProduct = dot( normal, lVector );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n\t\tvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n\t\themiDiffuse += diffuse * hemiColor;\n\n\t\t// specular (sky light)\n\n\t\tvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n\t\tfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n\t\tfloat hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\n\t\t// specular (ground light)\n\n\t\tvec3 lVectorGround = -lVector;\n\n\t\tvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n\t\tfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n\t\tfloat hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\n\t\tfloat dotProductGround = dot( normal, lVectorGround );\n\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n\t\tvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n\t\tvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n\t\themiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\n\t}\n\n#endif\n\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n\n#if MAX_DIR_LIGHTS > 0\n\n\ttotalDiffuse += dirDiffuse;\n\ttotalSpecular += dirSpecular;\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\ttotalDiffuse += hemiDiffuse;\n\ttotalSpecular += hemiSpecular;\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n\ttotalDiffuse += pointDiffuse;\n\ttotalSpecular += pointSpecular;\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\ttotalDiffuse += spotDiffuse;\n\ttotalSpecular += spotSpecular;\n\n#endif\n\n#ifdef METAL\n\n\tgl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\n\n#else\n\n\tgl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n\n#endif";
    THREE.ShaderChunk.fog_pars_fragment = "#ifdef USE_FOG\n\n\tuniform vec3 fogColor;\n\n\t#ifdef FOG_EXP2\n\n\t\tuniform float fogDensity;\n\n\t#else\n\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n\n#endif";
    THREE.ShaderChunk.morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\n\tvec3 morphedNormal = vec3( 0.0 );\n\n\tmorphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tmorphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tmorphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tmorphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n\tmorphedNormal += normal;\n\n#endif";
    THREE.ShaderChunk.envmap_pars_fragment = "#ifdef USE_ENVMAP\n\n\tuniform float reflectivity;\n\tuniform samplerCube envMap;\n\tuniform float flipEnvMap;\n\tuniform int combine;\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\tuniform bool useRefract;\n\t\tuniform float refractionRatio;\n\n\t#else\n\n\t\tvarying vec3 vReflect;\n\n\t#endif\n\n#endif";
    THREE.ShaderChunk.logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";
    THREE.ShaderChunk.normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\n\t\t\t// Per-Pixel Tangent Space Normal Mapping\n\t\t\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\n\t}\n\n#endif\n";
    THREE.ShaderChunk.lights_phong_pars_vertex = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n\tvarying vec3 vWorldPosition;\n\n#endif\n";
    THREE.ShaderChunk.lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\n\tvarying vec2 vUv2;\n\tuniform sampler2D lightMap;\n\n#endif";
    THREE.ShaderChunk.shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\n\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n\t\tvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n\t}\n\n#endif";
    THREE.ShaderChunk.lights_phong_vertex = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n\tvWorldPosition = worldPosition.xyz;\n\n#endif";
    THREE.ShaderChunk.map_fragment = "#ifdef USE_MAP\n\n\tvec4 texelColor = texture2D( map, vUv );\n\n\t#ifdef GAMMA_INPUT\n\n\t\ttexelColor.xyz *= texelColor.xyz;\n\n\t#endif\n\n\tgl_FragColor = gl_FragColor * texelColor;\n\n#endif";
    THREE.ShaderChunk.lightmap_vertex = "#ifdef USE_LIGHTMAP\n\n\tvUv2 = uv2;\n\n#endif";
    THREE.ShaderChunk.map_particle_fragment = "#ifdef USE_MAP\n\n\tgl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\n\n#endif";
    THREE.ShaderChunk.color_pars_fragment = "#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif\n";
    THREE.ShaderChunk.color_vertex = "#ifdef USE_COLOR\n\n\t#ifdef GAMMA_INPUT\n\n\t\tvColor = color * color;\n\n\t#else\n\n\t\tvColor = color;\n\n\t#endif\n\n#endif";
    THREE.ShaderChunk.skinning_vertex = "#ifdef USE_SKINNING\n\n\t#ifdef USE_MORPHTARGETS\n\n\tvec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n\t#else\n\n\tvec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n\t#endif\n\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n\n#endif\n";
    THREE.ShaderChunk.envmap_pars_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n\tvarying vec3 vReflect;\n\n\tuniform float refractionRatio;\n\tuniform bool useRefract;\n\n#endif\n";
    THREE.ShaderChunk.linear_to_gamma_fragment = "#ifdef GAMMA_OUTPUT\n\n\tgl_FragColor.xyz = sqrt( gl_FragColor.xyz );\n\n#endif";
    THREE.ShaderChunk.color_pars_vertex = "#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif";
    THREE.ShaderChunk.lights_lambert_pars_vertex = "uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 emissive;\n\nuniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#ifdef WRAP_AROUND\n\n\tuniform vec3 wrapRGB;\n\n#endif\n";
    THREE.ShaderChunk.map_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n\n#endif\n";
    THREE.ShaderChunk.envmap_fragment = "#ifdef USE_ENVMAP\n\n\tvec3 reflectVec;\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n\t\t// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\n\t\t// Transforming Normal Vectors with the Inverse Transformation\n\n\t\tvec3 worldNormal = normalize( vec3( vec4( normal, 0.0 ) * viewMatrix ) );\n\n\t\tif ( useRefract ) {\n\n\t\t\treflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t\t} else { \n\n\t\t\treflectVec = reflect( cameraToVertex, worldNormal );\n\n\t\t}\n\n\t#else\n\n\t\treflectVec = vReflect;\n\n\t#endif\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\t\tvec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n\t#else\n\n\t\tvec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n\t#endif\n\n\t#ifdef GAMMA_INPUT\n\n\t\tcubeColor.xyz *= cubeColor.xyz;\n\n\t#endif\n\n\tif ( combine == 1 ) {\n\n\t\tgl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\n\n\t} else if ( combine == 2 ) {\n\n\t\tgl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\n\n\t} else {\n\n\t\tgl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\n\n\t}\n\n#endif";
    THREE.ShaderChunk.specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\n\tuniform sampler2D specularMap;\n\n#endif";
    THREE.ShaderChunk.logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\n\tgl_Position.z = log2(max(1e-6, gl_Position.w + 1.0)) * logDepthBufFC;\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n\t#endif\n\n#endif";
    THREE.ShaderChunk.morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\n\t#ifndef USE_MORPHNORMALS\n\n\tuniform float morphTargetInfluences[ 8 ];\n\n\t#else\n\n\tuniform float morphTargetInfluences[ 4 ];\n\n\t#endif\n\n#endif";
    THREE.ShaderChunk.specularmap_fragment = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n\n#else\n\n\tspecularStrength = 1.0;\n\n#endif";
    THREE.ShaderChunk.fog_fragment = "#ifdef USE_FOG\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n\t#else\n\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\n\t#endif\n\n\t#ifdef FOG_EXP2\n\n\t\tconst float LOG2 = 1.442695;\n\t\tfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\n\t\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n\n\t#else\n\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\n\t#endif\n\t\n\tgl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n\n#endif";
    THREE.ShaderChunk.bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\n\t\t\t// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n\t\t\t//\thttp://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n\t\t\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n\tvec2 dHdxy_fwd() {\n\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n\t\treturn vec2( dBx, dBy );\n\n\t}\n\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\t\t// normalized\n\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\n\t}\n\n#endif";
    THREE.ShaderChunk.defaultnormal_vertex = "vec3 objectNormal;\n\n#ifdef USE_SKINNING\n\n\tobjectNormal = skinnedNormal.xyz;\n\n#endif\n\n#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\n\n\tobjectNormal = morphedNormal;\n\n#endif\n\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\n\n\tobjectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n\tobjectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;";
    THREE.ShaderChunk.lights_phong_pars_fragment = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n\tvarying vec3 vWorldPosition;\n\n#endif\n\n#ifdef WRAP_AROUND\n\n\tuniform vec3 wrapRGB;\n\n#endif\n\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;";
    THREE.ShaderChunk.skinbase_vertex = "#ifdef USE_SKINNING\n\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";
    THREE.ShaderChunk.map_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";
    THREE.ShaderChunk.lightmap_fragment = "#ifdef USE_LIGHTMAP\n\n\tgl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\n\n#endif";
    THREE.ShaderChunk.shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\n\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\n\tuniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif";
    THREE.ShaderChunk.color_fragment = "#ifdef USE_COLOR\n\n\tgl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\n\n#endif";
    THREE.ShaderChunk.morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\n\tvec3 morphed = vec3( 0.0 );\n\tmorphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\tmorphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\tmorphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\tmorphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n\t#ifndef USE_MORPHNORMALS\n\n\tmorphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\tmorphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\tmorphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\tmorphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n\t#endif\n\n\tmorphed += position;\n\n#endif";
    THREE.ShaderChunk.envmap_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n\tvec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\n\tworldNormal = normalize( worldNormal );\n\n\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n\tif ( useRefract ) {\n\n\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t} else {\n\n\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\n\t}\n\n#endif";
    THREE.ShaderChunk.shadowmap_fragment = "#ifdef USE_SHADOWMAP\n\n\t#ifdef SHADOWMAP_DEBUG\n\n\t\tvec3 frustumColors[3];\n\t\tfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n\t\tfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n\t\tfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n\t#endif\n\n\t#ifdef SHADOWMAP_CASCADE\n\n\t\tint inFrustumCount = 0;\n\n\t#endif\n\n\tfloat fDepth;\n\tvec3 shadowColor = vec3( 1.0 );\n\n\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n\t\tvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n\t\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\n\t\t\t\t// if ( all( something, something ) ) using this instead\n\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\n\t\t\t\t// don't shadow pixels outside of light frustum\n\t\t\t\t// use just first frustum (for cascades)\n\t\t\t\t// don't shadow pixels behind far plane of light frustum\n\n\t\t#ifdef SHADOWMAP_CASCADE\n\n\t\t\tinFrustumCount += int( inFrustum );\n\t\t\tbvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n\t\t#else\n\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n\t\t#endif\n\n\t\tbool frustumTest = all( frustumTestVec );\n\n\t\tif ( frustumTest ) {\n\n\t\t\tshadowCoord.z += shadowBias[ i ];\n\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\n\t\t\t\t\t\t// Percentage-close filtering\n\t\t\t\t\t\t// (9 pixel kernel)\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\n\n\t\t\t\tfloat shadow = 0.0;\n\n\t\t/*\n\t\t\t\t\t\t// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n\t\t\t\t\t\t// must enroll loop manually\n\n\t\t\t\tfor ( float y = -1.25; y <= 1.25; y += 1.25 )\n\t\t\t\t\tfor ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n\t\t\t\t\t\tvec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n\t\t\t\t\t\t\t\t// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n\t\t\t\t\t\t\t\t//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n\t\t\t\t\t\tfloat fDepth = unpackDepth( rgbaDepth );\n\n\t\t\t\t\t\tif ( fDepth < shadowCoord.z )\n\t\t\t\t\t\t\tshadow += 1.0;\n\n\t\t\t\t}\n\n\t\t\t\tshadow /= 9.0;\n\n\t\t*/\n\n\t\t\t\tconst float shadowDelta = 1.0 / 9.0;\n\n\t\t\t\tfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n\t\t\t\tfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n\t\t\t\tfloat dx0 = -1.25 * xPixelOffset;\n\t\t\t\tfloat dy0 = -1.25 * yPixelOffset;\n\t\t\t\tfloat dx1 = 1.25 * xPixelOffset;\n\t\t\t\tfloat dy1 = 1.25 * yPixelOffset;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\t\t\t\t// Percentage-close filtering\n\t\t\t\t\t\t// (9 pixel kernel)\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\n\n\t\t\t\tfloat shadow = 0.0;\n\n\t\t\t\tfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n\t\t\t\tfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n\t\t\t\tfloat dx0 = -1.0 * xPixelOffset;\n\t\t\t\tfloat dy0 = -1.0 * yPixelOffset;\n\t\t\t\tfloat dx1 = 1.0 * xPixelOffset;\n\t\t\t\tfloat dy1 = 1.0 * yPixelOffset;\n\n\t\t\t\tmat3 shadowKernel;\n\t\t\t\tmat3 depthKernel;\n\n\t\t\t\tdepthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n\t\t\t\tdepthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n\t\t\t\tdepthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n\t\t\t\tdepthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n\t\t\t\tdepthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n\t\t\t\tdepthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n\t\t\t\tdepthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n\t\t\t\tdepthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n\t\t\t\tdepthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n\t\t\t\tvec3 shadowZ = vec3( shadowCoord.z );\n\t\t\t\tshadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n\t\t\t\tshadowKernel[0] *= vec3(0.25);\n\n\t\t\t\tshadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n\t\t\t\tshadowKernel[1] *= vec3(0.25);\n\n\t\t\t\tshadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n\t\t\t\tshadowKernel[2] *= vec3(0.25);\n\n\t\t\t\tvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n\t\t\t\tshadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n\t\t\t\tshadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n\t\t\t\tvec4 shadowValues;\n\t\t\t\tshadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n\t\t\t\tshadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n\t\t\t\tshadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n\t\t\t\tshadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n\t\t\t\tshadow = dot( shadowValues, vec4( 1.0 ) );\n\n\t\t\t\tshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n\t\t\t#else\n\n\t\t\t\tvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n\t\t\t\tfloat fDepth = unpackDepth( rgbaDepth );\n\n\t\t\t\tif ( fDepth < shadowCoord.z )\n\n\t\t// spot with multiple shadows is darker\n\n\t\t\t\t\tshadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n\t\t// spot with multiple shadows has the same color as single shadow spot\n\n\t\t// \t\t\t\t\tshadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n\t\t\t#endif\n\n\t\t}\n\n\n\t\t#ifdef SHADOWMAP_DEBUG\n\n\t\t\t#ifdef SHADOWMAP_CASCADE\n\n\t\t\t\tif ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\n\n\t\t\t#else\n\n\t\t\t\tif ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\n\n\t\t\t#endif\n\n\t\t#endif\n\n\t}\n\n\t#ifdef GAMMA_OUTPUT\n\n\t\tshadowColor *= shadowColor;\n\n\t#endif\n\n\tgl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\n\n#endif\n";
    THREE.ShaderChunk.worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n\t#ifdef USE_SKINNING\n\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\n\t#endif\n\n\t#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\n\n\t\tvec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n\t#endif\n\n\t#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\n\n\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n\t#endif\n\n#endif";
    THREE.ShaderChunk.shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\n\tuniform sampler2D shadowMap[ MAX_SHADOWS ];\n\tuniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n\tuniform float shadowDarkness[ MAX_SHADOWS ];\n\tuniform float shadowBias[ MAX_SHADOWS ];\n\n\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n\tfloat unpackDepth( const in vec4 rgba_depth ) {\n\n\t\tconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n\t\tfloat depth = dot( rgba_depth, bit_shift );\n\t\treturn depth;\n\n\t}\n\n#endif";
    THREE.ShaderChunk.skinning_pars_vertex = "#ifdef USE_SKINNING\n\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\n\t#ifdef BONE_TEXTURE\n\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\n\t\t\ty = dy * ( y + 0.5 );\n\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\n\t\t\treturn bone;\n\n\t\t}\n\n\t#else\n\n\t\tuniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tmat4 bone = boneGlobalMatrices[ int(i) ];\n\t\t\treturn bone;\n\n\t\t}\n\n\t#endif\n\n#endif\n";
    THREE.ShaderChunk.logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\n\tuniform float logDepthBufFC;\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\t#extension GL_EXT_frag_depth : enable\n\t\tvarying float vFragDepth;\n\n\t#endif\n\n#endif";
    THREE.ShaderChunk.alphamap_fragment = "#ifdef USE_ALPHAMAP\n\n\tgl_FragColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";
    THREE.ShaderChunk.alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\n\tuniform sampler2D alphaMap;\n\n#endif\n";
    THREE.UniformsUtils = {
        merge: function (a) {
            for (var b = {}, d = 0; d < a.length; d++) {
                var e = this.clone(a[d]), f;
                for (f in e) b[f] = e[f]
            }
            return b
        }, clone: function (a) {
            var b = {}, d;
            for (d in a) {
                b[d] = {};
                for (var e in a[d]) {
                    var f = a[d][e];
                    b[d][e] = f instanceof THREE.Color || f instanceof THREE.Vector2 || f instanceof THREE.Vector3 || f instanceof THREE.Vector4 || f instanceof THREE.Matrix4 || f instanceof THREE.Texture ? f.clone() : f instanceof Array ? f.slice() : f
                }
            }
            return b
        }
    };
    THREE.UniformsLib = {
        common: {
            diffuse: {type: "c", value: new THREE.Color(15658734)},
            opacity: {type: "f", value: 1},
            map: {type: "t", value: null},
            offsetRepeat: {type: "v4", value: new THREE.Vector4(0, 0, 1, 1)},
            lightMap: {type: "t", value: null},
            specularMap: {type: "t", value: null},
            alphaMap: {type: "t", value: null},
            envMap: {type: "t", value: null},
            flipEnvMap: {type: "f", value: -1},
            useRefract: {type: "i", value: 0},
            reflectivity: {type: "f", value: 1},
            refractionRatio: {type: "f", value: .98},
            combine: {type: "i", value: 0},
            morphTargetInfluences: {
                type: "f",
                value: 0
            }
        },
        bump: {bumpMap: {type: "t", value: null}, bumpScale: {type: "f", value: 1}},
        normalmap: {normalMap: {type: "t", value: null}, normalScale: {type: "v2", value: new THREE.Vector2(1, 1)}},
        fog: {
            fogDensity: {type: "f", value: 2.5E-4},
            fogNear: {type: "f", value: 1},
            fogFar: {type: "f", value: 2E3},
            fogColor: {type: "c", value: new THREE.Color(16777215)}
        },
        lights: {
            ambientLightColor: {type: "fv", value: []},
            directionalLightDirection: {type: "fv", value: []},
            directionalLightColor: {type: "fv", value: []},
            hemisphereLightDirection: {type: "fv", value: []},
            hemisphereLightSkyColor: {type: "fv", value: []},
            hemisphereLightGroundColor: {type: "fv", value: []},
            pointLightColor: {type: "fv", value: []},
            pointLightPosition: {type: "fv", value: []},
            pointLightDistance: {type: "fv1", value: []},
            spotLightColor: {type: "fv", value: []},
            spotLightPosition: {type: "fv", value: []},
            spotLightDirection: {type: "fv", value: []},
            spotLightDistance: {type: "fv1", value: []},
            spotLightAngleCos: {type: "fv1", value: []},
            spotLightExponent: {type: "fv1", value: []}
        },
        particle: {
            psColor: {type: "c", value: new THREE.Color(15658734)},
            opacity: {type: "f", value: 1},
            size: {type: "f", value: 1},
            scale: {type: "f", value: 1},
            map: {type: "t", value: null},
            fogDensity: {type: "f", value: 2.5E-4},
            fogNear: {type: "f", value: 1},
            fogFar: {type: "f", value: 2E3},
            fogColor: {type: "c", value: new THREE.Color(16777215)}
        },
        shadowmap: {
            shadowMap: {type: "tv", value: []},
            shadowMapSize: {type: "v2v", value: []},
            shadowBias: {type: "fv1", value: []},
            shadowDarkness: {type: "fv1", value: []},
            shadowMatrix: {type: "m4v", value: []}
        }
    };
    THREE.ShaderLib = {
        basic: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.shadowmap]),
            vertexShader: [THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex,
                THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.skinbase_vertex, "\t#ifdef USE_ENVMAP", THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "\t#endif", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
            fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n\tgl_FragColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment,
                THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
        }, lambert: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap,
                {
                    ambient: {type: "c", value: new THREE.Color(16777215)},
                    emissive: {type: "c", value: new THREE.Color(0)},
                    wrapRGB: {type: "v3", value: new THREE.Vector3(1, 1, 1)}
                }]),
            vertexShader: ["#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif", THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_lambert_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex,
                THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex,
                THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_lambert_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
            fragmentShader: ["uniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment,
                THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n\tgl_FragColor = vec4( vec3( 1.0 ), opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, "\t#ifdef DOUBLE_SIDED\n\t\tif ( gl_FrontFacing )\n\t\t\tgl_FragColor.xyz *= vLightFront;\n\t\telse\n\t\t\tgl_FragColor.xyz *= vLightBack;\n\t#else\n\t\tgl_FragColor.xyz *= vLightFront;\n\t#endif",
                THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
        }, phong: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.bump, THREE.UniformsLib.normalmap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
                ambient: {type: "c", value: new THREE.Color(16777215)},
                emissive: {type: "c", value: new THREE.Color(0)},
                specular: {type: "c", value: new THREE.Color(1118481)},
                shininess: {type: "f", value: 30},
                wrapRGB: {type: "v3", value: new THREE.Vector3(1, 1, 1)}
            }]),
            vertexShader: ["#define PHONG\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;", THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_phong_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex,
                THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "\tvNormal = normalize( transformedNormal );", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "\tvViewPosition = -mvPosition.xyz;",
                THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_phong_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
            fragmentShader: ["#define PHONG\nuniform vec3 diffuse;\nuniform float opacity;\nuniform vec3 ambient;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment,
                THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.lights_phong_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.bumpmap_pars_fragment, THREE.ShaderChunk.normalmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n\tgl_FragColor = vec4( vec3( 1.0 ), opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment,
                THREE.ShaderChunk.lights_phong_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
        }, particle_basic: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.particle, THREE.UniformsLib.shadowmap]),
            vertexShader: ["uniform float size;\nuniform float scale;", THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex,
                THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / length( mvPosition.xyz ) );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\tgl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
            fragmentShader: ["uniform vec3 psColor;\nuniform float opacity;",
                THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_particle_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n\tgl_FragColor = vec4( psColor, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_particle_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
        }, dashed: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common,
                THREE.UniformsLib.fog, {
                    scale: {type: "f", value: 1},
                    dashSize: {type: "f", value: 1},
                    totalSize: {type: "f", value: 2}
                }]),
            vertexShader: ["uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;", THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.logdepthbuf_vertex,
                "}"].join("\n"),
            fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tgl_FragColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.fog_fragment,
                "}"].join("\n")
        }, depth: {
            uniforms: {mNear: {type: "f", value: 1}, mFar: {type: "f", value: 2E3}, opacity: {type: "f", value: 1}},
            vertexShader: [THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
            fragmentShader: ["uniform float mNear;\nuniform float mFar;\nuniform float opacity;", THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", THREE.ShaderChunk.logdepthbuf_fragment,
                "\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\tfloat color = 1.0 - smoothstep( mNear, mFar, depth );\n\tgl_FragColor = vec4( vec3( color ), opacity );\n}"].join("\n")
        }, normal: {
            uniforms: {opacity: {type: "f", value: 1}},
            vertexShader: ["varying vec3 vNormal;", THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {\n\tvNormal = normalize( normalMatrix * normal );",
                THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
            fragmentShader: ["uniform float opacity;\nvarying vec3 vNormal;", THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n\tgl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, "}"].join("\n")
        }, normalmap: {
            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
                enableAO: {
                    type: "i",
                    value: 0
                },
                enableDiffuse: {type: "i", value: 0},
                enableSpecular: {type: "i", value: 0},
                enableReflection: {type: "i", value: 0},
                enableDisplacement: {type: "i", value: 0},
                tDisplacement: {type: "t", value: null},
                tDiffuse: {type: "t", value: null},
                tCube: {type: "t", value: null},
                tNormal: {type: "t", value: null},
                tSpecular: {type: "t", value: null},
                tAO: {type: "t", value: null},
                uNormalScale: {type: "v2", value: new THREE.Vector2(1, 1)},
                uDisplacementBias: {type: "f", value: 0},
                uDisplacementScale: {type: "f", value: 1},
                diffuse: {type: "c", value: new THREE.Color(16777215)},
                specular: {type: "c", value: new THREE.Color(1118481)},
                ambient: {type: "c", value: new THREE.Color(16777215)},
                shininess: {type: "f", value: 30},
                opacity: {type: "f", value: 1},
                useRefract: {type: "i", value: 0},
                refractionRatio: {type: "f", value: .98},
                reflectivity: {type: "f", value: .5},
                uOffset: {type: "v2", value: new THREE.Vector2(0, 0)},
                uRepeat: {type: "v2", value: new THREE.Vector2(1, 1)},
                wrapRGB: {type: "v3", value: new THREE.Vector3(1, 1, 1)}
            }]),
            fragmentShader: ["uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\nuniform bool enableDiffuse;\nuniform bool enableSpecular;\nuniform bool enableAO;\nuniform bool enableReflection;\nuniform sampler2D tDiffuse;\nuniform sampler2D tNormal;\nuniform sampler2D tSpecular;\nuniform sampler2D tAO;\nuniform samplerCube tCube;\nuniform vec2 uNormalScale;\nuniform bool useRefract;\nuniform float refractionRatio;\nuniform float reflectivity;\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nuniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef WRAP_AROUND\n\tuniform vec3 wrapRGB;\n#endif\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;",
                THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", THREE.ShaderChunk.logdepthbuf_fragment, "\tgl_FragColor = vec4( vec3( 1.0 ), opacity );\n\tvec3 specularTex = vec3( 1.0 );\n\tvec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\n\tnormalTex.xy *= uNormalScale;\n\tnormalTex = normalize( normalTex );\n\tif( enableDiffuse ) {\n\t\t#ifdef GAMMA_INPUT\n\t\t\tvec4 texelColor = texture2D( tDiffuse, vUv );\n\t\t\ttexelColor.xyz *= texelColor.xyz;\n\t\t\tgl_FragColor = gl_FragColor * texelColor;\n\t\t#else\n\t\t\tgl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );\n\t\t#endif\n\t}\n\tif( enableAO ) {\n\t\t#ifdef GAMMA_INPUT\n\t\t\tvec4 aoColor = texture2D( tAO, vUv );\n\t\t\taoColor.xyz *= aoColor.xyz;\n\t\t\tgl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;\n\t\t#else\n\t\t\tgl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;\n\t\t#endif\n\t}",
                THREE.ShaderChunk.alphatest_fragment, "\tif( enableSpecular )\n\t\tspecularTex = texture2D( tSpecular, vUv ).xyz;\n\tmat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\n\tvec3 finalNormal = tsb * normalTex;\n\t#ifdef FLIP_SIDED\n\t\tfinalNormal = -finalNormal;\n\t#endif\n\tvec3 normal = normalize( finalNormal );\n\tvec3 viewPosition = normalize( vViewPosition );\n\t#if MAX_POINT_LIGHTS > 0\n\t\tvec3 pointDiffuse = vec3( 0.0 );\n\t\tvec3 pointSpecular = vec3( 0.0 );\n\t\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\t\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n\t\t\tvec3 pointVector = lPosition.xyz + vViewPosition.xyz;\n\t\t\tfloat pointDistance = 1.0;\n\t\t\tif ( pointLightDistance[ i ] > 0.0 )\n\t\t\t\tpointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );\n\t\t\tpointVector = normalize( pointVector );\n\t\t\t#ifdef WRAP_AROUND\n\t\t\t\tfloat pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );\n\t\t\t\tfloat pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );\n\t\t\t\tvec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\t\t\t#else\n\t\t\t\tfloat pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\n\t\t\t#endif\n\t\t\tpointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;\n\t\t\tvec3 pointHalfVector = normalize( pointVector + viewPosition );\n\t\t\tfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n\t\t\tfloat pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\t\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( pointVector, pointHalfVector ), 0.0 ), 5.0 );\n\t\t\tpointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;\n\t\t}\n\t#endif\n\t#if MAX_SPOT_LIGHTS > 0\n\t\tvec3 spotDiffuse = vec3( 0.0 );\n\t\tvec3 spotSpecular = vec3( 0.0 );\n\t\tfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\t\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n\t\t\tvec3 spotVector = lPosition.xyz + vViewPosition.xyz;\n\t\t\tfloat spotDistance = 1.0;\n\t\t\tif ( spotLightDistance[ i ] > 0.0 )\n\t\t\t\tspotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );\n\t\t\tspotVector = normalize( spotVector );\n\t\t\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\t\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\n\t\t\t\tspotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\t\t\t\t#ifdef WRAP_AROUND\n\t\t\t\t\tfloat spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );\n\t\t\t\t\tfloat spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );\n\t\t\t\t\tvec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\t\t\t\t#else\n\t\t\t\t\tfloat spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );\n\t\t\t\t#endif\n\t\t\t\tspotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;\n\t\t\t\tvec3 spotHalfVector = normalize( spotVector + viewPosition );\n\t\t\t\tfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n\t\t\t\tfloat spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\t\t\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\t\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( spotVector, spotHalfVector ), 0.0 ), 5.0 );\n\t\t\t\tspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;\n\t\t\t}\n\t\t}\n\t#endif\n\t#if MAX_DIR_LIGHTS > 0\n\t\tvec3 dirDiffuse = vec3( 0.0 );\n\t\tvec3 dirSpecular = vec3( 0.0 );\n\t\tfor( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\n\t\t\tvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n\t\t\tvec3 dirVector = normalize( lDirection.xyz );\n\t\t\t#ifdef WRAP_AROUND\n\t\t\t\tfloat directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );\n\t\t\t\tfloat directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\n\t\t\t\tvec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );\n\t\t\t#else\n\t\t\t\tfloat dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\n\t\t\t#endif\n\t\t\tdirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;\n\t\t\tvec3 dirHalfVector = normalize( dirVector + viewPosition );\n\t\t\tfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n\t\t\tfloat dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\t\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n\t\t\tdirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\t\t}\n\t#endif\n\t#if MAX_HEMI_LIGHTS > 0\n\t\tvec3 hemiDiffuse = vec3( 0.0 );\n\t\tvec3 hemiSpecular = vec3( 0.0 );\n\t\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\t\t\tvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n\t\t\tvec3 lVector = normalize( lDirection.xyz );\n\t\t\tfloat dotProduct = dot( normal, lVector );\n\t\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\t\t\tvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\t\t\themiDiffuse += diffuse * hemiColor;\n\t\t\tvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n\t\t\tfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n\t\t\tfloat hemiSpecularWeightSky = specularTex.r * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\t\t\tvec3 lVectorGround = -lVector;\n\t\t\tvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n\t\t\tfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n\t\t\tfloat hemiSpecularWeightGround = specularTex.r * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\t\t\tfloat dotProductGround = dot( normal, lVectorGround );\n\t\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\t\t\tvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n\t\t\tvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n\t\t\themiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\t\t}\n\t#endif\n\tvec3 totalDiffuse = vec3( 0.0 );\n\tvec3 totalSpecular = vec3( 0.0 );\n\t#if MAX_DIR_LIGHTS > 0\n\t\ttotalDiffuse += dirDiffuse;\n\t\ttotalSpecular += dirSpecular;\n\t#endif\n\t#if MAX_HEMI_LIGHTS > 0\n\t\ttotalDiffuse += hemiDiffuse;\n\t\ttotalSpecular += hemiSpecular;\n\t#endif\n\t#if MAX_POINT_LIGHTS > 0\n\t\ttotalDiffuse += pointDiffuse;\n\t\ttotalSpecular += pointSpecular;\n\t#endif\n\t#if MAX_SPOT_LIGHTS > 0\n\t\ttotalDiffuse += spotDiffuse;\n\t\ttotalSpecular += spotSpecular;\n\t#endif\n\t#ifdef METAL\n\t\tgl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );\n\t#else\n\t\tgl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n\t#endif\n\tif ( enableReflection ) {\n\t\tvec3 vReflect;\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tif ( useRefract ) {\n\t\t\tvReflect = refract( cameraToVertex, normal, refractionRatio );\n\t\t} else {\n\t\t\tvReflect = reflect( cameraToVertex, normal );\n\t\t}\n\t\tvec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\n\t\t#ifdef GAMMA_INPUT\n\t\t\tcubeColor.xyz *= cubeColor.xyz;\n\t\t#endif\n\t\tgl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );\n\t}",
                THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n"),
            vertexShader: ["attribute vec4 tangent;\nuniform vec2 uOffset;\nuniform vec2 uRepeat;\nuniform bool enableDisplacement;\n#ifdef VERTEX_TEXTURES\n\tuniform sampler2D tDisplacement;\n\tuniform float uDisplacementScale;\n\tuniform float uDisplacementBias;\n#endif\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;",
                THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, "\t#ifdef USE_SKINNING\n\t\tvNormal = normalize( normalMatrix * skinnedNormal.xyz );\n\t\tvec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\n\t\tvTangent = normalize( normalMatrix * skinnedTangent.xyz );\n\t#else\n\t\tvNormal = normalize( normalMatrix * normal );\n\t\tvTangent = normalize( normalMatrix * tangent.xyz );\n\t#endif\n\tvBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\n\tvUv = uv * uRepeat + uOffset;\n\tvec3 displacedPosition;\n\t#ifdef VERTEX_TEXTURES\n\t\tif ( enableDisplacement ) {\n\t\t\tvec3 dv = texture2D( tDisplacement, uv ).xyz;\n\t\t\tfloat df = uDisplacementScale * dv.x + uDisplacementBias;\n\t\t\tdisplacedPosition = position + normalize( normal ) * df;\n\t\t} else {\n\t\t\t#ifdef USE_SKINNING\n\t\t\t\tvec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\t\t\t\tvec4 skinned = vec4( 0.0 );\n\t\t\t\tskinned += boneMatX * skinVertex * skinWeight.x;\n\t\t\t\tskinned += boneMatY * skinVertex * skinWeight.y;\n\t\t\t\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\t\t\t\tskinned += boneMatW * skinVertex * skinWeight.w;\n\t\t\t\tskinned  = bindMatrixInverse * skinned;\n\t\t\t\tdisplacedPosition = skinned.xyz;\n\t\t\t#else\n\t\t\t\tdisplacedPosition = position;\n\t\t\t#endif\n\t\t}\n\t#else\n\t\t#ifdef USE_SKINNING\n\t\t\tvec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\t\t\tvec4 skinned = vec4( 0.0 );\n\t\t\tskinned += boneMatX * skinVertex * skinWeight.x;\n\t\t\tskinned += boneMatY * skinVertex * skinWeight.y;\n\t\t\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\t\t\tskinned += boneMatW * skinVertex * skinWeight.w;\n\t\t\tskinned  = bindMatrixInverse * skinned;\n\t\t\tdisplacedPosition = skinned.xyz;\n\t\t#else\n\t\t\tdisplacedPosition = position;\n\t\t#endif\n\t#endif\n\tvec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\n\tvec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;",
                THREE.ShaderChunk.logdepthbuf_vertex, "\tvWorldPosition = worldPosition.xyz;\n\tvViewPosition = -mvPosition.xyz;\n\t#ifdef USE_SHADOWMAP\n\t\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\t\t\tvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\t\t}\n\t#endif\n}"].join("\n")
        }, cube: {
            uniforms: {tCube: {type: "t", value: null}, tFlip: {type: "f", value: -1}},
            vertexShader: ["varying vec3 vWorldPosition;", THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {\n\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\tvWorldPosition = worldPosition.xyz;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
                THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
            fragmentShader: ["uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;", THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );", THREE.ShaderChunk.logdepthbuf_fragment, "}"].join("\n")
        }, depthRGBA: {
            uniforms: {},
            vertexShader: [THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex,
                "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
            fragmentShader: [THREE.ShaderChunk.logdepthbuf_pars_fragment, "vec4 pack_depth( const in float depth ) {\n\tconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n\tconst vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n\tvec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\nvoid main() {",
                THREE.ShaderChunk.logdepthbuf_fragment, "\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tgl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\n\t#else\n\t\tgl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\n\t#endif\n}"].join("\n")
        }
    };
    THREE.WebGLRenderer = function (a) {
        function b(a) {
            var b = a.geometry;
            a = a.material;
            var d = b.vertices.length;
            if (a.attributes) {
                void 0 === b.__webglCustomAttributesList && (b.__webglCustomAttributesList = []);
                for (var e in a.attributes) {
                    var g = a.attributes[e];
                    if (!g.__webglInitialized || g.createUniqueBuffers) {
                        g.__webglInitialized = !0;
                        var h = 1;
                        "v2" === g.type ? h = 2 : "v3" === g.type ? h = 3 : "v4" === g.type ? h = 4 : "c" === g.type && (h = 3);
                        g.size = h;
                        g.array = new Float32Array(d * h);
                        g.buffer = t.createBuffer();
                        g.buffer.belongsToAttribute = e;
                        g.needsUpdate =
                            !0
                    }
                    b.__webglCustomAttributesList.push(g)
                }
            }
        }

        function d(a, b) {
            var d = b.geometry, g = a.faces3, h = 3 * g.length, f = 1 * g.length, k = 3 * g.length, g = e(b, a);
            a.__vertexArray = new Float32Array(3 * h);
            Q.info.memory.vertices += h;
            a.__normalArray = new Float32Array(3 * h);
            a.__colorArray = new Float32Array(3 * h);
            0 < d.faceVertexUvs.length && 0 < d.faceVertexUvs[0].length && (a.__uvArray = new Float32Array(2 * h));
            1 < d.faceVertexUvs.length && (a.__uv2Array = new Float32Array(2 * h));
            d.hasTangents && (a.__tangentArray = new Float32Array(4 * h));
            b.geometry.skinWeights.length &&
            b.geometry.skinIndices.length && (a.__skinIndexArray = new Float32Array(4 * h), a.__skinWeightArray = new Float32Array(4 * h));
            d = null !== oa.get("OES_element_index_uint") && 21845 < f ? Uint32Array : Uint16Array;
            Q.info.memory.faces += f;
            a.__typeArray = d;
            a.__faceArray = new d(3 * f);
            Fa && (a.__lineArray = new d(2 * k));
            var l;
            if (a.numMorphTargets) for (a.__morphTargetsArrays = [], d = 0, l = a.numMorphTargets; d < l; d++) a.__morphTargetsArrays.push(new Float32Array(3 * h));
            if (a.numMorphNormals) for (a.__morphNormalsArrays = [], d = 0, l = a.numMorphNormals; d <
            l; d++) a.__morphNormalsArrays.push(new Float32Array(3 * h));
            a.__webglFaceCount = 3 * f;
            a.__webglLineCount = Fa ? 2 * k : 0;
            if (g.attributes) {
                void 0 === a.__webglCustomAttributesList && (a.__webglCustomAttributesList = []);
                for (var m in g.attributes) {
                    var f = g.attributes[m], k = {}, n;
                    for (n in f) k[n] = f[n];
                    if (!k.__webglInitialized || k.createUniqueBuffers) k.__webglInitialized = !0, d = 1, "v2" === k.type ? d = 2 : "v3" === k.type ? d = 3 : "v4" === k.type ? d = 4 : "c" === k.type && (d = 3), k.size = d, k.array = new Float32Array(h * d), k.buffer = t.createBuffer(), k.buffer.belongsToAttribute =
                        m, f.needsUpdate = !0, k.__original = f;
                    a.__webglCustomAttributesList.push(k)
                }
            }
            a.__inittedArrays = !0
        }

        function e(a, b) {
            return a.material instanceof THREE.MeshFaceMaterial ? a.material.materials[b.materialIndex] : a.material
        }

        function f(a, b, d, e) {
            d = d.attributes;
            var h = b.attributes;
            b = b.attributesKeys;
            for (var f = 0, l = b.length; f < l; f++) {
                var m = b[f], n = h[m];
                if (0 <= n) {
                    var p = d[m];
                    void 0 !== p ? (m = p.itemSize, t.bindBuffer(t.ARRAY_BUFFER, p.buffer), g(n), t.vertexAttribPointer(n, m, t.FLOAT, !1, 0, e * m * 4)) : void 0 !== a.defaultAttributeValues &&
                        (2 === a.defaultAttributeValues[m].length ? t.vertexAttrib2fv(n, a.defaultAttributeValues[m]) : 3 === a.defaultAttributeValues[m].length && t.vertexAttrib3fv(n, a.defaultAttributeValues[m]))
                }
            }
            k()
        }

        function h() {
            for (var a = 0, b = Fb.length; a < b; a++) Fb[a] = 0
        }

        function g(a) {
            Fb[a] = 1;
            0 === ib[a] && (t.enableVertexAttribArray(a), ib[a] = 1)
        }

        function k() {
            for (var a = 0, b = ib.length; a < b; a++) ib[a] !== Fb[a] && (t.disableVertexAttribArray(a), ib[a] = 0)
        }

        function l(a, b) {
            return a.material.id !== b.material.id ? b.material.id - a.material.id : a.z !== b.z ? b.z -
                a.z : a.id - b.id
        }

        function m(a, b) {
            return a.z !== b.z ? a.z - b.z : a.id - b.id
        }

        function n(a, b) {
            return b[0] - a[0]
        }

        function q(a, g) {
            if (!1 !== g.visible) {
                if (!(g instanceof THREE.Scene || g instanceof THREE.Group)) {
                    void 0 === g.__webglInit && (g.__webglInit = !0, g._modelViewMatrix = new THREE.Matrix4, g._normalMatrix = new THREE.Matrix3, g.addEventListener("removed", vc));
                    var h = g.geometry;
                    if (void 0 !== h && void 0 === h.__webglInit && (h.__webglInit = !0, h.addEventListener("dispose", Sb), Q.info.memory.geometries++, !(h instanceof THREE.BufferGeometry))) if (g instanceof
                        THREE.Mesh) u(a, g, h); else if (g instanceof THREE.Line) {
                        if (void 0 === h.__webglVertexBuffer) {
                            h.__webglVertexBuffer = t.createBuffer();
                            h.__webglColorBuffer = t.createBuffer();
                            h.__webglLineDistanceBuffer = t.createBuffer();
                            Q.info.memory.geometries++;
                            var f = h.vertices.length;
                            h.__vertexArray = new Float32Array(3 * f);
                            Q.info.memory.vertices += f;
                            h.__colorArray = new Float32Array(3 * f);
                            h.__lineDistanceArray = new Float32Array(1 * f);
                            h.__webglLineCount = f;
                            b(g);
                            h.verticesNeedUpdate = !0;
                            h.colorsNeedUpdate = !0;
                            h.lineDistancesNeedUpdate =
                                !0
                        }
                    } else if (g instanceof THREE.PointCloud && void 0 === h.__webglVertexBuffer) {
                        h.__webglVertexBuffer = t.createBuffer();
                        h.__webglColorBuffer = t.createBuffer();
                        Q.info.memory.geometries++;
                        var k = h.vertices.length;
                        h.__vertexArray = new Float32Array(3 * k);
                        h.__colorArray = new Float32Array(3 * k);
                        h.__sortArray = [];
                        h.__webglParticleCount = k;
                        b(g);
                        h.verticesNeedUpdate = !0;
                        h.colorsNeedUpdate = !0
                    }
                    if (void 0 === g.__webglActive) if (g.__webglActive = !0, g instanceof THREE.Mesh) if (h instanceof THREE.BufferGeometry) x(Va, h, g); else {
                        if (h instanceof
                            THREE.Geometry) for (var l = Ba[h.id], m = 0, p = l.length; m < p; m++) x(Va, l[m], g)
                    } else g instanceof THREE.Line || g instanceof THREE.PointCloud ? x(Va, h, g) : (g instanceof THREE.ImmediateRenderObject || g.immediateRenderCallback) && ya.push({
                        id: null,
                        object: g,
                        opaque: null,
                        transparent: null,
                        z: 0
                    });
                    if (g instanceof THREE.Light) va.push(g); else if (g instanceof THREE.Sprite) $a.push(g); else if (g instanceof THREE.LensFlare) vb.push(g); else {
                        var r = Va[g.id];
                        if (r && (!1 === g.frustumCulled || !0 === Tb.intersectsObject(g))) {
                            var V = g.geometry, v,
                                Ka;
                            if (V instanceof THREE.BufferGeometry) for (var Ma = V.attributes, Ua = V.attributesKeys, ec = 0, uc = Ua.length; ec < uc; ec++) {
                                var F = Ua[ec], A = Ma[F];
                                void 0 === A.buffer && (A.buffer = t.createBuffer(), A.needsUpdate = !0);
                                if (!0 === A.needsUpdate) {
                                    var B = "index" === F ? t.ELEMENT_ARRAY_BUFFER : t.ARRAY_BUFFER;
                                    t.bindBuffer(B, A.buffer);
                                    t.bufferData(B, A.array, t.STATIC_DRAW);
                                    A.needsUpdate = !1
                                }
                            } else if (g instanceof THREE.Mesh) {
                                !0 === V.groupsNeedUpdate && u(a, g, V);
                                for (var y = Ba[V.id], Eb = 0, H = y.length; Eb < H; Eb++) {
                                    var E = y[Eb];
                                    Ka = e(g, E);
                                    !0 === V.groupsNeedUpdate &&
                                    d(E, g);
                                    v = Ka.attributes && w(Ka);
                                    if (V.verticesNeedUpdate || V.morphTargetsNeedUpdate || V.elementsNeedUpdate || V.uvsNeedUpdate || V.normalsNeedUpdate || V.colorsNeedUpdate || V.tangentsNeedUpdate || v) {
                                        var ga = E, G = g, C = t.DYNAMIC_DRAW, N = !V.dynamic, I = Ka;
                                        if (ga.__inittedArrays) {
                                            var X = I && void 0 !== I.shading && I.shading === THREE.SmoothShading,
                                                D = void 0, J = void 0, mc = void 0, K = void 0, fc = void 0,
                                                Y = void 0, M = void 0, ub = void 0, Rb = void 0, na = void 0,
                                                U = void 0, L = void 0, S = void 0, pa = void 0, lc = void 0,
                                                T = void 0, aa = void 0, P = void 0, Z = void 0, ca = void 0,
                                                ua = void 0, Bb = void 0, ra = void 0, ka = void 0, da = void 0,
                                                W = void 0, wb = void 0, ea = void 0, la = void 0, ja = void 0,
                                                Fb = void 0, ib = void 0, lb = void 0, bb = void 0, oa = void 0,
                                                Oa = void 0, ta = void 0, Sa = void 0, Aa = void 0, Ya = void 0, Ha = 0,
                                                Ea = 0, Ja = 0, Pa = 0, La = 0, Ub = 0, db = 0, gc = 0, jb = 0, Ca = 0,
                                                Ra = 0, R = 0, gb = void 0, mb = ga.__vertexArray, Qa = ga.__uvArray,
                                                Ac = ga.__uv2Array, pb = ga.__normalArray, Ia = ga.__tangentArray,
                                                kb = ga.__colorArray, qb = ga.__skinIndexArray,
                                                rb = ga.__skinWeightArray, Ta = ga.__morphTargetsArrays,
                                                Cb = ga.__morphNormalsArrays, cb = ga.__webglCustomAttributesList,
                                                O = void 0, Za = ga.__faceArray, hb = ga.__lineArray, Wa = G.geometry,
                                                yb = Wa.elementsNeedUpdate, ob = Wa.uvsNeedUpdate,
                                                Zb = Wa.normalsNeedUpdate, sa = Wa.tangentsNeedUpdate,
                                                $b = Wa.colorsNeedUpdate, fa = Wa.morphTargetsNeedUpdate,
                                                wa = Wa.vertices, ba = ga.faces3, Xa = Wa.faces,
                                                Na = Wa.faceVertexUvs[0], xb = Wa.faceVertexUvs[1], Mb = Wa.skinIndices,
                                                hc = Wa.skinWeights, Hb = Wa.morphTargets, eb = Wa.morphNormals;
                                            if (Wa.verticesNeedUpdate) {
                                                D = 0;
                                                for (J = ba.length; D < J; D++) K = Xa[ba[D]], L = wa[K.a], S = wa[K.b], pa = wa[K.c], mb[Ea] = L.x, mb[Ea + 1] = L.y, mb[Ea + 2] = L.z, mb[Ea +
                                                3] = S.x, mb[Ea + 4] = S.y, mb[Ea + 5] = S.z, mb[Ea + 6] = pa.x, mb[Ea + 7] = pa.y, mb[Ea + 8] = pa.z, Ea += 9;
                                                t.bindBuffer(t.ARRAY_BUFFER, ga.__webglVertexBuffer);
                                                t.bufferData(t.ARRAY_BUFFER, mb, C)
                                            }
                                            if (fa) for (oa = 0, Oa = Hb.length; oa < Oa; oa++) {
                                                D = Ra = 0;
                                                for (J = ba.length; D < J; D++) Aa = ba[D], K = Xa[Aa], L = Hb[oa].vertices[K.a], S = Hb[oa].vertices[K.b], pa = Hb[oa].vertices[K.c], ta = Ta[oa], ta[Ra] = L.x, ta[Ra + 1] = L.y, ta[Ra + 2] = L.z, ta[Ra + 3] = S.x, ta[Ra + 4] = S.y, ta[Ra + 5] = S.z, ta[Ra + 6] = pa.x, ta[Ra + 7] = pa.y, ta[Ra + 8] = pa.z, I.morphNormals && (X ? (Ya = eb[oa].vertexNormals[Aa],
                                                    P = Ya.a, Z = Ya.b, ca = Ya.c) : ca = Z = P = eb[oa].faceNormals[Aa], Sa = Cb[oa], Sa[Ra] = P.x, Sa[Ra + 1] = P.y, Sa[Ra + 2] = P.z, Sa[Ra + 3] = Z.x, Sa[Ra + 4] = Z.y, Sa[Ra + 5] = Z.z, Sa[Ra + 6] = ca.x, Sa[Ra + 7] = ca.y, Sa[Ra + 8] = ca.z), Ra += 9;
                                                t.bindBuffer(t.ARRAY_BUFFER, ga.__webglMorphTargetsBuffers[oa]);
                                                t.bufferData(t.ARRAY_BUFFER, Ta[oa], C);
                                                I.morphNormals && (t.bindBuffer(t.ARRAY_BUFFER, ga.__webglMorphNormalsBuffers[oa]), t.bufferData(t.ARRAY_BUFFER, Cb[oa], C))
                                            }
                                            if (hc.length) {
                                                D = 0;
                                                for (J = ba.length; D < J; D++) K = Xa[ba[D]], ka = hc[K.a], da = hc[K.b], W = hc[K.c], rb[Ca] =
                                                    ka.x, rb[Ca + 1] = ka.y, rb[Ca + 2] = ka.z, rb[Ca + 3] = ka.w, rb[Ca + 4] = da.x, rb[Ca + 5] = da.y, rb[Ca + 6] = da.z, rb[Ca + 7] = da.w, rb[Ca + 8] = W.x, rb[Ca + 9] = W.y, rb[Ca + 10] = W.z, rb[Ca + 11] = W.w, wb = Mb[K.a], ea = Mb[K.b], la = Mb[K.c], qb[Ca] = wb.x, qb[Ca + 1] = wb.y, qb[Ca + 2] = wb.z, qb[Ca + 3] = wb.w, qb[Ca + 4] = ea.x, qb[Ca + 5] = ea.y, qb[Ca + 6] = ea.z, qb[Ca + 7] = ea.w, qb[Ca + 8] = la.x, qb[Ca + 9] = la.y, qb[Ca + 10] = la.z, qb[Ca + 11] = la.w, Ca += 12;
                                                0 < Ca && (t.bindBuffer(t.ARRAY_BUFFER, ga.__webglSkinIndicesBuffer), t.bufferData(t.ARRAY_BUFFER, qb, C), t.bindBuffer(t.ARRAY_BUFFER, ga.__webglSkinWeightsBuffer),
                                                    t.bufferData(t.ARRAY_BUFFER, rb, C))
                                            }
                                            if ($b) {
                                                D = 0;
                                                for (J = ba.length; D < J; D++) K = Xa[ba[D]], M = K.vertexColors, ub = K.color, 3 === M.length && I.vertexColors === THREE.VertexColors ? (ua = M[0], Bb = M[1], ra = M[2]) : ra = Bb = ua = ub, kb[jb] = ua.r, kb[jb + 1] = ua.g, kb[jb + 2] = ua.b, kb[jb + 3] = Bb.r, kb[jb + 4] = Bb.g, kb[jb + 5] = Bb.b, kb[jb + 6] = ra.r, kb[jb + 7] = ra.g, kb[jb + 8] = ra.b, jb += 9;
                                                0 < jb && (t.bindBuffer(t.ARRAY_BUFFER, ga.__webglColorBuffer), t.bufferData(t.ARRAY_BUFFER, kb, C))
                                            }
                                            if (sa && Wa.hasTangents) {
                                                D = 0;
                                                for (J = ba.length; D < J; D++) K = Xa[ba[D]], Rb = K.vertexTangents,
                                                    lc = Rb[0], T = Rb[1], aa = Rb[2], Ia[db] = lc.x, Ia[db + 1] = lc.y, Ia[db + 2] = lc.z, Ia[db + 3] = lc.w, Ia[db + 4] = T.x, Ia[db + 5] = T.y, Ia[db + 6] = T.z, Ia[db + 7] = T.w, Ia[db + 8] = aa.x, Ia[db + 9] = aa.y, Ia[db + 10] = aa.z, Ia[db + 11] = aa.w, db += 12;
                                                t.bindBuffer(t.ARRAY_BUFFER, ga.__webglTangentBuffer);
                                                t.bufferData(t.ARRAY_BUFFER, Ia, C)
                                            }
                                            if (Zb) {
                                                D = 0;
                                                for (J = ba.length; D < J; D++) if (K = Xa[ba[D]], fc = K.vertexNormals, Y = K.normal, 3 === fc.length && X) for (ja = 0; 3 > ja; ja++) ib = fc[ja], pb[Ub] = ib.x, pb[Ub + 1] = ib.y, pb[Ub + 2] = ib.z, Ub += 3; else for (ja = 0; 3 > ja; ja++) pb[Ub] = Y.x, pb[Ub + 1] = Y.y,
                                                    pb[Ub + 2] = Y.z, Ub += 3;
                                                t.bindBuffer(t.ARRAY_BUFFER, ga.__webglNormalBuffer);
                                                t.bufferData(t.ARRAY_BUFFER, pb, C)
                                            }
                                            if (ob && Na && 0 < Na.length) {
                                                D = 0;
                                                for (J = ba.length; D < J; D++) if (mc = ba[D], na = Na[mc], void 0 !== na) for (ja = 0; 3 > ja; ja++) lb = na[ja], Qa[Ja] = lb.x, Qa[Ja + 1] = lb.y, Ja += 2;
                                                0 < Ja && (t.bindBuffer(t.ARRAY_BUFFER, ga.__webglUVBuffer), t.bufferData(t.ARRAY_BUFFER, Qa, C))
                                            }
                                            if (ob && xb) {
                                                D = 0;
                                                for (J = ba.length; D < J; D++) if (mc = ba[D], U = xb[mc], void 0 !== U) for (ja = 0; 3 > ja; ja++) bb = U[ja], Ac[Pa] = bb.x, Ac[Pa + 1] = bb.y, Pa += 2;
                                                0 < Pa && (t.bindBuffer(t.ARRAY_BUFFER,
                                                    ga.__webglUV2Buffer), t.bufferData(t.ARRAY_BUFFER, Ac, C))
                                            }
                                            if (yb) {
                                                D = 0;
                                                for (J = ba.length; D < J; D++) Za[La] = Ha, Za[La + 1] = Ha + 1, Za[La + 2] = Ha + 2, La += 3, Fa && (hb[gc] = Ha, hb[gc + 1] = Ha + 1, hb[gc + 2] = Ha, hb[gc + 3] = Ha + 2, hb[gc + 4] = Ha + 1, hb[gc + 5] = Ha + 2), gc += 6, Ha += 3;
                                                t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, ga.__webglFaceBuffer);
                                                t.bufferData(t.ELEMENT_ARRAY_BUFFER, Za, C);
                                                Fa && (t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, ga.__webglLineBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, hb, C))
                                            }
                                            if (cb) for (ja = 0, Fb = cb.length; ja < Fb; ja++) if (O = cb[ja], O.__original.needsUpdate) {
                                                R =
                                                    0;
                                                if (1 === O.size) if (void 0 === O.boundTo || "vertices" === O.boundTo) for (D = 0, J = ba.length; D < J; D++) K = Xa[ba[D]], O.array[R] = O.value[K.a], O.array[R + 1] = O.value[K.b], O.array[R + 2] = O.value[K.c], R += 3; else {
                                                    if ("faces" === O.boundTo) for (D = 0, J = ba.length; D < J; D++) gb = O.value[ba[D]], O.array[R] = gb, O.array[R + 1] = gb, O.array[R + 2] = gb, R += 3
                                                } else if (2 === O.size) if (void 0 === O.boundTo || "vertices" === O.boundTo) for (D = 0, J = ba.length; D < J; D++) K = Xa[ba[D]], L = O.value[K.a], S = O.value[K.b], pa = O.value[K.c], O.array[R] = L.x, O.array[R + 1] = L.y, O.array[R +
                                                2] = S.x, O.array[R + 3] = S.y, O.array[R + 4] = pa.x, O.array[R + 5] = pa.y, R += 6; else {
                                                    if ("faces" === O.boundTo) for (D = 0, J = ba.length; D < J; D++) pa = S = L = gb = O.value[ba[D]], O.array[R] = L.x, O.array[R + 1] = L.y, O.array[R + 2] = S.x, O.array[R + 3] = S.y, O.array[R + 4] = pa.x, O.array[R + 5] = pa.y, R += 6
                                                } else if (3 === O.size) {
                                                    var Da;
                                                    Da = "c" === O.type ? ["r", "g", "b"] : ["x", "y", "z"];
                                                    if (void 0 === O.boundTo || "vertices" === O.boundTo) for (D = 0, J = ba.length; D < J; D++) K = Xa[ba[D]], L = O.value[K.a], S = O.value[K.b], pa = O.value[K.c], O.array[R] = L[Da[0]], O.array[R + 1] = L[Da[1]], O.array[R +
                                                    2] = L[Da[2]], O.array[R + 3] = S[Da[0]], O.array[R + 4] = S[Da[1]], O.array[R + 5] = S[Da[2]], O.array[R + 6] = pa[Da[0]], O.array[R + 7] = pa[Da[1]], O.array[R + 8] = pa[Da[2]], R += 9; else if ("faces" === O.boundTo) for (D = 0, J = ba.length; D < J; D++) pa = S = L = gb = O.value[ba[D]], O.array[R] = L[Da[0]], O.array[R + 1] = L[Da[1]], O.array[R + 2] = L[Da[2]], O.array[R + 3] = S[Da[0]], O.array[R + 4] = S[Da[1]], O.array[R + 5] = S[Da[2]], O.array[R + 6] = pa[Da[0]], O.array[R + 7] = pa[Da[1]], O.array[R + 8] = pa[Da[2]], R += 9; else if ("faceVertices" === O.boundTo) for (D = 0, J = ba.length; D < J; D++) gb =
                                                        O.value[ba[D]], L = gb[0], S = gb[1], pa = gb[2], O.array[R] = L[Da[0]], O.array[R + 1] = L[Da[1]], O.array[R + 2] = L[Da[2]], O.array[R + 3] = S[Da[0]], O.array[R + 4] = S[Da[1]], O.array[R + 5] = S[Da[2]], O.array[R + 6] = pa[Da[0]], O.array[R + 7] = pa[Da[1]], O.array[R + 8] = pa[Da[2]], R += 9
                                                } else if (4 === O.size) if (void 0 === O.boundTo || "vertices" === O.boundTo) for (D = 0, J = ba.length; D < J; D++) K = Xa[ba[D]], L = O.value[K.a], S = O.value[K.b], pa = O.value[K.c], O.array[R] = L.x, O.array[R + 1] = L.y, O.array[R + 2] = L.z, O.array[R + 3] = L.w, O.array[R + 4] = S.x, O.array[R + 5] = S.y, O.array[R +
                                                6] = S.z, O.array[R + 7] = S.w, O.array[R + 8] = pa.x, O.array[R + 9] = pa.y, O.array[R + 10] = pa.z, O.array[R + 11] = pa.w, R += 12; else if ("faces" === O.boundTo) for (D = 0, J = ba.length; D < J; D++) pa = S = L = gb = O.value[ba[D]], O.array[R] = L.x, O.array[R + 1] = L.y, O.array[R + 2] = L.z, O.array[R + 3] = L.w, O.array[R + 4] = S.x, O.array[R + 5] = S.y, O.array[R + 6] = S.z, O.array[R + 7] = S.w, O.array[R + 8] = pa.x, O.array[R + 9] = pa.y, O.array[R + 10] = pa.z, O.array[R + 11] = pa.w, R += 12; else if ("faceVertices" === O.boundTo) for (D = 0, J = ba.length; D < J; D++) gb = O.value[ba[D]], L = gb[0], S = gb[1], pa = gb[2],
                                                    O.array[R] = L.x, O.array[R + 1] = L.y, O.array[R + 2] = L.z, O.array[R + 3] = L.w, O.array[R + 4] = S.x, O.array[R + 5] = S.y, O.array[R + 6] = S.z, O.array[R + 7] = S.w, O.array[R + 8] = pa.x, O.array[R + 9] = pa.y, O.array[R + 10] = pa.z, O.array[R + 11] = pa.w, R += 12;
                                                t.bindBuffer(t.ARRAY_BUFFER, O.buffer);
                                                t.bufferData(t.ARRAY_BUFFER, O.array, C)
                                            }
                                            N && (delete ga.__inittedArrays, delete ga.__colorArray, delete ga.__normalArray, delete ga.__tangentArray, delete ga.__uvArray, delete ga.__uv2Array, Q.info.memory.faces -= ga.__faceArray.length, delete ga.__faceArray, Q.info.memory.vertices -=
                                                ga.__vertexArray.length / 3, delete ga.__vertexArray, delete ga.__lineArray, delete ga.__skinIndexArray, delete ga.__skinWeightArray)
                                        }
                                    }
                                }
                                V.verticesNeedUpdate = !1;
                                V.morphTargetsNeedUpdate = !1;
                                V.elementsNeedUpdate = !1;
                                V.uvsNeedUpdate = !1;
                                V.normalsNeedUpdate = !1;
                                V.colorsNeedUpdate = !1;
                                V.tangentsNeedUpdate = !1;
                                Ka.attributes && z(Ka)
                            } else if (g instanceof THREE.Line) {
                                Ka = e(g, V);
                                v = Ka.attributes && w(Ka);
                                if (V.verticesNeedUpdate || V.colorsNeedUpdate || V.lineDistancesNeedUpdate || v) {
                                    var Kb = t.DYNAMIC_DRAW, zb, ac, Gb, Db, xa, Nb, Lb = V.vertices,
                                        Ob = V.colors, Pb = V.lineDistances, dc = Lb.length, nc = Ob.length,
                                        tc = Pb.length, Qb = V.__vertexArray, wc = V.__colorArray,
                                        Gc = V.__lineDistanceArray, Mc = V.colorsNeedUpdate,
                                        Nc = V.lineDistancesNeedUpdate, Bc = V.__webglCustomAttributesList, xc, Hc, fb,
                                        rc, sb, Ga;
                                    if (V.verticesNeedUpdate) {
                                        for (zb = 0; zb < dc; zb++) Db = Lb[zb], xa = 3 * zb, Qb[xa] = Db.x, Qb[xa + 1] = Db.y, Qb[xa + 2] = Db.z;
                                        t.bindBuffer(t.ARRAY_BUFFER, V.__webglVertexBuffer);
                                        t.bufferData(t.ARRAY_BUFFER, Qb, Kb)
                                    }
                                    if (Mc) {
                                        for (ac = 0; ac < nc; ac++) Nb = Ob[ac], xa = 3 * ac, wc[xa] = Nb.r, wc[xa + 1] = Nb.g, wc[xa + 2] =
                                            Nb.b;
                                        t.bindBuffer(t.ARRAY_BUFFER, V.__webglColorBuffer);
                                        t.bufferData(t.ARRAY_BUFFER, wc, Kb)
                                    }
                                    if (Nc) {
                                        for (Gb = 0; Gb < tc; Gb++) Gc[Gb] = Pb[Gb];
                                        t.bindBuffer(t.ARRAY_BUFFER, V.__webglLineDistanceBuffer);
                                        t.bufferData(t.ARRAY_BUFFER, Gc, Kb)
                                    }
                                    if (Bc) for (xc = 0, Hc = Bc.length; xc < Hc; xc++) if (Ga = Bc[xc], Ga.needsUpdate && (void 0 === Ga.boundTo || "vertices" === Ga.boundTo)) {
                                        xa = 0;
                                        rc = Ga.value.length;
                                        if (1 === Ga.size) for (fb = 0; fb < rc; fb++) Ga.array[fb] = Ga.value[fb]; else if (2 === Ga.size) for (fb = 0; fb < rc; fb++) sb = Ga.value[fb], Ga.array[xa] = sb.x, Ga.array[xa +
                                        1] = sb.y, xa += 2; else if (3 === Ga.size) if ("c" === Ga.type) for (fb = 0; fb < rc; fb++) sb = Ga.value[fb], Ga.array[xa] = sb.r, Ga.array[xa + 1] = sb.g, Ga.array[xa + 2] = sb.b, xa += 3; else for (fb = 0; fb < rc; fb++) sb = Ga.value[fb], Ga.array[xa] = sb.x, Ga.array[xa + 1] = sb.y, Ga.array[xa + 2] = sb.z, xa += 3; else if (4 === Ga.size) for (fb = 0; fb < rc; fb++) sb = Ga.value[fb], Ga.array[xa] = sb.x, Ga.array[xa + 1] = sb.y, Ga.array[xa + 2] = sb.z, Ga.array[xa + 3] = sb.w, xa += 4;
                                        t.bindBuffer(t.ARRAY_BUFFER, Ga.buffer);
                                        t.bufferData(t.ARRAY_BUFFER, Ga.array, Kb)
                                    }
                                }
                                V.verticesNeedUpdate = !1;
                                V.colorsNeedUpdate = !1;
                                V.lineDistancesNeedUpdate = !1;
                                Ka.attributes && z(Ka)
                            } else if (g instanceof THREE.PointCloud) {
                                Ka = e(g, V);
                                v = Ka.attributes && w(Ka);
                                if (V.verticesNeedUpdate || V.colorsNeedUpdate || g.sortParticles || v) {
                                    var Cc = t.DYNAMIC_DRAW, tb, Vb, Wb, ia, Xb, ic, yc = V.vertices, Dc = yc.length,
                                        Ec = V.colors, Ic = Ec.length, oc = V.__vertexArray, pc = V.__colorArray,
                                        bc = V.__sortArray, Jc = V.verticesNeedUpdate, Kc = V.colorsNeedUpdate,
                                        cc = V.__webglCustomAttributesList, Ib, sc, qa, Jb, za, ha;
                                    if (g.sortParticles) {
                                        Yb.copy(Ab);
                                        Yb.multiply(g.matrixWorld);
                                        for (tb = 0; tb < Dc; tb++) Wb = yc[tb], ab.copy(Wb), ab.applyProjection(Yb), bc[tb] = [ab.z, tb];
                                        bc.sort(n);
                                        for (tb = 0; tb < Dc; tb++) Wb = yc[bc[tb][1]], ia = 3 * tb, oc[ia] = Wb.x, oc[ia + 1] = Wb.y, oc[ia + 2] = Wb.z;
                                        for (Vb = 0; Vb < Ic; Vb++) ia = 3 * Vb, ic = Ec[bc[Vb][1]], pc[ia] = ic.r, pc[ia + 1] = ic.g, pc[ia + 2] = ic.b;
                                        if (cc) for (Ib = 0, sc = cc.length; Ib < sc; Ib++) if (ha = cc[Ib], void 0 === ha.boundTo || "vertices" === ha.boundTo) if (ia = 0, Jb = ha.value.length, 1 === ha.size) for (qa = 0; qa < Jb; qa++) Xb = bc[qa][1], ha.array[qa] = ha.value[Xb]; else if (2 === ha.size) for (qa = 0; qa < Jb; qa++) Xb =
                                            bc[qa][1], za = ha.value[Xb], ha.array[ia] = za.x, ha.array[ia + 1] = za.y, ia += 2; else if (3 === ha.size) if ("c" === ha.type) for (qa = 0; qa < Jb; qa++) Xb = bc[qa][1], za = ha.value[Xb], ha.array[ia] = za.r, ha.array[ia + 1] = za.g, ha.array[ia + 2] = za.b, ia += 3; else for (qa = 0; qa < Jb; qa++) Xb = bc[qa][1], za = ha.value[Xb], ha.array[ia] = za.x, ha.array[ia + 1] = za.y, ha.array[ia + 2] = za.z, ia += 3; else if (4 === ha.size) for (qa = 0; qa < Jb; qa++) Xb = bc[qa][1], za = ha.value[Xb], ha.array[ia] = za.x, ha.array[ia + 1] = za.y, ha.array[ia + 2] = za.z, ha.array[ia + 3] = za.w, ia += 4
                                    } else {
                                        if (Jc) for (tb =
                                                         0; tb < Dc; tb++) Wb = yc[tb], ia = 3 * tb, oc[ia] = Wb.x, oc[ia + 1] = Wb.y, oc[ia + 2] = Wb.z;
                                        if (Kc) for (Vb = 0; Vb < Ic; Vb++) ic = Ec[Vb], ia = 3 * Vb, pc[ia] = ic.r, pc[ia + 1] = ic.g, pc[ia + 2] = ic.b;
                                        if (cc) for (Ib = 0, sc = cc.length; Ib < sc; Ib++) if (ha = cc[Ib], ha.needsUpdate && (void 0 === ha.boundTo || "vertices" === ha.boundTo)) if (Jb = ha.value.length, ia = 0, 1 === ha.size) for (qa = 0; qa < Jb; qa++) ha.array[qa] = ha.value[qa]; else if (2 === ha.size) for (qa = 0; qa < Jb; qa++) za = ha.value[qa], ha.array[ia] = za.x, ha.array[ia + 1] = za.y, ia += 2; else if (3 === ha.size) if ("c" === ha.type) for (qa = 0; qa <
                                        Jb; qa++) za = ha.value[qa], ha.array[ia] = za.r, ha.array[ia + 1] = za.g, ha.array[ia + 2] = za.b, ia += 3; else for (qa = 0; qa < Jb; qa++) za = ha.value[qa], ha.array[ia] = za.x, ha.array[ia + 1] = za.y, ha.array[ia + 2] = za.z, ia += 3; else if (4 === ha.size) for (qa = 0; qa < Jb; qa++) za = ha.value[qa], ha.array[ia] = za.x, ha.array[ia + 1] = za.y, ha.array[ia + 2] = za.z, ha.array[ia + 3] = za.w, ia += 4
                                    }
                                    if (Jc || g.sortParticles) t.bindBuffer(t.ARRAY_BUFFER, V.__webglVertexBuffer), t.bufferData(t.ARRAY_BUFFER, oc, Cc);
                                    if (Kc || g.sortParticles) t.bindBuffer(t.ARRAY_BUFFER, V.__webglColorBuffer),
                                        t.bufferData(t.ARRAY_BUFFER, pc, Cc);
                                    if (cc) for (Ib = 0, sc = cc.length; Ib < sc; Ib++) if (ha = cc[Ib], ha.needsUpdate || g.sortParticles) t.bindBuffer(t.ARRAY_BUFFER, ha.buffer), t.bufferData(t.ARRAY_BUFFER, ha.array, Cc)
                                }
                                V.verticesNeedUpdate = !1;
                                V.colorsNeedUpdate = !1;
                                Ka.attributes && z(Ka)
                            }
                            for (var qc = 0, Fc = r.length; qc < Fc; qc++) {
                                var zc = r[qc], jc = zc, Lc = jc.object, Oc = jc.buffer, Pc = Lc.geometry,
                                    kc = Lc.material;
                                kc instanceof THREE.MeshFaceMaterial ? (kc = kc.materials[Pc instanceof THREE.BufferGeometry ? 0 : Oc.materialIndex], jc.material = kc,
                                    kc.transparent ? ma.push(jc) : nb.push(jc)) : kc && (jc.material = kc, kc.transparent ? ma.push(jc) : nb.push(jc));
                                zc.render = !0;
                                !0 === Q.sortObjects && (null !== g.renderDepth ? zc.z = g.renderDepth : (ab.setFromMatrixPosition(g.matrixWorld), ab.applyProjection(Ab), zc.z = ab.z))
                            }
                        }
                    }
                }
                qc = 0;
                for (Fc = g.children.length; qc < Fc; qc++) q(a, g.children[qc])
            }
        }

        function p(a, b, d, e, g, h) {
            for (var f, k = a.length - 1; -1 !== k; k--) {
                f = a[k];
                var l = f.object, m = f.buffer;
                E(l, b);
                if (h) f = h; else {
                    f = f.material;
                    if (!f) continue;
                    g && Q.setBlending(f.blending, f.blendEquation, f.blendSrc,
                        f.blendDst);
                    Q.setDepthTest(f.depthTest);
                    Q.setDepthWrite(f.depthWrite);
                    G(f.polygonOffset, f.polygonOffsetFactor, f.polygonOffsetUnits)
                }
                Q.setMaterialFaces(f);
                m instanceof THREE.BufferGeometry ? Q.renderBufferDirect(b, d, e, f, m, l) : Q.renderBuffer(b, d, e, f, m, l)
            }
        }

        function r(a, b, d, e, g, h, f) {
            for (var k, l = 0, m = a.length; l < m; l++) {
                k = a[l];
                var n = k.object;
                if (n.visible) {
                    if (f) k = f; else {
                        k = k[b];
                        if (!k) continue;
                        h && Q.setBlending(k.blending, k.blendEquation, k.blendSrc, k.blendDst);
                        Q.setDepthTest(k.depthTest);
                        Q.setDepthWrite(k.depthWrite);
                        G(k.polygonOffset, k.polygonOffsetFactor, k.polygonOffsetUnits)
                    }
                    Q.renderImmediateObject(d, e, g, k, n)
                }
            }
        }

        function v(a) {
            var b = a.object.material;
            b.transparent ? (a.transparent = b, a.opaque = null) : (a.opaque = b, a.transparent = null)
        }

        function u(a, b, e) {
            var g = b.material, h = !1;
            if (void 0 === Ba[e.id] || !0 === e.groupsNeedUpdate) {
                delete Va[b.id];
                a = Ba;
                for (var f = e.id, g = g instanceof THREE.MeshFaceMaterial, k = oa.get("OES_element_index_uint") ? 4294967296 : 65535, l, h = {}, m = e.morphTargets.length, n = e.morphNormals.length, p, q = {}, r = [], u = 0, V =
                    e.faces.length; u < V; u++) {
                    l = e.faces[u];
                    var v = g ? l.materialIndex : 0;
                    v in h || (h[v] = {hash: v, counter: 0});
                    l = h[v].hash + "_" + h[v].counter;
                    l in q || (p = {
                        id: Bb++,
                        faces3: [],
                        materialIndex: v,
                        vertices: 0,
                        numMorphTargets: m,
                        numMorphNormals: n
                    }, q[l] = p, r.push(p));
                    q[l].vertices + 3 > k && (h[v].counter += 1, l = h[v].hash + "_" + h[v].counter, l in q || (p = {
                        id: Bb++,
                        faces3: [],
                        materialIndex: v,
                        vertices: 0,
                        numMorphTargets: m,
                        numMorphNormals: n
                    }, q[l] = p, r.push(p)));
                    q[l].faces3.push(u);
                    q[l].vertices += 3
                }
                a[f] = r;
                e.groupsNeedUpdate = !1
            }
            a = Ba[e.id];
            f = 0;
            for (g =
                     a.length; f < g; f++) {
                k = a[f];
                if (void 0 === k.__webglVertexBuffer) {
                    h = k;
                    h.__webglVertexBuffer = t.createBuffer();
                    h.__webglNormalBuffer = t.createBuffer();
                    h.__webglTangentBuffer = t.createBuffer();
                    h.__webglColorBuffer = t.createBuffer();
                    h.__webglUVBuffer = t.createBuffer();
                    h.__webglUV2Buffer = t.createBuffer();
                    h.__webglSkinIndicesBuffer = t.createBuffer();
                    h.__webglSkinWeightsBuffer = t.createBuffer();
                    h.__webglFaceBuffer = t.createBuffer();
                    h.__webglLineBuffer = t.createBuffer();
                    n = m = void 0;
                    if (h.numMorphTargets) for (h.__webglMorphTargetsBuffers =
                                                    [], m = 0, n = h.numMorphTargets; m < n; m++) h.__webglMorphTargetsBuffers.push(t.createBuffer());
                    if (h.numMorphNormals) for (h.__webglMorphNormalsBuffers = [], m = 0, n = h.numMorphNormals; m < n; m++) h.__webglMorphNormalsBuffers.push(t.createBuffer());
                    Q.info.memory.geometries++;
                    d(k, b);
                    e.verticesNeedUpdate = !0;
                    e.morphTargetsNeedUpdate = !0;
                    e.elementsNeedUpdate = !0;
                    e.uvsNeedUpdate = !0;
                    e.normalsNeedUpdate = !0;
                    e.tangentsNeedUpdate = !0;
                    h = e.colorsNeedUpdate = !0
                } else h = !1;
                (h || void 0 === b.__webglActive) && x(Va, k, b)
            }
            b.__webglActive = !0
        }

        function x(a,
                   b, d) {
            var e = d.id;
            a[e] = a[e] || [];
            a[e].push({id: e, buffer: b, object: d, material: null, z: 0})
        }

        function w(a) {
            for (var b in a.attributes) if (a.attributes[b].needsUpdate) return !0;
            return !1
        }

        function z(a) {
            for (var b in a.attributes) a.attributes[b].needsUpdate = !1
        }

        function F(a, b, d, e, g) {
            var h, f, k, l;
            Cb = 0;
            if (e.needsUpdate) {
                e.program && lc(e);
                e.addEventListener("dispose", pa);
                var m;
                e instanceof THREE.MeshDepthMaterial ? m = "depth" : e instanceof THREE.MeshNormalMaterial ? m = "normal" : e instanceof THREE.MeshBasicMaterial ? m = "basic" : e instanceof
                THREE.MeshLambertMaterial ? m = "lambert" : e instanceof THREE.MeshPhongMaterial ? m = "phong" : e instanceof THREE.LineBasicMaterial ? m = "basic" : e instanceof THREE.LineDashedMaterial ? m = "dashed" : e instanceof THREE.PointCloudMaterial && (m = "particle_basic");
                if (m) {
                    var n = THREE.ShaderLib[m];
                    e.__webglShader = {
                        uniforms: THREE.UniformsUtils.clone(n.uniforms),
                        vertexShader: n.vertexShader,
                        fragmentShader: n.fragmentShader
                    }
                } else e.__webglShader = {
                    uniforms: e.uniforms,
                    vertexShader: e.vertexShader,
                    fragmentShader: e.fragmentShader
                };
                for (var p =
                    0, q = 0, r = 0, u = 0, V = 0, v = b.length; V < v; V++) {
                    var Ka = b[V];
                    Ka.onlyShadow || !1 === Ka.visible || (Ka instanceof THREE.DirectionalLight && p++, Ka instanceof THREE.PointLight && q++, Ka instanceof THREE.SpotLight && r++, Ka instanceof THREE.HemisphereLight && u++)
                }
                h = p;
                f = q;
                k = r;
                l = u;
                for (var x, w = 0, Ma = 0, z = b.length; Ma < z; Ma++) {
                    var Ua = b[Ma];
                    Ua.castShadow && (Ua instanceof THREE.SpotLight && w++, Ua instanceof THREE.DirectionalLight && !Ua.shadowCascade && w++)
                }
                x = w;
                var ec;
                if (Mb && g && g.skeleton && g.skeleton.useVertexTexture) ec = 1024; else {
                    var uc =
                        t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS), F = Math.floor((uc - 20) / 4);
                    void 0 !== g && g instanceof THREE.SkinnedMesh && (F = Math.min(g.skeleton.bones.length, F), F < g.skeleton.bones.length && console.warn("WebGLRenderer: too many bones - " + g.skeleton.bones.length + ", this GPU supports just " + F + " (try OpenGL instead of ANGLE)"));
                    ec = F
                }
                var y = {
                    precision: Z,
                    supportsVertexTextures: Kb,
                    map: !!e.map,
                    envMap: !!e.envMap,
                    lightMap: !!e.lightMap,
                    bumpMap: !!e.bumpMap,
                    normalMap: !!e.normalMap,
                    specularMap: !!e.specularMap,
                    alphaMap: !!e.alphaMap,
                    vertexColors: e.vertexColors,
                    fog: d,
                    useFog: e.fog,
                    fogExp: d instanceof THREE.FogExp2,
                    sizeAttenuation: e.sizeAttenuation,
                    logarithmicDepthBuffer: ea,
                    skinning: e.skinning,
                    maxBones: ec,
                    useVertexTexture: Mb && g && g.skeleton && g.skeleton.useVertexTexture,
                    morphTargets: e.morphTargets,
                    morphNormals: e.morphNormals,
                    maxMorphTargets: Q.maxMorphTargets,
                    maxMorphNormals: Q.maxMorphNormals,
                    maxDirLights: h,
                    maxPointLights: f,
                    maxSpotLights: k,
                    maxHemiLights: l,
                    maxShadows: x,
                    shadowMapEnabled: Q.shadowMapEnabled && g.receiveShadow && 0 < x,
                    shadowMapType: Q.shadowMapType,
                    shadowMapDebug: Q.shadowMapDebug,
                    shadowMapCascade: Q.shadowMapCascade,
                    alphaTest: e.alphaTest,
                    metal: e.metal,
                    wrapAround: e.wrapAround,
                    doubleSided: e.side === THREE.DoubleSide,
                    flipSided: e.side === THREE.BackSide
                }, Eb = [];
                m ? Eb.push(m) : (Eb.push(e.fragmentShader), Eb.push(e.vertexShader));
                if (void 0 !== e.defines) for (var ga in e.defines) Eb.push(ga), Eb.push(e.defines[ga]);
                for (ga in y) Eb.push(ga), Eb.push(y[ga]);
                for (var E = Eb.join(), C, G = 0, vc = lb.length; G < vc; G++) {
                    var N = lb[G];
                    if (N.code === E) {
                        C = N;
                        C.usedTimes++;
                        break
                    }
                }
                void 0 ===
                C && (C = new THREE.WebGLProgram(Q, E, e, y), lb.push(C), Q.info.memory.programs = lb.length);
                e.program = C;
                var J = C.attributes;
                if (e.morphTargets) {
                    e.numSupportedMorphTargets = 0;
                    for (var X, K = "morphTarget", Sb = 0; Sb < Q.maxMorphTargets; Sb++) X = K + Sb, 0 <= J[X] && e.numSupportedMorphTargets++
                }
                if (e.morphNormals) for (e.numSupportedMorphNormals = 0, K = "morphNormal", Sb = 0; Sb < Q.maxMorphNormals; Sb++) X = K + Sb, 0 <= J[X] && e.numSupportedMorphNormals++;
                e.uniformsList = [];
                for (var S in e.__webglShader.uniforms) {
                    var fc = e.program.uniforms[S];
                    fc && e.uniformsList.push([e.__webglShader.uniforms[S],
                        fc])
                }
                e.needsUpdate = !1
            }
            e.morphTargets && !g.__webglMorphTargetInfluences && (g.__webglMorphTargetInfluences = new Float32Array(Q.maxMorphTargets));
            var M = !1, Rb = !1, ub = !1, na = e.program, Ba = na.uniforms, T = e.__webglShader.uniforms;
            na.id !== ja && (t.useProgram(na.program), ja = na.id, ub = Rb = M = !0, Q.info.render.programSwitch++);
            e.id !== Sa && (-1 === Sa && (ub = !0), Sa = e.id, Rb = !0);
            if (M || a !== Ya) t.uniformMatrix4fv(Ba.projectionMatrix, !1, a.projectionMatrix.elements), ea && t.uniform1f(Ba.logDepthBufFC, 2 / (Math.log(a.far + 1) / Math.LN2)), a !==
            Ya && (Ya = a), (e instanceof THREE.ShaderMaterial || e instanceof THREE.MeshPhongMaterial || e.envMap) && null !== Ba.cameraPosition && (ab.setFromMatrixPosition(a.matrixWorld), t.uniform3f(Ba.cameraPosition, ab.x, ab.y, ab.z)), (e instanceof THREE.MeshPhongMaterial || e instanceof THREE.MeshLambertMaterial || e instanceof THREE.ShaderMaterial || e.skinning) && null !== Ba.viewMatrix && t.uniformMatrix4fv(Ba.viewMatrix, !1, a.matrixWorldInverse.elements);
            if (e.skinning) if (g.bindMatrix && null !== Ba.bindMatrix && t.uniformMatrix4fv(Ba.bindMatrix,
                    !1, g.bindMatrix.elements), g.bindMatrixInverse && null !== Ba.bindMatrixInverse && t.uniformMatrix4fv(Ba.bindMatrixInverse, !1, g.bindMatrixInverse.elements), Mb && g.skeleton && g.skeleton.useVertexTexture) {
                if (null !== Ba.boneTexture) {
                    var aa = H();
                    t.uniform1i(Ba.boneTexture, aa);
                    Q.setTexture(g.skeleton.boneTexture, aa)
                }
                null !== Ba.boneTextureWidth && t.uniform1i(Ba.boneTextureWidth, g.skeleton.boneTextureWidth);
                null !== Ba.boneTextureHeight && t.uniform1i(Ba.boneTextureHeight, g.skeleton.boneTextureHeight)
            } else g.skeleton && g.skeleton.boneMatrices &&
            null !== Ba.boneGlobalMatrices && t.uniformMatrix4fv(Ba.boneGlobalMatrices, !1, g.skeleton.boneMatrices);
            if (Rb) {
                d && e.fog && (T.fogColor.value = d.color, d instanceof THREE.Fog ? (T.fogNear.value = d.near, T.fogFar.value = d.far) : d instanceof THREE.FogExp2 && (T.fogDensity.value = d.density));
                if (e instanceof THREE.MeshPhongMaterial || e instanceof THREE.MeshLambertMaterial || e.lights) {
                    if (Zb) {
                        var ub = !0, P, ca, ua, Bb = 0, ra = 0, ka = 0, da, W, wb, ya, la, Fa, ma = Ha,
                            nb = ma.directional.colors, Fb = ma.directional.positions, va = ma.point.colors,
                            $a = ma.point.positions,
                            oa = ma.point.distances, ib = ma.spot.colors, Va = ma.spot.positions,
                            bb = ma.spot.distances, ta = ma.spot.directions, vb = ma.spot.anglesCos,
                            Ea = ma.spot.exponents, Aa = ma.hemi.skyColors, Ja = ma.hemi.groundColors,
                            Pa = ma.hemi.positions, La = 0, db = 0, Qa = 0, jb = 0, Ca = 0, Ra = 0, R = 0, gb = 0,
                            mb = 0, Za = 0, Ta = 0, pb = 0;
                        P = 0;
                        for (ca = b.length; P < ca; P++) ua = b[P], ua.onlyShadow || (da = ua.color, ya = ua.intensity, Fa = ua.distance, ua instanceof THREE.AmbientLight ? ua.visible && (Q.gammaInput ? (Bb += da.r * da.r, ra += da.g * da.g, ka += da.b * da.b) : (Bb += da.r, ra += da.g, ka += da.b)) : ua instanceof
                        THREE.DirectionalLight ? (Ca += 1, ua.visible && (Oa.setFromMatrixPosition(ua.matrixWorld), ab.setFromMatrixPosition(ua.target.matrixWorld), Oa.sub(ab), Oa.normalize(), mb = 3 * La, Fb[mb] = Oa.x, Fb[mb + 1] = Oa.y, Fb[mb + 2] = Oa.z, Q.gammaInput ? I(nb, mb, da, ya * ya) : A(nb, mb, da, ya), La += 1)) : ua instanceof THREE.PointLight ? (Ra += 1, ua.visible && (Za = 3 * db, Q.gammaInput ? I(va, Za, da, ya * ya) : A(va, Za, da, ya), ab.setFromMatrixPosition(ua.matrixWorld), $a[Za] = ab.x, $a[Za + 1] = ab.y, $a[Za + 2] = ab.z, oa[db] = Fa, db += 1)) : ua instanceof THREE.SpotLight ? (R += 1, ua.visible &&
                        (Ta = 3 * Qa, Q.gammaInput ? I(ib, Ta, da, ya * ya) : A(ib, Ta, da, ya), Oa.setFromMatrixPosition(ua.matrixWorld), Va[Ta] = Oa.x, Va[Ta + 1] = Oa.y, Va[Ta + 2] = Oa.z, bb[Qa] = Fa, ab.setFromMatrixPosition(ua.target.matrixWorld), Oa.sub(ab), Oa.normalize(), ta[Ta] = Oa.x, ta[Ta + 1] = Oa.y, ta[Ta + 2] = Oa.z, vb[Qa] = Math.cos(ua.angle), Ea[Qa] = ua.exponent, Qa += 1)) : ua instanceof THREE.HemisphereLight && (gb += 1, ua.visible && (Oa.setFromMatrixPosition(ua.matrixWorld), Oa.normalize(), pb = 3 * jb, Pa[pb] = Oa.x, Pa[pb + 1] = Oa.y, Pa[pb + 2] = Oa.z, W = ua.color, wb = ua.groundColor,
                            Q.gammaInput ? (la = ya * ya, I(Aa, pb, W, la), I(Ja, pb, wb, la)) : (A(Aa, pb, W, ya), A(Ja, pb, wb, ya)), jb += 1)));
                        P = 3 * La;
                        for (ca = Math.max(nb.length, 3 * Ca); P < ca; P++) nb[P] = 0;
                        P = 3 * db;
                        for (ca = Math.max(va.length, 3 * Ra); P < ca; P++) va[P] = 0;
                        P = 3 * Qa;
                        for (ca = Math.max(ib.length, 3 * R); P < ca; P++) ib[P] = 0;
                        P = 3 * jb;
                        for (ca = Math.max(Aa.length, 3 * gb); P < ca; P++) Aa[P] = 0;
                        P = 3 * jb;
                        for (ca = Math.max(Ja.length, 3 * gb); P < ca; P++) Ja[P] = 0;
                        ma.directional.length = La;
                        ma.point.length = db;
                        ma.spot.length = Qa;
                        ma.hemi.length = jb;
                        ma.ambient[0] = Bb;
                        ma.ambient[1] = ra;
                        ma.ambient[2] = ka;
                        Zb = !1
                    }
                    if (ub) {
                        var Ia = Ha;
                        T.ambientLightColor.value = Ia.ambient;
                        T.directionalLightColor.value = Ia.directional.colors;
                        T.directionalLightDirection.value = Ia.directional.positions;
                        T.pointLightColor.value = Ia.point.colors;
                        T.pointLightPosition.value = Ia.point.positions;
                        T.pointLightDistance.value = Ia.point.distances;
                        T.spotLightColor.value = Ia.spot.colors;
                        T.spotLightPosition.value = Ia.spot.positions;
                        T.spotLightDistance.value = Ia.spot.distances;
                        T.spotLightDirection.value = Ia.spot.directions;
                        T.spotLightAngleCos.value =
                            Ia.spot.anglesCos;
                        T.spotLightExponent.value = Ia.spot.exponents;
                        T.hemisphereLightSkyColor.value = Ia.hemi.skyColors;
                        T.hemisphereLightGroundColor.value = Ia.hemi.groundColors;
                        T.hemisphereLightDirection.value = Ia.hemi.positions;
                        B(T, !0)
                    } else B(T, !1)
                }
                if (e instanceof THREE.MeshBasicMaterial || e instanceof THREE.MeshLambertMaterial || e instanceof THREE.MeshPhongMaterial) {
                    T.opacity.value = e.opacity;
                    Q.gammaInput ? T.diffuse.value.copyGammaToLinear(e.color) : T.diffuse.value = e.color;
                    T.map.value = e.map;
                    T.lightMap.value = e.lightMap;
                    T.specularMap.value = e.specularMap;
                    T.alphaMap.value = e.alphaMap;
                    e.bumpMap && (T.bumpMap.value = e.bumpMap, T.bumpScale.value = e.bumpScale);
                    e.normalMap && (T.normalMap.value = e.normalMap, T.normalScale.value.copy(e.normalScale));
                    var kb;
                    e.map ? kb = e.map : e.specularMap ? kb = e.specularMap : e.normalMap ? kb = e.normalMap : e.bumpMap ? kb = e.bumpMap : e.alphaMap && (kb = e.alphaMap);
                    if (void 0 !== kb) {
                        var qb = kb.offset, rb = kb.repeat;
                        T.offsetRepeat.value.set(qb.x, qb.y, rb.x, rb.y)
                    }
                    T.envMap.value = e.envMap;
                    T.flipEnvMap.value = e.envMap instanceof
                    THREE.WebGLRenderTargetCube ? 1 : -1;
                    T.reflectivity.value = e.reflectivity;
                    T.refractionRatio.value = e.refractionRatio;
                    T.combine.value = e.combine;
                    T.useRefract.value = e.envMap && e.envMap.mapping instanceof THREE.CubeRefractionMapping
                }
                e instanceof THREE.LineBasicMaterial ? (T.diffuse.value = e.color, T.opacity.value = e.opacity) : e instanceof THREE.LineDashedMaterial ? (T.diffuse.value = e.color, T.opacity.value = e.opacity, T.dashSize.value = e.dashSize, T.totalSize.value = e.dashSize + e.gapSize, T.scale.value = e.scale) : e instanceof
                THREE.PointCloudMaterial ? (T.psColor.value = e.color, T.opacity.value = e.opacity, T.size.value = e.size, T.scale.value = U.height / 2, T.map.value = e.map) : e instanceof THREE.MeshPhongMaterial ? (T.shininess.value = e.shininess, Q.gammaInput ? (T.ambient.value.copyGammaToLinear(e.ambient), T.emissive.value.copyGammaToLinear(e.emissive), T.specular.value.copyGammaToLinear(e.specular)) : (T.ambient.value = e.ambient, T.emissive.value = e.emissive, T.specular.value = e.specular), e.wrapAround && T.wrapRGB.value.copy(e.wrapRGB)) : e instanceof
                THREE.MeshLambertMaterial ? (Q.gammaInput ? (T.ambient.value.copyGammaToLinear(e.ambient), T.emissive.value.copyGammaToLinear(e.emissive)) : (T.ambient.value = e.ambient, T.emissive.value = e.emissive), e.wrapAround && T.wrapRGB.value.copy(e.wrapRGB)) : e instanceof THREE.MeshDepthMaterial ? (T.mNear.value = a.near, T.mFar.value = a.far, T.opacity.value = e.opacity) : e instanceof THREE.MeshNormalMaterial && (T.opacity.value = e.opacity);
                if (g.receiveShadow && !e._shadowPass && T.shadowMatrix) for (var cb = 0, ob = 0, Db = b.length; ob < Db; ob++) {
                    var O =
                        b[ob];
                    O.castShadow && (O instanceof THREE.SpotLight || O instanceof THREE.DirectionalLight && !O.shadowCascade) && (T.shadowMap.value[cb] = O.shadowMap, T.shadowMapSize.value[cb] = O.shadowMapSize, T.shadowMatrix.value[cb] = O.shadowMatrix, T.shadowDarkness.value[cb] = O.shadowDarkness, T.shadowBias.value[cb] = O.shadowBias, cb++)
                }
                for (var xb = e.uniformsList, hb, Wa, yb, Ab = 0, Qb = xb.length; Ab < Qb; Ab++) {
                    var sa = xb[Ab][0];
                    if (!1 !== sa.needsUpdate) {
                        var Lb = sa.type, fa = sa.value, wa = xb[Ab][1];
                        switch (Lb) {
                            case "1i":
                                t.uniform1i(wa, fa);
                                break;
                            case "1f":
                                t.uniform1f(wa, fa);
                                break;
                            case "2f":
                                t.uniform2f(wa, fa[0], fa[1]);
                                break;
                            case "3f":
                                t.uniform3f(wa, fa[0], fa[1], fa[2]);
                                break;
                            case "4f":
                                t.uniform4f(wa, fa[0], fa[1], fa[2], fa[3]);
                                break;
                            case "1iv":
                                t.uniform1iv(wa, fa);
                                break;
                            case "3iv":
                                t.uniform3iv(wa, fa);
                                break;
                            case "1fv":
                                t.uniform1fv(wa, fa);
                                break;
                            case "2fv":
                                t.uniform2fv(wa, fa);
                                break;
                            case "3fv":
                                t.uniform3fv(wa, fa);
                                break;
                            case "4fv":
                                t.uniform4fv(wa, fa);
                                break;
                            case "Matrix3fv":
                                t.uniformMatrix3fv(wa, !1, fa);
                                break;
                            case "Matrix4fv":
                                t.uniformMatrix4fv(wa, !1,
                                    fa);
                                break;
                            case "i":
                                t.uniform1i(wa, fa);
                                break;
                            case "f":
                                t.uniform1f(wa, fa);
                                break;
                            case "v2":
                                t.uniform2f(wa, fa.x, fa.y);
                                break;
                            case "v3":
                                t.uniform3f(wa, fa.x, fa.y, fa.z);
                                break;
                            case "v4":
                                t.uniform4f(wa, fa.x, fa.y, fa.z, fa.w);
                                break;
                            case "c":
                                t.uniform3f(wa, fa.r, fa.g, fa.b);
                                break;
                            case "iv1":
                                t.uniform1iv(wa, fa);
                                break;
                            case "iv":
                                t.uniform3iv(wa, fa);
                                break;
                            case "fv1":
                                t.uniform1fv(wa, fa);
                                break;
                            case "fv":
                                t.uniform3fv(wa, fa);
                                break;
                            case "v2v":
                                void 0 === sa._array && (sa._array = new Float32Array(2 * fa.length));
                                for (var ba = 0, Xa = fa.length; ba <
                                Xa; ba++) yb = 2 * ba, sa._array[yb] = fa[ba].x, sa._array[yb + 1] = fa[ba].y;
                                t.uniform2fv(wa, sa._array);
                                break;
                            case "v3v":
                                void 0 === sa._array && (sa._array = new Float32Array(3 * fa.length));
                                ba = 0;
                                for (Xa = fa.length; ba < Xa; ba++) yb = 3 * ba, sa._array[yb] = fa[ba].x, sa._array[yb + 1] = fa[ba].y, sa._array[yb + 2] = fa[ba].z;
                                t.uniform3fv(wa, sa._array);
                                break;
                            case "v4v":
                                void 0 === sa._array && (sa._array = new Float32Array(4 * fa.length));
                                ba = 0;
                                for (Xa = fa.length; ba < Xa; ba++) yb = 4 * ba, sa._array[yb] = fa[ba].x, sa._array[yb + 1] = fa[ba].y, sa._array[yb + 2] = fa[ba].z,
                                    sa._array[yb + 3] = fa[ba].w;
                                t.uniform4fv(wa, sa._array);
                                break;
                            case "m3":
                                t.uniformMatrix3fv(wa, !1, fa.elements);
                                break;
                            case "m3v":
                                void 0 === sa._array && (sa._array = new Float32Array(9 * fa.length));
                                ba = 0;
                                for (Xa = fa.length; ba < Xa; ba++) fa[ba].flattenToArrayOffset(sa._array, 9 * ba);
                                t.uniformMatrix3fv(wa, !1, sa._array);
                                break;
                            case "m4":
                                t.uniformMatrix4fv(wa, !1, fa.elements);
                                break;
                            case "m4v":
                                void 0 === sa._array && (sa._array = new Float32Array(16 * fa.length));
                                ba = 0;
                                for (Xa = fa.length; ba < Xa; ba++) fa[ba].flattenToArrayOffset(sa._array,
                                    16 * ba);
                                t.uniformMatrix4fv(wa, !1, sa._array);
                                break;
                            case "t":
                                hb = fa;
                                Wa = H();
                                t.uniform1i(wa, Wa);
                                if (!hb) continue;
                                if (hb instanceof THREE.CubeTexture || hb.image instanceof Array && 6 === hb.image.length) {
                                    var Na = hb, Ob = Wa;
                                    if (6 === Na.image.length) if (Na.needsUpdate) {
                                        Na.image.__webglTextureCube || (Na.addEventListener("dispose", mc), Na.image.__webglTextureCube = t.createTexture(), Q.info.memory.textures++);
                                        t.activeTexture(t.TEXTURE0 + Ob);
                                        t.bindTexture(t.TEXTURE_CUBE_MAP, Na.image.__webglTextureCube);
                                        t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,
                                            Na.flipY);
                                        for (var Pb = Na instanceof THREE.CompressedTexture, hc = Na.image[0] instanceof THREE.DataTexture, Hb = [], eb = 0; 6 > eb; eb++) Hb[eb] = !Q.autoScaleCubemaps || Pb || hc ? hc ? Na.image[eb].image : Na.image[eb] : Y(Na.image[eb], Nb);
                                        var Da = Hb[0],
                                            Tb = THREE.Math.isPowerOfTwo(Da.width) && THREE.Math.isPowerOfTwo(Da.height),
                                            zb = L(Na.format), ac = L(Na.type);
                                        D(t.TEXTURE_CUBE_MAP, Na, Tb);
                                        for (eb = 0; 6 > eb; eb++) if (Pb) for (var Gb, Yb = Hb[eb].mipmaps, xa = 0, dc = Yb.length; xa < dc; xa++) Gb = Yb[xa], Na.format !== THREE.RGBAFormat && Na.format !== THREE.RGBFormat ?
                                            -1 < $b().indexOf(zb) ? t.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + eb, xa, zb, Gb.width, Gb.height, 0, Gb.data) : console.warn("Attempt to load unsupported compressed texture format") : t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + eb, xa, zb, Gb.width, Gb.height, 0, zb, ac, Gb.data); else hc ? t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + eb, 0, zb, Hb[eb].width, Hb[eb].height, 0, zb, ac, Hb[eb].data) : t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + eb, 0, zb, zb, ac, Hb[eb]);
                                        Na.generateMipmaps && Tb && t.generateMipmap(t.TEXTURE_CUBE_MAP);
                                        Na.needsUpdate = !1;
                                        if (Na.onUpdate) Na.onUpdate()
                                    } else t.activeTexture(t.TEXTURE0 + Ob), t.bindTexture(t.TEXTURE_CUBE_MAP, Na.image.__webglTextureCube)
                                } else if (hb instanceof THREE.WebGLRenderTargetCube) {
                                    var nc = hb;
                                    t.activeTexture(t.TEXTURE0 + Wa);
                                    t.bindTexture(t.TEXTURE_CUBE_MAP, nc.__webglTexture)
                                } else Q.setTexture(hb, Wa);
                                break;
                            case "tv":
                                void 0 === sa._array && (sa._array = []);
                                ba = 0;
                                for (Xa = sa.value.length; ba < Xa; ba++) sa._array[ba] = H();
                                t.uniform1iv(wa, sa._array);
                                ba = 0;
                                for (Xa = sa.value.length; ba < Xa; ba++) hb = sa.value[ba],
                                    Wa = sa._array[ba], hb && Q.setTexture(hb, Wa);
                                break;
                            default:
                                console.warn("THREE.WebGLRenderer: Unknown uniform type: " + Lb)
                        }
                    }
                }
            }
            t.uniformMatrix4fv(Ba.modelViewMatrix, !1, g._modelViewMatrix.elements);
            Ba.normalMatrix && t.uniformMatrix3fv(Ba.normalMatrix, !1, g._normalMatrix.elements);
            null !== Ba.modelMatrix && t.uniformMatrix4fv(Ba.modelMatrix, !1, g.matrixWorld.elements);
            return na
        }

        function B(a, b) {
            a.ambientLightColor.needsUpdate = b;
            a.directionalLightColor.needsUpdate = b;
            a.directionalLightDirection.needsUpdate = b;
            a.pointLightColor.needsUpdate =
                b;
            a.pointLightPosition.needsUpdate = b;
            a.pointLightDistance.needsUpdate = b;
            a.spotLightColor.needsUpdate = b;
            a.spotLightPosition.needsUpdate = b;
            a.spotLightDistance.needsUpdate = b;
            a.spotLightDirection.needsUpdate = b;
            a.spotLightAngleCos.needsUpdate = b;
            a.spotLightExponent.needsUpdate = b;
            a.hemisphereLightSkyColor.needsUpdate = b;
            a.hemisphereLightGroundColor.needsUpdate = b;
            a.hemisphereLightDirection.needsUpdate = b
        }

        function H() {
            var a = Cb;
            a >= Ob && console.warn("WebGLRenderer: trying to use " + a + " texture units while this GPU supports only " +
                Ob);
            Cb += 1;
            return a
        }

        function E(a, b) {
            a._modelViewMatrix.multiplyMatrices(b.matrixWorldInverse, a.matrixWorld);
            a._normalMatrix.getNormalMatrix(a._modelViewMatrix)
        }

        function I(a, b, d, e) {
            a[b] = d.r * d.r * e;
            a[b + 1] = d.g * d.g * e;
            a[b + 2] = d.b * d.b * e
        }

        function A(a, b, d, e) {
            a[b] = d.r * e;
            a[b + 1] = d.g * e;
            a[b + 2] = d.b * e
        }

        function N(a) {
            a !== V && (t.lineWidth(a), V = a)
        }

        function G(a, b, d) {
            Aa !== a && (a ? t.enable(t.POLYGON_OFFSET_FILL) : t.disable(t.POLYGON_OFFSET_FILL), Aa = a);
            !a || Pa === b && Ta === d || (t.polygonOffset(b, d), Pa = b, Ta = d)
        }

        function D(a, b, d) {
            d ? (t.texParameteri(a,
                t.TEXTURE_WRAP_S, L(b.wrapS)), t.texParameteri(a, t.TEXTURE_WRAP_T, L(b.wrapT)), t.texParameteri(a, t.TEXTURE_MAG_FILTER, L(b.magFilter)), t.texParameteri(a, t.TEXTURE_MIN_FILTER, L(b.minFilter))) : (t.texParameteri(a, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(a, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(a, t.TEXTURE_MAG_FILTER, J(b.magFilter)), t.texParameteri(a, t.TEXTURE_MIN_FILTER, J(b.minFilter)));
            (d = oa.get("EXT_texture_filter_anisotropic")) && b.type !== THREE.FloatType && (1 < b.anisotropy || b.__oldAnisotropy) &&
            (t.texParameterf(a, d.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(b.anisotropy, Q.getMaxAnisotropy())), b.__oldAnisotropy = b.anisotropy)
        }

        function Y(a, b) {
            if (a.width > b || a.height > b) {
                var d = b / Math.max(a.width, a.height), e = document.createElement("canvas");
                e.width = Math.floor(a.width * d);
                e.height = Math.floor(a.height * d);
                e.getContext("2d").drawImage(a, 0, 0, a.width, a.height, 0, 0, e.width, e.height);
                console.log("THREE.WebGLRenderer:", a, "is too big (" + a.width + "x" + a.height + "). Resized to " + e.width + "x" + e.height + ".");
                return e
            }
            return a
        }

        function C(a, b) {
            t.bindRenderbuffer(t.RENDERBUFFER, a);
            b.depthBuffer && !b.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_COMPONENT16, b.width, b.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, a)) : b.depthBuffer && b.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, b.width, b.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, a)) : t.renderbufferStorage(t.RENDERBUFFER, t.RGBA4, b.width, b.height)
        }

        function K(a) {
            a instanceof
            THREE.WebGLRenderTargetCube ? (t.bindTexture(t.TEXTURE_CUBE_MAP, a.__webglTexture), t.generateMipmap(t.TEXTURE_CUBE_MAP), t.bindTexture(t.TEXTURE_CUBE_MAP, null)) : (t.bindTexture(t.TEXTURE_2D, a.__webglTexture), t.generateMipmap(t.TEXTURE_2D), t.bindTexture(t.TEXTURE_2D, null))
        }

        function J(a) {
            return a === THREE.NearestFilter || a === THREE.NearestMipMapNearestFilter || a === THREE.NearestMipMapLinearFilter ? t.NEAREST : t.LINEAR
        }

        function L(a) {
            var b;
            if (a === THREE.RepeatWrapping) return t.REPEAT;
            if (a === THREE.ClampToEdgeWrapping) return t.CLAMP_TO_EDGE;
            if (a === THREE.MirroredRepeatWrapping) return t.MIRRORED_REPEAT;
            if (a === THREE.NearestFilter) return t.NEAREST;
            if (a === THREE.NearestMipMapNearestFilter) return t.NEAREST_MIPMAP_NEAREST;
            if (a === THREE.NearestMipMapLinearFilter) return t.NEAREST_MIPMAP_LINEAR;
            if (a === THREE.LinearFilter) return t.LINEAR;
            if (a === THREE.LinearMipMapNearestFilter) return t.LINEAR_MIPMAP_NEAREST;
            if (a === THREE.LinearMipMapLinearFilter) return t.LINEAR_MIPMAP_LINEAR;
            if (a === THREE.UnsignedByteType) return t.UNSIGNED_BYTE;
            if (a === THREE.UnsignedShort4444Type) return t.UNSIGNED_SHORT_4_4_4_4;
            if (a === THREE.UnsignedShort5551Type) return t.UNSIGNED_SHORT_5_5_5_1;
            if (a === THREE.UnsignedShort565Type) return t.UNSIGNED_SHORT_5_6_5;
            if (a === THREE.ByteType) return t.BYTE;
            if (a === THREE.ShortType) return t.SHORT;
            if (a === THREE.UnsignedShortType) return t.UNSIGNED_SHORT;
            if (a === THREE.IntType) return t.INT;
            if (a === THREE.UnsignedIntType) return t.UNSIGNED_INT;
            if (a === THREE.FloatType) return t.FLOAT;
            if (a === THREE.AlphaFormat) return t.ALPHA;
            if (a === THREE.RGBFormat) return t.RGB;
            if (a === THREE.RGBAFormat) return t.RGBA;
            if (a ===
                THREE.LuminanceFormat) return t.LUMINANCE;
            if (a === THREE.LuminanceAlphaFormat) return t.LUMINANCE_ALPHA;
            if (a === THREE.AddEquation) return t.FUNC_ADD;
            if (a === THREE.SubtractEquation) return t.FUNC_SUBTRACT;
            if (a === THREE.ReverseSubtractEquation) return t.FUNC_REVERSE_SUBTRACT;
            if (a === THREE.ZeroFactor) return t.ZERO;
            if (a === THREE.OneFactor) return t.ONE;
            if (a === THREE.SrcColorFactor) return t.SRC_COLOR;
            if (a === THREE.OneMinusSrcColorFactor) return t.ONE_MINUS_SRC_COLOR;
            if (a === THREE.SrcAlphaFactor) return t.SRC_ALPHA;
            if (a ===
                THREE.OneMinusSrcAlphaFactor) return t.ONE_MINUS_SRC_ALPHA;
            if (a === THREE.DstAlphaFactor) return t.DST_ALPHA;
            if (a === THREE.OneMinusDstAlphaFactor) return t.ONE_MINUS_DST_ALPHA;
            if (a === THREE.DstColorFactor) return t.DST_COLOR;
            if (a === THREE.OneMinusDstColorFactor) return t.ONE_MINUS_DST_COLOR;
            if (a === THREE.SrcAlphaSaturateFactor) return t.SRC_ALPHA_SATURATE;
            b = oa.get("WEBGL_compressed_texture_s3tc");
            if (null !== b) {
                if (a === THREE.RGB_S3TC_DXT1_Format) return b.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (a === THREE.RGBA_S3TC_DXT1_Format) return b.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (a === THREE.RGBA_S3TC_DXT3_Format) return b.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (a === THREE.RGBA_S3TC_DXT5_Format) return b.COMPRESSED_RGBA_S3TC_DXT5_EXT
            }
            b = oa.get("WEBGL_compressed_texture_pvrtc");
            if (null !== b) {
                if (a === THREE.RGB_PVRTC_4BPPV1_Format) return b.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (a === THREE.RGB_PVRTC_2BPPV1_Format) return b.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (a === THREE.RGBA_PVRTC_4BPPV1_Format) return b.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (a === THREE.RGBA_PVRTC_2BPPV1_Format) return b.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            }
            b =
                oa.get("EXT_blend_minmax");
            if (null !== b) {
                if (a === THREE.MinEquation) return b.MIN_EXT;
                if (a === THREE.MaxEquation) return b.MAX_EXT
            }
            return 0
        }

        a = a || {};
        var U = void 0 !== a.canvas ? a.canvas : document.createElement("canvas"),
            aa = void 0 !== a.context ? a.context : null, Z = void 0 !== a.precision ? a.precision : "highp",
            P = void 0 !== a.alpha ? a.alpha : !1, S = void 0 !== a.depth ? a.depth : !0,
            da = void 0 !== a.stencil ? a.stencil : !0, ca = void 0 !== a.antialias ? a.antialias : !1,
            M = void 0 !== a.premultipliedAlpha ? a.premultipliedAlpha : !0, la = void 0 !== a.preserveDrawingBuffer ?
            a.preserveDrawingBuffer : !1, ea = void 0 !== a.logarithmicDepthBuffer ? a.logarithmicDepthBuffer : !1,
            ka = new THREE.Color(0), na = 0, T = void 0 !== a.bugPixelStorei ? a.bugPixelStorei : !1,
            X = void 0 !== a.useSkeleton ? a.useSkeleton : !0,
            ra = void 0 !== a.recomputeCameraInverse ? a.recomputeCameraInverse : !0, Fa = a.generateLines;
        void 0 !== a.bugWP81 && a.bugWP81 && Object.keys(THREE.ShaderLib).forEach(function (a) {
            THREE.ShaderLib[a].fragmentShader = THREE.ShaderLib[a].fragmentShader.replace("#extension GL_EXT_frag_depth : enable", "")
        });
        void 0 !==
        a.disable_console && a.disable_console && (console = {
            log: function () {
            }, warn: function () {
            }, error: function () {
            }
        });
        var va = [], Va = {}, ya = [], nb = [], ma = [], $a = [], vb = [];
        this.domElement = U;
        this.context = null;
        this.devicePixelRatio = void 0 !== a.devicePixelRatio ? a.devicePixelRatio : void 0 !== self.devicePixelRatio ? self.devicePixelRatio : 1;
        this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0;
        this.shadowMapEnabled = this.gammaOutput = this.gammaInput = !1;
        this.shadowMapType = THREE.PCFShadowMap;
        this.shadowMapCullFace = THREE.CullFaceFront;
        this.shadowMapCascade = this.shadowMapDebug = !1;
        this.maxMorphTargets = 8;
        this.maxMorphNormals = 4;
        this.autoScaleCubemaps = !0;
        this.info = {
            memory: {programs: 0, geometries: 0, textures: 0, vertices: 0, faces: 0, textureSz: 0},
            render: {calls: 0, vertices: 0, faces: 0, points: 0}
        };
        var Q = this, lb = [], ja = null, bb = null, Sa = -1, Ea = -1, Ya = null, Cb = 0, cb = -1, y = -1, La = -1,
            ob = -1, Qa = -1, ta = -1, Za = -1, Ja = -1, Aa = null, Pa = null, Ta = null, V = null, Ma = 0, Ua = 0,
            ga = U.width, ub = U.height, ua = 0, wb = 0, Fb = new Uint8Array(16), ib = new Uint8Array(16),
            Tb = new THREE.Frustum, Ab = new THREE.Matrix4, Yb = new THREE.Matrix4, ab = new THREE.Vector3,
            Oa = new THREE.Vector3, Zb = !0, Ha = {
                ambient: [0, 0, 0],
                directional: {length: 0, colors: [], positions: []},
                point: {length: 0, colors: [], positions: [], distances: []},
                spot: {length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: []},
                hemi: {length: 0, skyColors: [], groundColors: [], positions: []}
            }, t;
        try {
            var Db = {alpha: P, depth: S, stencil: da, antialias: ca, premultipliedAlpha: M, preserveDrawingBuffer: la};
            t = aa || U.getContext("webgl",
                Db) || U.getContext("experimental-webgl", Db);
            if (null === t) {
                if (null !== U.getContext("webgl")) throw"Error creating WebGL context with your selected attributes.";
                throw"Error creating WebGL context.";
            }
        } catch (nc) {
            console.error(nc)
        }
        void 0 === t.getShaderPrecisionFormat && (t.getShaderPrecisionFormat = function () {
            return {rangeMin: 1, rangeMax: 1, precision: 1}
        });
        var oa = new THREE.WebGLExtensions(t);
        oa.get("OES_texture_float");
        oa.get("OES_texture_float_linear");
        oa.get("OES_standard_derivatives");
        ea && oa.get("EXT_frag_depth");
        t.clearColor(0, 0, 0, 1);
        t.clearDepth(1);
        da && t.clearStencil(0);
        t.enable(t.DEPTH_TEST);
        t.depthFunc(t.LEQUAL);
        t.frontFace(t.CCW);
        t.cullFace(t.BACK);
        t.enable(t.CULL_FACE);
        t.enable(t.BLEND);
        t.blendEquation(t.FUNC_ADD);
        t.blendFunc(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA);
        t.viewport(Ma, Ua, ga, ub);
        t.clearColor(ka.r, ka.g, ka.b, na);
        this.context = t;
        var Ob = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), tc = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
            W = t.getParameter(t.MAX_TEXTURE_SIZE), Nb = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
            Kb = 0 < tc, Mb = Kb && oa.get("OES_texture_float"),
            Pb = t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT),
            dc = t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT);
        t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.LOW_FLOAT);
        var Qb = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT),
            xb = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT);
        t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.LOW_FLOAT);
        var $b = function () {
            var a;
            return function () {
                if (void 0 !== a) return a;
                a = [];
                if (oa.get("WEBGL_compressed_texture_pvrtc") ||
                    oa.get("WEBGL_compressed_texture_s3tc")) for (var b = t.getParameter(t.COMPRESSED_TEXTURE_FORMATS), d = 0; d < b.length; d++) a.push(b[d]);
                return a
            }
        }(), Lb = 0 < Pb.precision && 0 < Qb.precision, Ka = 0 < dc.precision && 0 < xb.precision;
        "highp" !== Z || Lb || (Ka ? (Z = "mediump", console.warn("THREE.WebGLRenderer: highp not supported, using mediump.")) : (Z = "lowp", console.warn("THREE.WebGLRenderer: highp and mediump not supported, using lowp.")));
        "mediump" !== Z || Ka || (Z = "lowp", console.warn("THREE.WebGLRenderer: mediump not supported, using lowp."));
        var ec = new THREE.ShadowMapPlugin(this, va, Va, ya), uc = new THREE.SpritePlugin(this, $a),
            Eb = new THREE.LensFlarePlugin(this, vb);
        this.getContext = function () {
            return t
        };
        this.supportsVertexTextures = function () {
            return Kb
        };
        this.supportsFloatTextures = function () {
            return oa.get("OES_texture_float")
        };
        this.supportsStandardDerivatives = function () {
            return oa.get("OES_standard_derivatives")
        };
        this.supportsCompressedTextureS3TC = function () {
            return oa.get("WEBGL_compressed_texture_s3tc")
        };
        this.supportsCompressedTexturePVRTC = function () {
            return oa.get("WEBGL_compressed_texture_pvrtc")
        };
        this.supportsBlendMinMax = function () {
            return oa.get("EXT_blend_minmax")
        };
        this.getMaxAnisotropy = function () {
            var a;
            return function () {
                if (void 0 !== a) return a;
                var b = oa.get("EXT_texture_filter_anisotropic");
                return a = null !== b ? t.getParameter(b.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
            }
        }();
        this.getPrecision = function () {
            return Z
        };
        this.setSize = function (a, b, d) {
            U.width = a * this.devicePixelRatio;
            U.height = b * this.devicePixelRatio;
            !1 !== d && (U.style.width = a + "px", U.style.height = b + "px");
            this.setViewport(0, 0, a, b)
        };
        this.setViewport =
            function (a, b, d, e) {
                Ma = a * this.devicePixelRatio;
                Ua = b * this.devicePixelRatio;
                ga = d * this.devicePixelRatio;
                ub = e * this.devicePixelRatio;
                t.viewport(Ma, Ua, ga, ub)
            };
        this.setScissor = function (a, b, d, e) {
            t.scissor(a * this.devicePixelRatio, b * this.devicePixelRatio, d * this.devicePixelRatio, e * this.devicePixelRatio)
        };
        this.enableScissorTest = function (a) {
            a ? t.enable(t.SCISSOR_TEST) : t.disable(t.SCISSOR_TEST)
        };
        this.setClearColor = function (a, b) {
            ka.set(a);
            na = void 0 !== b ? b : 1;
            t.clearColor(ka.r, ka.g, ka.b, na)
        };
        this.setClearColorHex = function (a,
                                          b) {
            console.warn("THREE.WebGLRenderer: .setClearColorHex() is being removed. Use .setClearColor() instead.");
            this.setClearColor(a, b)
        };
        this.getClearColor = function () {
            return ka
        };
        this.getClearAlpha = function () {
            return na
        };
        this.clear = function (a, b, d) {
            var e = 0;
            if (void 0 === a || a) e |= t.COLOR_BUFFER_BIT;
            if (void 0 === b || b) e |= t.DEPTH_BUFFER_BIT;
            if (void 0 === d || d) e |= t.STENCIL_BUFFER_BIT;
            t.clear(e)
        };
        this.clearColor = function () {
            t.clear(t.COLOR_BUFFER_BIT)
        };
        this.clearDepth = function () {
            t.clear(t.DEPTH_BUFFER_BIT)
        };
        this.clearStencil =
            function () {
                t.clear(t.STENCIL_BUFFER_BIT)
            };
        this.clearTarget = function (a, b, d, e) {
            this.setRenderTarget(a);
            this.clear(b, d, e)
        };
        this.resetGLState = function () {
            Ya = ja = null;
            Sa = Ea = y = cb = Ja = Za = La = -1;
            Zb = !0
        };
        var vc = function (a) {
            a.target.traverse(function (a) {
                a.removeEventListener("remove", vc);
                if (a instanceof THREE.Mesh || a instanceof THREE.PointCloud || a instanceof THREE.Line) delete Va[a.id]; else if (a instanceof THREE.ImmediateRenderObject || a.immediateRenderCallback) for (var b = ya, d = b.length - 1; 0 <= d; d--) b[d].object === a &&
                b.splice(d, 1);
                delete a.__webglInit;
                delete a._modelViewMatrix;
                delete a._normalMatrix;
                delete a.__webglActive
            })
        }, Sb = function (a) {
            a = a.target;
            a.removeEventListener("dispose", Sb);
            delete a.__webglInit;
            if (a instanceof THREE.BufferGeometry) {
                for (var b in a.attributes) {
                    var d = a.attributes[b];
                    void 0 !== d.buffer && (t.deleteBuffer(d.buffer), delete d.buffer)
                }
                Q.info.memory.geometries--
            } else if (b = Ba[a.id], void 0 !== b) {
                for (var d = 0, e = b.length; d < e; d++) {
                    var g = b[d];
                    if (void 0 !== g.numMorphTargets) {
                        for (var h = 0, f = g.numMorphTargets; h <
                        f; h++) t.deleteBuffer(g.__webglMorphTargetsBuffers[h]);
                        delete g.__webglMorphTargetsBuffers
                    }
                    if (void 0 !== g.numMorphNormals) {
                        h = 0;
                        for (f = g.numMorphNormals; h < f; h++) t.deleteBuffer(g.__webglMorphNormalsBuffers[h]);
                        delete g.__webglMorphNormalsBuffers
                    }
                    Rb(g)
                }
                delete Ba[a.id]
            } else Rb(a);
            Ea = -1
        }, mc = function (a) {
            a = a.target;
            a.removeEventListener("dispose", mc);
            a.image && a.image.__webglTextureCube ? (t.deleteTexture(a.image.__webglTextureCube), delete a.image.__webglTextureCube) : void 0 !== a.__webglInit && (t.deleteTexture(a.__webglTexture),
                delete a.__webglTexture, delete a.__webglInit);
            Q.info.memory.textures--;
            Q.info.memory.textureSz -= a.textureSz
        }, fc = function (a) {
            a = a.target;
            a.removeEventListener("dispose", fc);
            if (a && void 0 !== a.__webglTexture) {
                t.deleteTexture(a.__webglTexture);
                delete a.__webglTexture;
                if (a instanceof THREE.WebGLRenderTargetCube) for (var b = 0; 6 > b; b++) t.deleteFramebuffer(a.__webglFramebuffer[b]), t.deleteRenderbuffer(a.__webglRenderbuffer[b]); else t.deleteFramebuffer(a.__webglFramebuffer), t.deleteRenderbuffer(a.__webglRenderbuffer);
                delete a.__webglFramebuffer;
                delete a.__webglRenderbuffer
            }
            Q.info.memory.textures--
        }, pa = function (a) {
            a = a.target;
            a.removeEventListener("dispose", pa);
            lc(a)
        }, Rb = function (a) {
            for (var b = "__webglVertexBuffer __webglNormalBuffer __webglTangentBuffer __webglColorBuffer __webglUVBuffer __webglUV2Buffer __webglSkinIndicesBuffer __webglSkinWeightsBuffer __webglFaceBuffer __webglLineBuffer __webglLineDistanceBuffer".split(" "), d = 0, e = b.length; d < e; d++) {
                var g = b[d];
                void 0 !== a[g] && (t.deleteBuffer(a[g]), delete a[g])
            }
            if (void 0 !==
                a.__webglCustomAttributesList) {
                for (g in a.__webglCustomAttributesList) t.deleteBuffer(a.__webglCustomAttributesList[g].buffer);
                delete a.__webglCustomAttributesList
            }
            Q.info.memory.geometries--
        }, lc = function (a) {
            var b = a.program.program;
            if (void 0 !== b) {
                a.program = void 0;
                var d, e, g = !1;
                a = 0;
                for (d = lb.length; a < d; a++) if (e = lb[a], e.program === b) {
                    e.usedTimes--;
                    0 === e.usedTimes && (g = !0);
                    break
                }
                if (!0 === g) {
                    g = [];
                    a = 0;
                    for (d = lb.length; a < d; a++) e = lb[a], e.program !== b && g.push(e);
                    lb = g;
                    t.deleteProgram(b);
                    Q.info.memory.programs--
                }
            }
        };
        this.renderBufferImmediate = function (a, b, d) {
            h();
            a.hasPositions && !a.__webglVertexBuffer && (a.__webglVertexBuffer = t.createBuffer());
            a.hasNormals && !a.__webglNormalBuffer && (a.__webglNormalBuffer = t.createBuffer());
            a.hasUvs && !a.__webglUvBuffer && (a.__webglUvBuffer = t.createBuffer());
            a.hasColors && !a.__webglColorBuffer && (a.__webglColorBuffer = t.createBuffer());
            a.hasPositions && (t.bindBuffer(t.ARRAY_BUFFER, a.__webglVertexBuffer), t.bufferData(t.ARRAY_BUFFER, a.positionArray, t.DYNAMIC_DRAW), g(b.attributes.position),
                t.vertexAttribPointer(b.attributes.position, 3, t.FLOAT, !1, 0, 0));
            if (a.hasNormals) {
                t.bindBuffer(t.ARRAY_BUFFER, a.__webglNormalBuffer);
                if (d.shading === THREE.FlatShading) {
                    var e, f, l, m, n, p, q, r, u, V, v, Ka = 3 * a.count;
                    for (v = 0; v < Ka; v += 9) V = a.normalArray, e = V[v], f = V[v + 1], l = V[v + 2], m = V[v + 3], p = V[v + 4], r = V[v + 5], n = V[v + 6], q = V[v + 7], u = V[v + 8], e = (e + m + n) / 3, f = (f + p + q) / 3, l = (l + r + u) / 3, V[v] = e, V[v + 1] = f, V[v + 2] = l, V[v + 3] = e, V[v + 4] = f, V[v + 5] = l, V[v + 6] = e, V[v + 7] = f, V[v + 8] = l
                }
                t.bufferData(t.ARRAY_BUFFER, a.normalArray, t.DYNAMIC_DRAW);
                g(b.attributes.normal);
                t.vertexAttribPointer(b.attributes.normal, 3, t.FLOAT, !1, 0, 0)
            }
            a.hasUvs && d.map && (t.bindBuffer(t.ARRAY_BUFFER, a.__webglUvBuffer), t.bufferData(t.ARRAY_BUFFER, a.uvArray, t.DYNAMIC_DRAW), g(b.attributes.uv), t.vertexAttribPointer(b.attributes.uv, 2, t.FLOAT, !1, 0, 0));
            a.hasColors && d.vertexColors !== THREE.NoColors && (t.bindBuffer(t.ARRAY_BUFFER, a.__webglColorBuffer), t.bufferData(t.ARRAY_BUFFER, a.colorArray, t.DYNAMIC_DRAW), g(b.attributes.color), t.vertexAttribPointer(b.attributes.color, 3, t.FLOAT, !1, 0, 0));
            k();
            t.drawArrays(t.TRIANGLES,
                0, a.count);
            a.count = 0
        };
        this.renderBufferDirect = function (a, b, d, e, g, k) {
            if (!1 !== e.visible) if (a = F(a, b, d, e, k), b = !1, d = 16777215 * g.id + 2 * a.id + (e.wireframe ? 1 : 0), d !== Ea && (Ea = d, b = !0), b && h(), k instanceof THREE.Mesh) if (k = !0 === e.wireframe ? t.LINES : t.TRIANGLES, d = g.attributes.index) {
                var l, m;
                d.array instanceof Uint32Array && oa.get("OES_element_index_uint") ? (l = t.UNSIGNED_INT, m = 4) : (l = t.UNSIGNED_SHORT, m = 2);
                var n = g.offsets;
                if (0 === n.length) b && (f(e, a, g, 0), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, d.buffer)), t.drawElements(k, d.array.length,
                    l, 0), Q.info.render.calls++, Q.info.render.vertices += d.array.length, Q.info.render.faces += d.array.length / 3; else {
                    b = !0;
                    for (var p = 0, q = n.length; p < q; p++) {
                        var r = n[p].index;
                        b && (f(e, a, g, r), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, d.buffer));
                        t.drawElements(k, n[p].count, l, n[p].start * m);
                        Q.info.render.calls++;
                        Q.info.render.vertices += n[p].count;
                        Q.info.render.faces += n[p].count / 3
                    }
                }
            } else b && f(e, a, g, 0), e = g.attributes.position, t.drawArrays(k, 0, e.array.length / 3), Q.info.render.calls++, Q.info.render.vertices += e.array.length /
                3, Q.info.render.faces += e.array.length / 9; else if (k instanceof THREE.PointCloud) b && f(e, a, g, 0), e = g.attributes.position, t.drawArrays(t.POINTS, 0, e.array.length / 3), Q.info.render.calls++, Q.info.render.points += e.array.length / 3; else if (k instanceof THREE.Line) if (k = k.mode === THREE.LineStrip ? t.LINE_STRIP : t.LINES, N(e.linewidth), d = g.attributes.index) if (d.array instanceof Uint32Array ? (l = t.UNSIGNED_INT, m = 4) : (l = t.UNSIGNED_SHORT, m = 2), n = g.offsets, 0 === n.length) b && (f(e, a, g, 0), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, d.buffer)),
                t.drawElements(k, d.array.length, l, 0), Q.info.render.calls++, Q.info.render.vertices += d.array.length; else for (1 < n.length && (b = !0), p = 0, q = n.length; p < q; p++) r = n[p].index, b && (f(e, a, g, r), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, d.buffer)), t.drawElements(k, n[p].count, l, n[p].start * m), Q.info.render.calls++, Q.info.render.vertices += n[p].count; else b && f(e, a, g, 0), e = g.attributes.position, t.drawArrays(k, 0, e.array.length / 3), Q.info.render.calls++, Q.info.render.points += e.array.length / 3
        };
        this.renderBuffer = function (a, b, d, e, f,
                                      l) {
            if (!1 !== e.visible) {
                d = F(a, b, d, e, l);
                b = d.attributes;
                a = !1;
                d = 16777215 * f.id + 2 * d.id + (e.wireframe ? 1 : 0);
                d !== Ea && (Ea = d, a = !0);
                a && h();
                if (!e.morphTargets && 0 <= b.position) a && (t.bindBuffer(t.ARRAY_BUFFER, f.__webglVertexBuffer), g(b.position), t.vertexAttribPointer(b.position, 3, t.FLOAT, !1, 0, 0)); else if (l.morphTargetBase) {
                    d = e.program.attributes;
                    -1 !== l.morphTargetBase && 0 <= d.position ? (t.bindBuffer(t.ARRAY_BUFFER, f.__webglMorphTargetsBuffers[l.morphTargetBase]), g(d.position), t.vertexAttribPointer(d.position, 3, t.FLOAT,
                        !1, 0, 0)) : 0 <= d.position && (t.bindBuffer(t.ARRAY_BUFFER, f.__webglVertexBuffer), g(d.position), t.vertexAttribPointer(d.position, 3, t.FLOAT, !1, 0, 0));
                    if (l.morphTargetForcedOrder.length) for (var m = 0, p = l.morphTargetForcedOrder, q = l.morphTargetInfluences; m < e.numSupportedMorphTargets && m < p.length;) 0 <= d["morphTarget" + m] && (t.bindBuffer(t.ARRAY_BUFFER, f.__webglMorphTargetsBuffers[p[m]]), g(d["morphTarget" + m]), t.vertexAttribPointer(d["morphTarget" + m], 3, t.FLOAT, !1, 0, 0)), 0 <= d["morphNormal" + m] && e.morphNormals && (t.bindBuffer(t.ARRAY_BUFFER,
                        f.__webglMorphNormalsBuffers[p[m]]), g(d["morphNormal" + m]), t.vertexAttribPointer(d["morphNormal" + m], 3, t.FLOAT, !1, 0, 0)), l.__webglMorphTargetInfluences[m] = q[p[m]], m++; else {
                        var p = [], q = l.morphTargetInfluences, r, V = q.length;
                        for (r = 0; r < V; r++) m = q[r], 0 < m && p.push([m, r]);
                        p.length > e.numSupportedMorphTargets ? (p.sort(n), p.length = e.numSupportedMorphTargets) : p.length > e.numSupportedMorphNormals ? p.sort(n) : 0 === p.length && p.push([0, 0]);
                        for (m = 0; m < e.numSupportedMorphTargets;) p[m] ? (r = p[m][1], 0 <= d["morphTarget" + m] && (t.bindBuffer(t.ARRAY_BUFFER,
                            f.__webglMorphTargetsBuffers[r]), g(d["morphTarget" + m]), t.vertexAttribPointer(d["morphTarget" + m], 3, t.FLOAT, !1, 0, 0)), 0 <= d["morphNormal" + m] && e.morphNormals && (t.bindBuffer(t.ARRAY_BUFFER, f.__webglMorphNormalsBuffers[r]), g(d["morphNormal" + m]), t.vertexAttribPointer(d["morphNormal" + m], 3, t.FLOAT, !1, 0, 0)), l.__webglMorphTargetInfluences[m] = q[r]) : l.__webglMorphTargetInfluences[m] = 0, m++
                    }
                    null !== e.program.uniforms.morphTargetInfluences && t.uniform1fv(e.program.uniforms.morphTargetInfluences, l.__webglMorphTargetInfluences)
                }
                if (a) {
                    if (f.__webglCustomAttributesList) for (d =
                                                                0, q = f.__webglCustomAttributesList.length; d < q; d++) p = f.__webglCustomAttributesList[d], 0 <= b[p.buffer.belongsToAttribute] && (t.bindBuffer(t.ARRAY_BUFFER, p.buffer), g(b[p.buffer.belongsToAttribute]), t.vertexAttribPointer(b[p.buffer.belongsToAttribute], p.size, t.FLOAT, !1, 0, 0));
                    0 <= b.color && (0 < l.geometry.colors.length || 0 < l.geometry.faces.length ? (t.bindBuffer(t.ARRAY_BUFFER, f.__webglColorBuffer), g(b.color), t.vertexAttribPointer(b.color, 3, t.FLOAT, !1, 0, 0)) : void 0 !== e.defaultAttributeValues && t.vertexAttrib3fv(b.color,
                        e.defaultAttributeValues.color));
                    0 <= b.normal && (t.bindBuffer(t.ARRAY_BUFFER, f.__webglNormalBuffer), g(b.normal), t.vertexAttribPointer(b.normal, 3, t.FLOAT, !1, 0, 0));
                    0 <= b.tangent && (t.bindBuffer(t.ARRAY_BUFFER, f.__webglTangentBuffer), g(b.tangent), t.vertexAttribPointer(b.tangent, 4, t.FLOAT, !1, 0, 0));
                    0 <= b.uv && (l.geometry.faceVertexUvs[0] ? (t.bindBuffer(t.ARRAY_BUFFER, f.__webglUVBuffer), g(b.uv), t.vertexAttribPointer(b.uv, 2, t.FLOAT, !1, 0, 0)) : void 0 !== e.defaultAttributeValues && t.vertexAttrib2fv(b.uv, e.defaultAttributeValues.uv));
                    0 <= b.uv2 && (l.geometry.faceVertexUvs[1] ? (t.bindBuffer(t.ARRAY_BUFFER, f.__webglUV2Buffer), g(b.uv2), t.vertexAttribPointer(b.uv2, 2, t.FLOAT, !1, 0, 0)) : void 0 !== e.defaultAttributeValues && t.vertexAttrib2fv(b.uv2, e.defaultAttributeValues.uv2));
                    e.skinning && 0 <= b.skinIndex && 0 <= b.skinWeight && (t.bindBuffer(t.ARRAY_BUFFER, f.__webglSkinIndicesBuffer), g(b.skinIndex), t.vertexAttribPointer(b.skinIndex, 4, t.FLOAT, !1, 0, 0), t.bindBuffer(t.ARRAY_BUFFER, f.__webglSkinWeightsBuffer), g(b.skinWeight), t.vertexAttribPointer(b.skinWeight,
                        4, t.FLOAT, !1, 0, 0));
                    0 <= b.lineDistance && (t.bindBuffer(t.ARRAY_BUFFER, f.__webglLineDistanceBuffer), g(b.lineDistance), t.vertexAttribPointer(b.lineDistance, 1, t.FLOAT, !1, 0, 0))
                }
                k();
                l instanceof THREE.Mesh ? (l = f.__typeArray === Uint32Array ? t.UNSIGNED_INT : t.UNSIGNED_SHORT, e.wireframe ? (N(e.wireframeLinewidth), a && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, f.__webglLineBuffer), t.drawElements(t.LINES, f.__webglLineCount, l, 0)) : (a && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, f.__webglFaceBuffer), t.drawElements(t.TRIANGLES, f.__webglFaceCount,
                    l, 0)), Q.info.render.calls++, Q.info.render.vertices += f.__webglFaceCount, Q.info.render.faces += f.__webglFaceCount / 3) : l instanceof THREE.Line ? (l = l.mode === THREE.LineStrip ? t.LINE_STRIP : t.LINES, N(e.linewidth), t.drawArrays(l, 0, f.__webglLineCount), Q.info.render.calls++) : l instanceof THREE.PointCloud && (t.drawArrays(t.POINTS, 0, f.__webglParticleCount), Q.info.render.calls++, Q.info.render.points += f.__webglParticleCount)
            }
        };
        this.render = function (a, b, d, e) {
            if (!1 === b instanceof THREE.Camera) console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            else {
                var g = a.fog;
                Sa = Ea = -1;
                Ya = null;
                Zb = !0;
                !0 === a.autoUpdate && a.updateMatrixWorld();
                void 0 === b.parent && b.updateMatrixWorld();
                X && a.traverse(function (a) {
                    a instanceof THREE.SkinnedMesh && a.skeleton.update()
                });
                ra && b.matrixWorldInverse.getInverse(b.matrixWorld);
                Ab.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
                Tb.setFromMatrix(Ab);
                va.length = 0;
                nb.length = 0;
                ma.length = 0;
                $a.length = 0;
                vb.length = 0;
                q(a, a);
                !0 === Q.sortObjects && (nb.sort(l), ma.sort(m));
                ec.render(a, b);
                Q.info.render.calls = 0;
                Q.info.render.vertices =
                    0;
                Q.info.render.faces = 0;
                Q.info.render.points = 0;
                Q.info.render.programSwitch = 0;
                this.setRenderTarget(d);
                (this.autoClear || e) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
                e = 0;
                for (var h = ya.length; e < h; e++) {
                    var f = ya[e], k = f.object;
                    k.visible && (E(k, b), v(f))
                }
                a.overrideMaterial ? (e = a.overrideMaterial, this.setBlending(e.blending, e.blendEquation, e.blendSrc, e.blendDst), this.setDepthTest(e.depthTest), this.setDepthWrite(e.depthWrite), G(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits),
                    p(nb, b, va, g, !0, e), p(ma, b, va, g, !0, e), r(ya, "", b, va, g, !1, e)) : (e = null, this.setBlending(THREE.NoBlending), p(nb, b, va, g, !1, e), r(ya, "opaque", b, va, g, !1, e), p(ma, b, va, g, !0, e), r(ya, "transparent", b, va, g, !0, e));
                uc.render(a, b);
                Eb.render(a, b, ua, wb);
                d && d.generateMipmaps && d.minFilter !== THREE.NearestFilter && d.minFilter !== THREE.LinearFilter && K(d);
                this.setDepthTest(!0);
                this.setDepthWrite(!0)
            }
        };
        this.renderImmediateObject = function (a, b, d, e, g) {
            var h = F(a, b, d, e, g);
            Ea = -1;
            Q.setMaterialFaces(e);
            g.immediateRenderCallback ? g.immediateRenderCallback(h,
                t, Tb) : g.render(function (a) {
                Q.renderBufferImmediate(a, h, e)
            })
        };
        var Ba = {}, Bb = 0;
        this.setFaceCulling = function (a, b) {
            a === THREE.CullFaceNone ? t.disable(t.CULL_FACE) : (b === THREE.FrontFaceDirectionCW ? t.frontFace(t.CW) : t.frontFace(t.CCW), a === THREE.CullFaceBack ? t.cullFace(t.BACK) : a === THREE.CullFaceFront ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK), t.enable(t.CULL_FACE))
        };
        this.setMaterialFaces = function (a) {
            var b = a.side === THREE.DoubleSide;
            a = a.side === THREE.BackSide;
            cb !== b && (b ? t.disable(t.CULL_FACE) : t.enable(t.CULL_FACE),
                cb = b);
            y !== a && (a ? t.frontFace(t.CW) : t.frontFace(t.CCW), y = a)
        };
        this.setDepthTest = function (a) {
            Za !== a && (a ? t.enable(t.DEPTH_TEST) : t.disable(t.DEPTH_TEST), Za = a)
        };
        this.setDepthWrite = function (a) {
            Ja !== a && (t.depthMask(a), Ja = a)
        };
        this.setBlending = function (a, b, d, e) {
            a !== La && (a === THREE.NoBlending ? t.disable(t.BLEND) : a === THREE.AdditiveBlending ? (t.enable(t.BLEND), t.blendEquation(t.FUNC_ADD), t.blendFunc(t.SRC_ALPHA, t.ONE)) : a === THREE.SubtractiveBlending ? (t.enable(t.BLEND), t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ZERO,
                t.ONE_MINUS_SRC_COLOR)) : a === THREE.MultiplyBlending ? (t.enable(t.BLEND), t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ZERO, t.SRC_COLOR)) : a === THREE.CustomBlending ? t.enable(t.BLEND) : (t.enable(t.BLEND), t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA)), La = a);
            if (a === THREE.CustomBlending) {
                if (b !== ob && (t.blendEquation(L(b)), ob = b), d !== Qa || e !== ta) t.blendFunc(L(d), L(e)), Qa = d, ta = e
            } else ta = Qa = ob = null
        };
        this.uploadTexture = function (a) {
            void 0 ===
            a.__webglInit ? (a.__webglInit = !0, a.addEventListener("dispose", mc), a.__webglTexture = t.createTexture(), Q.info.memory.textures++) : Q.info.memory.textureSz -= a.textureSz;
            a.textureSz = 0;
            t.bindTexture(t.TEXTURE_2D, a.__webglTexture);
            t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, a.flipY);
            t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha);
            t.pixelStorei(t.UNPACK_ALIGNMENT, a.unpackAlignment);
            T || t.pixelStorei(t.UNPACK_ALIGNMENT, a.unpackAlignment);
            a.image = Y(a.image, W);
            var b = a.image, d = THREE.Math.isPowerOfTwo(b.width) &&
                THREE.Math.isPowerOfTwo(b.height), e = L(a.format), g = L(a.type);
            D(t.TEXTURE_2D, a, d);
            var h = a.mipmaps;
            if (a instanceof THREE.DataTexture) if (0 < h.length && d) {
                for (var f = 0, k = h.length; f < k; f++) b = h[f], t.texImage2D(t.TEXTURE_2D, f, e, b.width, b.height, 0, e, g, b.data);
                a.generateMipmaps = !1
            } else t.texImage2D(t.TEXTURE_2D, 0, e, b.width, b.height, 0, e, g, b.data); else if (a instanceof THREE.CompressedTexture) for (f = 0, k = h.length; f < k; f++) b = h[f], a.format !== THREE.RGBAFormat && a.format !== THREE.RGBFormat ? -1 < $b().indexOf(e) ? t.compressedTexImage2D(t.TEXTURE_2D,
                f, e, b.width, b.height, 0, b.data) : console.warn("Attempt to load unsupported compressed texture format") : t.texImage2D(t.TEXTURE_2D, f, e, b.width, b.height, 0, e, g, b.data); else if (0 < h.length && d) {
                f = 0;
                for (k = h.length; f < k; f++) b = h[f], t.texImage2D(t.TEXTURE_2D, f, e, e, g, b), a.textureSz += b.image.width * b.image.height * (b.format === THREE.RGBAFormat ? 4 : 3);
                a.generateMipmaps = !1
            } else t.texImage2D(t.TEXTURE_2D, 0, e, e, g, a.image), a.textureSz += a.image.width * a.image.height * (a.format === THREE.RGBAFormat ? 4 : 3);
            a.generateMipmaps && d && t.generateMipmap(t.TEXTURE_2D);
            a.needsUpdate = !1;
            if (a.onUpdate) a.onUpdate();
            this.info.memory.textureSz += a.textureSz
        };
        this.setTexture = function (a, b) {
            t.activeTexture(t.TEXTURE0 + b);
            a.needsUpdate ? Q.uploadTexture(a) : t.bindTexture(t.TEXTURE_2D, a.__webglTexture)
        };
        this.setRenderTarget = function (a) {
            var b = a instanceof THREE.WebGLRenderTargetCube;
            if (a && void 0 === a.__webglFramebuffer) {
                void 0 === a.depthBuffer && (a.depthBuffer = !0);
                void 0 === a.stencilBuffer && (a.stencilBuffer = !0);
                a.addEventListener("dispose", fc);
                a.__webglTexture = t.createTexture();
                Q.info.memory.textures++;
                var d = THREE.Math.isPowerOfTwo(a.width) && THREE.Math.isPowerOfTwo(a.height), e = L(a.format),
                    g = L(a.type);
                if (b) {
                    a.__webglFramebuffer = [];
                    a.__webglRenderbuffer = [];
                    t.bindTexture(t.TEXTURE_CUBE_MAP, a.__webglTexture);
                    D(t.TEXTURE_CUBE_MAP, a, d);
                    for (var h = 0; 6 > h; h++) {
                        a.__webglFramebuffer[h] = t.createFramebuffer();
                        a.__webglRenderbuffer[h] = t.createRenderbuffer();
                        t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + h, 0, e, a.width, a.height, 0, e, g, null);
                        var f = a, k = t.TEXTURE_CUBE_MAP_POSITIVE_X + h;
                        t.bindFramebuffer(t.FRAMEBUFFER, a.__webglFramebuffer[h]);
                        t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, k, f.__webglTexture, 0);
                        C(a.__webglRenderbuffer[h], a)
                    }
                    d && t.generateMipmap(t.TEXTURE_CUBE_MAP)
                } else a.__webglFramebuffer = t.createFramebuffer(), a.__webglRenderbuffer = a.shareDepthFrom ? a.shareDepthFrom.__webglRenderbuffer : t.createRenderbuffer(), t.bindTexture(t.TEXTURE_2D, a.__webglTexture), D(t.TEXTURE_2D, a, d), t.texImage2D(t.TEXTURE_2D, 0, e, a.width, a.height, 0, e, g, null), e = t.TEXTURE_2D, t.bindFramebuffer(t.FRAMEBUFFER, a.__webglFramebuffer), t.framebufferTexture2D(t.FRAMEBUFFER,
                    t.COLOR_ATTACHMENT0, e, a.__webglTexture, 0), a.shareDepthFrom ? a.depthBuffer && !a.stencilBuffer ? t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, a.__webglRenderbuffer) : a.depthBuffer && a.stencilBuffer && t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, a.__webglRenderbuffer) : C(a.__webglRenderbuffer, a), d && t.generateMipmap(t.TEXTURE_2D);
                b ? t.bindTexture(t.TEXTURE_CUBE_MAP, null) : t.bindTexture(t.TEXTURE_2D, null);
                t.bindRenderbuffer(t.RENDERBUFFER, null);
                t.bindFramebuffer(t.FRAMEBUFFER,
                    null)
            }
            a ? (b = b ? a.__webglFramebuffer[a.activeCubeFace] : a.__webglFramebuffer, d = a.width, a = a.height, g = e = 0) : (b = null, d = ga, a = ub, e = Ma, g = Ua);
            b !== bb && (t.bindFramebuffer(t.FRAMEBUFFER, b), t.viewport(e, g, d, a), bb = b);
            ua = d;
            wb = a
        };
        this.initMaterial = function () {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        };
        this.addPrePlugin = function () {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        };
        this.addPostPlugin = function () {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        };
        this.updateShadowMap = function () {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        }
    };
    THREE.WebGLRenderTarget = function (a, b, d) {
        this.width = a;
        this.height = b;
        d = d || {};
        this.wrapS = void 0 !== d.wrapS ? d.wrapS : THREE.ClampToEdgeWrapping;
        this.wrapT = void 0 !== d.wrapT ? d.wrapT : THREE.ClampToEdgeWrapping;
        this.magFilter = void 0 !== d.magFilter ? d.magFilter : THREE.LinearFilter;
        this.minFilter = void 0 !== d.minFilter ? d.minFilter : THREE.LinearMipMapLinearFilter;
        this.anisotropy = void 0 !== d.anisotropy ? d.anisotropy : 1;
        this.offset = new THREE.Vector2(0, 0);
        this.repeat = new THREE.Vector2(1, 1);
        this.format = void 0 !== d.format ? d.format :
            THREE.RGBAFormat;
        this.type = void 0 !== d.type ? d.type : THREE.UnsignedByteType;
        this.depthBuffer = void 0 !== d.depthBuffer ? d.depthBuffer : !0;
        this.stencilBuffer = void 0 !== d.stencilBuffer ? d.stencilBuffer : !0;
        this.generateMipmaps = !0;
        this.shareDepthFrom = null
    };
    THREE.WebGLRenderTarget.prototype = {
        constructor: THREE.WebGLRenderTarget, setSize: function (a, b) {
            this.width = a;
            this.height = b
        }, clone: function () {
            var a = new THREE.WebGLRenderTarget(this.width, this.height);
            a.wrapS = this.wrapS;
            a.wrapT = this.wrapT;
            a.magFilter = this.magFilter;
            a.minFilter = this.minFilter;
            a.anisotropy = this.anisotropy;
            a.offset.copy(this.offset);
            a.repeat.copy(this.repeat);
            a.format = this.format;
            a.type = this.type;
            a.depthBuffer = this.depthBuffer;
            a.stencilBuffer = this.stencilBuffer;
            a.generateMipmaps = this.generateMipmaps;
            a.shareDepthFrom = this.shareDepthFrom;
            return a
        }, dispose: function () {
            this.dispatchEvent({type: "dispose"})
        }
    };
    THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype);
    THREE.WebGLRenderTargetCube = function (a, b, d) {
        THREE.WebGLRenderTarget.call(this, a, b, d);
        this.activeCubeFace = 0
    };
    THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype);
    THREE.WebGLExtensions = function (a) {
        var b = {};
        this.get = function (d) {
            if (void 0 !== b[d]) return b[d];
            var e;
            switch (d) {
                case "OES_texture_float":
                    e = a.getExtension("OES_texture_float");
                    break;
                case "OES_texture_float_linear":
                    e = a.getExtension("OES_texture_float_linear");
                    break;
                case "OES_standard_derivatives":
                    e = a.getExtension("OES_standard_derivatives");
                    break;
                case "EXT_texture_filter_anisotropic":
                    e = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    e = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    e = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                case "OES_element_index_uint":
                    e = a.getExtension("OES_element_index_uint");
                    break;
                case "EXT_blend_minmax":
                    e = a.getExtension("EXT_blend_minmax");
                    break;
                case "EXT_frag_depth":
                    e = a.getExtension("EXT_frag_depth")
            }
            null === e && console.log("THREE.WebGLRenderer: " + d + " extension not supported.");
            return b[d] = e
        }
    };
    THREE.WebGLProgram = function () {
        var a = 0;
        return function (b, d, e, f) {
            var h = b.context, g = e.defines, k = e.__webglShader.uniforms, l = e.attributes,
                m = e.__webglShader.vertexShader, n = e.__webglShader.fragmentShader, q = e.index0AttributeName;
            void 0 === q && !0 === f.morphTargets && (q = "position");
            var p = "SHADOWMAP_TYPE_BASIC";
            f.shadowMapType === THREE.PCFShadowMap ? p = "SHADOWMAP_TYPE_PCF" : f.shadowMapType === THREE.PCFSoftShadowMap && (p = "SHADOWMAP_TYPE_PCF_SOFT");
            var r, v;
            r = [];
            for (var u in g) v = g[u], !1 !== v && (v = "#define " + u + " " + v, r.push(v));
            r = r.join("\n");
            g = h.createProgram();
            e instanceof THREE.RawShaderMaterial ? b = e = "" : (e = ["precision " + f.precision + " float;", "precision " + f.precision + " int;", r, f.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", b.gammaInput ? "#define GAMMA_INPUT" : "", b.gammaOutput ? "#define GAMMA_OUTPUT" : "", "#define MAX_DIR_LIGHTS " + f.maxDirLights, "#define MAX_POINT_LIGHTS " + f.maxPointLights, "#define MAX_SPOT_LIGHTS " + f.maxSpotLights, "#define MAX_HEMI_LIGHTS " + f.maxHemiLights, "#define MAX_SHADOWS " + f.maxShadows, "#define MAX_BONES " +
            f.maxBones, f.map ? "#define USE_MAP" : "", f.envMap ? "#define USE_ENVMAP" : "", f.lightMap ? "#define USE_LIGHTMAP" : "", f.bumpMap ? "#define USE_BUMPMAP" : "", f.normalMap ? "#define USE_NORMALMAP" : "", f.specularMap ? "#define USE_SPECULARMAP" : "", f.alphaMap ? "#define USE_ALPHAMAP" : "", f.vertexColors ? "#define USE_COLOR" : "", f.skinning ? "#define USE_SKINNING" : "", f.useVertexTexture ? "#define BONE_TEXTURE" : "", f.morphTargets ? "#define USE_MORPHTARGETS" : "", f.morphNormals ? "#define USE_MORPHNORMALS" : "", f.wrapAround ? "#define WRAP_AROUND" :
                "", f.doubleSided ? "#define DOUBLE_SIDED" : "", f.flipSided ? "#define FLIP_SIDED" : "", f.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", f.shadowMapEnabled ? "#define " + p : "", f.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", f.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", f.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", f.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n#ifdef USE_COLOR\n\tattribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n"].join("\n"),
                b = ["precision " + f.precision + " float;", "precision " + f.precision + " int;", f.bumpMap || f.normalMap ? "#extension GL_OES_standard_derivatives : enable" : "", r, "#define MAX_DIR_LIGHTS " + f.maxDirLights, "#define MAX_POINT_LIGHTS " + f.maxPointLights, "#define MAX_SPOT_LIGHTS " + f.maxSpotLights, "#define MAX_HEMI_LIGHTS " + f.maxHemiLights, "#define MAX_SHADOWS " + f.maxShadows, f.alphaTest ? "#define ALPHATEST " + f.alphaTest : "", b.gammaInput ? "#define GAMMA_INPUT" : "", b.gammaOutput ? "#define GAMMA_OUTPUT" : "", f.useFog && f.fog ? "#define USE_FOG" :
                    "", f.useFog && f.fogExp ? "#define FOG_EXP2" : "", f.map ? "#define USE_MAP" : "", f.envMap ? "#define USE_ENVMAP" : "", f.lightMap ? "#define USE_LIGHTMAP" : "", f.bumpMap ? "#define USE_BUMPMAP" : "", f.normalMap ? "#define USE_NORMALMAP" : "", f.specularMap ? "#define USE_SPECULARMAP" : "", f.alphaMap ? "#define USE_ALPHAMAP" : "", f.vertexColors ? "#define USE_COLOR" : "", f.metal ? "#define METAL" : "", f.wrapAround ? "#define WRAP_AROUND" : "", f.doubleSided ? "#define DOUBLE_SIDED" : "", f.flipSided ? "#define FLIP_SIDED" : "", f.shadowMapEnabled ? "#define USE_SHADOWMAP" :
                    "", f.shadowMapEnabled ? "#define " + p : "", f.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", f.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", f.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n"].join("\n"));
            m = new THREE.WebGLShader(h, h.VERTEX_SHADER, e + m);
            n = new THREE.WebGLShader(h, h.FRAGMENT_SHADER, b + n);
            h.attachShader(g, m);
            h.attachShader(g, n);
            void 0 !== q && h.bindAttribLocation(g, 0, q);
            h.linkProgram(g);
            !1 === h.getProgramParameter(g, h.LINK_STATUS) && (console.error("THREE.WebGLProgram: Could not initialise shader."),
                console.error("gl.VALIDATE_STATUS", h.getProgramParameter(g, h.VALIDATE_STATUS)), console.error("gl.getError()", h.getError()));
            "" !== h.getProgramInfoLog(g) && console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", h.getProgramInfoLog(g));
            h.deleteShader(m);
            h.deleteShader(n);
            q = "viewMatrix modelViewMatrix projectionMatrix normalMatrix modelMatrix cameraPosition morphTargetInfluences bindMatrix bindMatrixInverse".split(" ");
            f.useVertexTexture ? (q.push("boneTexture"), q.push("boneTextureWidth"), q.push("boneTextureHeight")) :
                q.push("boneGlobalMatrices");
            f.logarithmicDepthBuffer && q.push("logDepthBufFC");
            for (var x in k) q.push(x);
            k = q;
            x = {};
            q = 0;
            for (b = k.length; q < b; q++) p = k[q], x[p] = h.getUniformLocation(g, p);
            this.uniforms = x;
            q = "position normal uv uv2 tangent color skinIndex skinWeight lineDistance".split(" ");
            for (k = 0; k < f.maxMorphTargets; k++) q.push("morphTarget" + k);
            for (k = 0; k < f.maxMorphNormals; k++) q.push("morphNormal" + k);
            for (var w in l) q.push(w);
            f = q;
            l = {};
            w = 0;
            for (k = f.length; w < k; w++) x = f[w], l[x] = h.getAttribLocation(g, x);
            this.attributes =
                l;
            this.attributesKeys = Object.keys(this.attributes);
            this.id = a++;
            this.code = d;
            this.usedTimes = 1;
            this.program = g;
            this.vertexShader = m;
            this.fragmentShader = n;
            return this
        }
    }();
    THREE.WebGLShader = function () {
        var a = function (a) {
            a = a.split("\n");
            for (var d = 0; d < a.length; d++) a[d] = d + 1 + ": " + a[d];
            return a.join("\n")
        };
        return function (b, d, e) {
            d = b.createShader(d);
            b.shaderSource(d, e);
            b.compileShader(d);
            !1 === b.getShaderParameter(d, b.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile.");
            "" !== b.getShaderInfoLog(d) && (console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", b.getShaderInfoLog(d)), console.warn(a(e)));
            return d
        }
    }();
    THREE.LensFlarePlugin = function (a, b) {
        var d, e, f, h, g, k, l, m, n, q, p = a.context, r, v, u, x, w, z;
        this.render = function (F, B, H, E) {
            if (0 !== b.length) {
                F = new THREE.Vector3;
                var I = E / H, A = .5 * H, N = .5 * E, G = 16 / E, D = new THREE.Vector2(G * I, G),
                    Y = new THREE.Vector3(1, 1, 0), C = new THREE.Vector2(1, 1);
                if (void 0 === u) {
                    var G = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]),
                        K = new Uint16Array([0, 1, 2, 0, 2, 3]);
                    r = p.createBuffer();
                    v = p.createBuffer();
                    p.bindBuffer(p.ARRAY_BUFFER, r);
                    p.bufferData(p.ARRAY_BUFFER, G, p.STATIC_DRAW);
                    p.bindBuffer(p.ELEMENT_ARRAY_BUFFER,
                        v);
                    p.bufferData(p.ELEMENT_ARRAY_BUFFER, K, p.STATIC_DRAW);
                    w = p.createTexture();
                    z = p.createTexture();
                    p.bindTexture(p.TEXTURE_2D, w);
                    p.texImage2D(p.TEXTURE_2D, 0, p.RGB, 16, 16, 0, p.RGB, p.UNSIGNED_BYTE, null);
                    p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, p.CLAMP_TO_EDGE);
                    p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, p.CLAMP_TO_EDGE);
                    p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, p.NEAREST);
                    p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, p.NEAREST);
                    p.bindTexture(p.TEXTURE_2D, z);
                    p.texImage2D(p.TEXTURE_2D, 0,
                        p.RGBA, 16, 16, 0, p.RGBA, p.UNSIGNED_BYTE, null);
                    p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, p.CLAMP_TO_EDGE);
                    p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, p.CLAMP_TO_EDGE);
                    p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, p.NEAREST);
                    p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, p.NEAREST);
                    var G = (x = 0 < p.getParameter(p.MAX_VERTEX_TEXTURE_IMAGE_UNITS)) ? {
                            vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
                            fragmentShader: "uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
                        } : {
                            vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
                            fragmentShader: "precision mediump float;\nuniform lowp int renderType;\nuniform sampler2D map;\nuniform sampler2D occlusionMap;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nfloat visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\nvisibility = ( 1.0 - visibility / 4.0 );\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * visibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
                        },
                        K = p.createProgram(), J = p.createShader(p.FRAGMENT_SHADER),
                        L = p.createShader(p.VERTEX_SHADER), U = "precision " + a.getPrecision() + " float;\n";
                    p.shaderSource(J, U + G.fragmentShader);
                    p.shaderSource(L, U + G.vertexShader);
                    p.compileShader(J);
                    p.compileShader(L);
                    p.attachShader(K, J);
                    p.attachShader(K, L);
                    p.linkProgram(K);
                    u = K;
                    n = p.getAttribLocation(u, "position");
                    q = p.getAttribLocation(u, "uv");
                    d = p.getUniformLocation(u, "renderType");
                    e = p.getUniformLocation(u, "map");
                    f = p.getUniformLocation(u, "occlusionMap");
                    h = p.getUniformLocation(u,
                        "opacity");
                    g = p.getUniformLocation(u, "color");
                    k = p.getUniformLocation(u, "scale");
                    l = p.getUniformLocation(u, "rotation");
                    m = p.getUniformLocation(u, "screenPosition")
                }
                p.useProgram(u);
                p.enableVertexAttribArray(n);
                p.enableVertexAttribArray(q);
                p.uniform1i(f, 0);
                p.uniform1i(e, 1);
                p.bindBuffer(p.ARRAY_BUFFER, r);
                p.vertexAttribPointer(n, 2, p.FLOAT, !1, 16, 0);
                p.vertexAttribPointer(q, 2, p.FLOAT, !1, 16, 8);
                p.bindBuffer(p.ELEMENT_ARRAY_BUFFER, v);
                p.disable(p.CULL_FACE);
                p.depthMask(!1);
                K = 0;
                for (J = b.length; K < J; K++) if (G = 16 / E, D.set(G *
                        I, G), L = b[K], F.set(L.matrixWorld.elements[12], L.matrixWorld.elements[13], L.matrixWorld.elements[14]), F.applyMatrix4(B.matrixWorldInverse), F.applyProjection(B.projectionMatrix), Y.copy(F), C.x = Y.x * A + A, C.y = Y.y * N + N, x || 0 < C.x && C.x < H && 0 < C.y && C.y < E) {
                    p.activeTexture(p.TEXTURE1);
                    p.bindTexture(p.TEXTURE_2D, w);
                    p.copyTexImage2D(p.TEXTURE_2D, 0, p.RGB, C.x - 8, C.y - 8, 16, 16, 0);
                    p.uniform1i(d, 0);
                    p.uniform2f(k, D.x, D.y);
                    p.uniform3f(m, Y.x, Y.y, Y.z);
                    p.disable(p.BLEND);
                    p.enable(p.DEPTH_TEST);
                    p.drawElements(p.TRIANGLES, 6, p.UNSIGNED_SHORT,
                        0);
                    p.activeTexture(p.TEXTURE0);
                    p.bindTexture(p.TEXTURE_2D, z);
                    p.copyTexImage2D(p.TEXTURE_2D, 0, p.RGBA, C.x - 8, C.y - 8, 16, 16, 0);
                    p.uniform1i(d, 1);
                    p.disable(p.DEPTH_TEST);
                    p.activeTexture(p.TEXTURE1);
                    p.bindTexture(p.TEXTURE_2D, w);
                    p.drawElements(p.TRIANGLES, 6, p.UNSIGNED_SHORT, 0);
                    L.positionScreen.copy(Y);
                    L.customUpdateCallback ? L.customUpdateCallback(L) : L.updateLensFlares();
                    p.uniform1i(d, 2);
                    p.enable(p.BLEND);
                    for (var U = 0, aa = L.lensFlares.length; U < aa; U++) {
                        var Z = L.lensFlares[U];
                        .001 < Z.opacity && .001 < Z.scale && (Y.x =
                            Z.x, Y.y = Z.y, Y.z = Z.z, G = Z.size * Z.scale / E, D.x = G * I, D.y = G, p.uniform3f(m, Y.x, Y.y, Y.z), p.uniform2f(k, D.x, D.y), p.uniform1f(l, Z.rotation), p.uniform1f(h, Z.opacity), p.uniform3f(g, Z.color.r, Z.color.g, Z.color.b), a.setBlending(Z.blending, Z.blendEquation, Z.blendSrc, Z.blendDst), a.setTexture(Z.texture, 1), p.drawElements(p.TRIANGLES, 6, p.UNSIGNED_SHORT, 0))
                    }
                }
                p.enable(p.CULL_FACE);
                p.enable(p.DEPTH_TEST);
                p.depthMask(!0);
                a.resetGLState()
            }
        }
    };
    THREE.ShadowMapPlugin = function (a, b, d, e) {
        function f(a, b, e) {
            if (b.visible) {
                var g = d[b.id];
                if (g && b.castShadow && (!1 === b.frustumCulled || !0 === n.intersectsObject(b))) for (var h = 0, k = g.length; h < k; h++) {
                    var l = g[h];
                    b._modelViewMatrix.multiplyMatrices(e.matrixWorldInverse, b.matrixWorld);
                    u.push(l)
                }
                h = 0;
                for (k = b.children.length; h < k; h++) f(a, b.children[h], e)
            }
        }

        var h = a.context, g, k, l, m, n = new THREE.Frustum, q = new THREE.Matrix4, p = new THREE.Vector3,
            r = new THREE.Vector3, v = new THREE.Vector3, u = [], x = THREE.ShaderLib.depthRGBA,
            w = THREE.UniformsUtils.clone(x.uniforms);
        g = new THREE.ShaderMaterial({uniforms: w, vertexShader: x.vertexShader, fragmentShader: x.fragmentShader});
        k = new THREE.ShaderMaterial({
            uniforms: w,
            vertexShader: x.vertexShader,
            fragmentShader: x.fragmentShader,
            morphTargets: !0
        });
        l = new THREE.ShaderMaterial({
            uniforms: w,
            vertexShader: x.vertexShader,
            fragmentShader: x.fragmentShader,
            skinning: !0
        });
        m = new THREE.ShaderMaterial({
            uniforms: w,
            vertexShader: x.vertexShader,
            fragmentShader: x.fragmentShader,
            morphTargets: !0,
            skinning: !0
        });
        g._shadowPass = !0;
        k._shadowPass = !0;
        l._shadowPass =
            !0;
        m._shadowPass = !0;
        this.render = function (d, x) {
            if (!1 !== a.shadowMapEnabled) {
                var w, H, E, I, A, N, G, D, Y = [];
                I = 0;
                h.clearColor(1, 1, 1, 1);
                h.disable(h.BLEND);
                h.enable(h.CULL_FACE);
                h.frontFace(h.CCW);
                a.shadowMapCullFace === THREE.CullFaceFront ? h.cullFace(h.FRONT) : h.cullFace(h.BACK);
                a.setDepthTest(!0);
                w = 0;
                for (H = b.length; w < H; w++) if (E = b[w], E.castShadow) if (E instanceof THREE.DirectionalLight && E.shadowCascade) for (A = 0; A < E.shadowCascadeCount; A++) {
                    var C;
                    if (E.shadowCascadeArray[A]) C = E.shadowCascadeArray[A]; else {
                        G = E;
                        var K =
                            A;
                        C = new THREE.DirectionalLight;
                        C.isVirtual = !0;
                        C.onlyShadow = !0;
                        C.castShadow = !0;
                        C.shadowCameraNear = G.shadowCameraNear;
                        C.shadowCameraFar = G.shadowCameraFar;
                        C.shadowCameraLeft = G.shadowCameraLeft;
                        C.shadowCameraRight = G.shadowCameraRight;
                        C.shadowCameraBottom = G.shadowCameraBottom;
                        C.shadowCameraTop = G.shadowCameraTop;
                        C.shadowCameraVisible = G.shadowCameraVisible;
                        C.shadowDarkness = G.shadowDarkness;
                        C.shadowBias = G.shadowCascadeBias[K];
                        C.shadowMapWidth = G.shadowCascadeWidth[K];
                        C.shadowMapHeight = G.shadowCascadeHeight[K];
                        C.pointsWorld = [];
                        C.pointsFrustum = [];
                        D = C.pointsWorld;
                        N = C.pointsFrustum;
                        for (var J = 0; 8 > J; J++) D[J] = new THREE.Vector3, N[J] = new THREE.Vector3;
                        D = G.shadowCascadeNearZ[K];
                        G = G.shadowCascadeFarZ[K];
                        N[0].set(-1, -1, D);
                        N[1].set(1, -1, D);
                        N[2].set(-1, 1, D);
                        N[3].set(1, 1, D);
                        N[4].set(-1, -1, G);
                        N[5].set(1, -1, G);
                        N[6].set(-1, 1, G);
                        N[7].set(1, 1, G);
                        C.originalCamera = x;
                        N = new THREE.Gyroscope;
                        N.position.copy(E.shadowCascadeOffset);
                        N.add(C);
                        N.add(C.target);
                        x.add(N);
                        E.shadowCascadeArray[A] = C;
                        console.log("Created virtualLight", C)
                    }
                    K =
                        E;
                    D = A;
                    G = K.shadowCascadeArray[D];
                    G.position.copy(K.position);
                    G.target.position.copy(K.target.position);
                    G.lookAt(G.target);
                    G.shadowCameraVisible = K.shadowCameraVisible;
                    G.shadowDarkness = K.shadowDarkness;
                    G.shadowBias = K.shadowCascadeBias[D];
                    N = K.shadowCascadeNearZ[D];
                    K = K.shadowCascadeFarZ[D];
                    G = G.pointsFrustum;
                    G[0].z = N;
                    G[1].z = N;
                    G[2].z = N;
                    G[3].z = N;
                    G[4].z = K;
                    G[5].z = K;
                    G[6].z = K;
                    G[7].z = K;
                    Y[I] = C;
                    I++
                } else Y[I] = E, I++;
                w = 0;
                for (H = Y.length; w < H; w++) {
                    E = Y[w];
                    E.shadowMap || (A = THREE.LinearFilter, a.shadowMapType === THREE.PCFSoftShadowMap &&
                    (A = THREE.NearestFilter), E.shadowMap = new THREE.WebGLRenderTarget(E.shadowMapWidth, E.shadowMapHeight, {
                        minFilter: A,
                        magFilter: A,
                        format: THREE.RGBAFormat
                    }), E.shadowMapSize = new THREE.Vector2(E.shadowMapWidth, E.shadowMapHeight), E.shadowMatrix = new THREE.Matrix4);
                    if (!E.shadowCamera) {
                        if (E instanceof THREE.SpotLight) E.shadowCamera = new THREE.PerspectiveCamera(E.shadowCameraFov, E.shadowMapWidth / E.shadowMapHeight, E.shadowCameraNear, E.shadowCameraFar); else if (E instanceof THREE.DirectionalLight) E.shadowCamera = new THREE.OrthographicCamera(E.shadowCameraLeft,
                            E.shadowCameraRight, E.shadowCameraTop, E.shadowCameraBottom, E.shadowCameraNear, E.shadowCameraFar); else {
                            console.error("Unsupported light type for shadow");
                            continue
                        }
                        d.add(E.shadowCamera);
                        !0 === d.autoUpdate && d.updateMatrixWorld()
                    }
                    E.shadowCameraVisible && !E.cameraHelper && (E.cameraHelper = new THREE.CameraHelper(E.shadowCamera), d.add(E.cameraHelper));
                    if (E.isVirtual && C.originalCamera == x) {
                        A = x;
                        I = E.shadowCamera;
                        N = E.pointsFrustum;
                        G = E.pointsWorld;
                        p.set(Infinity, Infinity, Infinity);
                        r.set(-Infinity, -Infinity, -Infinity);
                        for (K = 0; 8 > K; K++) D = G[K], D.copy(N[K]), D.unproject(A), D.applyMatrix4(I.matrixWorldInverse), D.x < p.x && (p.x = D.x), D.x > r.x && (r.x = D.x), D.y < p.y && (p.y = D.y), D.y > r.y && (r.y = D.y), D.z < p.z && (p.z = D.z), D.z > r.z && (r.z = D.z);
                        I.left = p.x;
                        I.right = r.x;
                        I.top = r.y;
                        I.bottom = p.y;
                        I.updateProjectionMatrix()
                    }
                    I = E.shadowMap;
                    N = E.shadowMatrix;
                    A = E.shadowCamera;
                    A.position.setFromMatrixPosition(E.matrixWorld);
                    v.setFromMatrixPosition(E.target.matrixWorld);
                    A.lookAt(v);
                    A.updateMatrixWorld();
                    A.matrixWorldInverse.getInverse(A.matrixWorld);
                    E.cameraHelper &&
                    (E.cameraHelper.visible = E.shadowCameraVisible);
                    E.shadowCameraVisible && E.cameraHelper.update();
                    N.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1);
                    N.multiply(A.projectionMatrix);
                    N.multiply(A.matrixWorldInverse);
                    q.multiplyMatrices(A.projectionMatrix, A.matrixWorldInverse);
                    n.setFromMatrix(q);
                    a.setRenderTarget(I);
                    a.clear();
                    u.length = 0;
                    f(d, d, A);
                    E = 0;
                    for (I = u.length; E < I; E++) G = u[E], N = G.object, G = G.buffer, K = N.material instanceof THREE.MeshFaceMaterial ? N.material.materials[0] : N.material, D = void 0 !== N.geometry.morphTargets &&
                        0 < N.geometry.morphTargets.length && K.morphTargets, J = N instanceof THREE.SkinnedMesh && K.skinning, D = N.customDepthMaterial ? N.customDepthMaterial : J ? D ? m : l : D ? k : g, a.setMaterialFaces(K), G instanceof THREE.BufferGeometry ? a.renderBufferDirect(A, b, null, D, G, N) : a.renderBuffer(A, b, null, D, G, N);
                    E = 0;
                    for (I = e.length; E < I; E++) G = e[E], N = G.object, N.visible && N.castShadow && (N._modelViewMatrix.multiplyMatrices(A.matrixWorldInverse, N.matrixWorld), a.renderImmediateObject(A, b, null, g, N))
                }
                w = a.getClearColor();
                H = a.getClearAlpha();
                h.clearColor(w.r,
                    w.g, w.b, H);
                h.enable(h.BLEND);
                a.shadowMapCullFace === THREE.CullFaceFront && h.cullFace(h.BACK);
                a.resetGLState()
            }
        }
    };
    THREE.SpritePlugin = function (a, b) {
        var d, e, f, h, g, k, l, m, n, q, p, r, v, u, x, w, z;

        function F(a, b) {
            return a.z !== b.z ? b.z - a.z : b.id - a.id
        }

        var B = a.context, H, E, I, A;
        this.render = function (N, G) {
            if (0 !== b.length) {
                if (void 0 === I) {
                    var D = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]),
                        Y = new Uint16Array([0, 1, 2, 0, 2, 3]);
                    H = B.createBuffer();
                    E = B.createBuffer();
                    B.bindBuffer(B.ARRAY_BUFFER, H);
                    B.bufferData(B.ARRAY_BUFFER, D, B.STATIC_DRAW);
                    B.bindBuffer(B.ELEMENT_ARRAY_BUFFER, E);
                    B.bufferData(B.ELEMENT_ARRAY_BUFFER, Y, B.STATIC_DRAW);
                    var D = B.createProgram(), Y = B.createShader(B.VERTEX_SHADER),
                        C = B.createShader(B.FRAGMENT_SHADER);
                    B.shaderSource(Y, ["precision " + a.getPrecision() + " float;", "uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}"].join("\n"));
                    B.shaderSource(C, ["precision " + a.getPrecision() + " float;", "uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}"].join("\n"));
                    B.compileShader(Y);
                    B.compileShader(C);
                    B.attachShader(D, Y);
                    B.attachShader(D, C);
                    B.linkProgram(D);
                    I = D;
                    w = B.getAttribLocation(I, "position");
                    z = B.getAttribLocation(I, "uv");
                    d = B.getUniformLocation(I, "uvOffset");
                    e = B.getUniformLocation(I, "uvScale");
                    f = B.getUniformLocation(I, "rotation");
                    h = B.getUniformLocation(I, "scale");
                    g = B.getUniformLocation(I, "color");
                    k = B.getUniformLocation(I, "map");
                    l = B.getUniformLocation(I, "opacity");
                    m = B.getUniformLocation(I, "modelViewMatrix");
                    n = B.getUniformLocation(I, "projectionMatrix");
                    q =
                        B.getUniformLocation(I, "fogType");
                    p = B.getUniformLocation(I, "fogDensity");
                    r = B.getUniformLocation(I, "fogNear");
                    v = B.getUniformLocation(I, "fogFar");
                    u = B.getUniformLocation(I, "fogColor");
                    x = B.getUniformLocation(I, "alphaTest");
                    D = document.createElement("canvas");
                    D.width = 8;
                    D.height = 8;
                    Y = D.getContext("2d");
                    Y.fillStyle = "white";
                    Y.fillRect(0, 0, 8, 8);
                    A = new THREE.Texture(D);
                    A.needsUpdate = !0
                }
                B.useProgram(I);
                B.enableVertexAttribArray(w);
                B.enableVertexAttribArray(z);
                B.disable(B.CULL_FACE);
                B.enable(B.BLEND);
                B.bindBuffer(B.ARRAY_BUFFER,
                    H);
                B.vertexAttribPointer(w, 2, B.FLOAT, !1, 16, 0);
                B.vertexAttribPointer(z, 2, B.FLOAT, !1, 16, 8);
                B.bindBuffer(B.ELEMENT_ARRAY_BUFFER, E);
                B.uniformMatrix4fv(n, !1, G.projectionMatrix.elements);
                B.activeTexture(B.TEXTURE0);
                B.uniform1i(k, 0);
                Y = D = 0;
                (C = N.fog) ? (B.uniform3f(u, C.color.r, C.color.g, C.color.b), C instanceof THREE.Fog ? (B.uniform1f(r, C.near), B.uniform1f(v, C.far), B.uniform1i(q, 1), Y = D = 1) : C instanceof THREE.FogExp2 && (B.uniform1f(p, C.density), B.uniform1i(q, 2), Y = D = 2)) : (B.uniform1i(q, 0), Y = D = 0);
                for (var C = 0, K = b.length; C <
                K; C++) {
                    var J = b[C];
                    J._modelViewMatrix.multiplyMatrices(G.matrixWorldInverse, J.matrixWorld);
                    J.z = null === J.renderDepth ? -J._modelViewMatrix.elements[14] : J.renderDepth
                }
                b.sort(F);
                for (var L = [], C = 0, K = b.length; C < K; C++) {
                    var J = b[C], U = J.material;
                    B.uniform1f(x, U.alphaTest);
                    B.uniformMatrix4fv(m, !1, J._modelViewMatrix.elements);
                    L[0] = J.scale.x;
                    L[1] = J.scale.y;
                    J = 0;
                    N.fog && U.fog && (J = Y);
                    D !== J && (B.uniform1i(q, J), D = J);
                    null !== U.map ? (B.uniform2f(d, U.map.offset.x, U.map.offset.y), B.uniform2f(e, U.map.repeat.x, U.map.repeat.y)) :
                        (B.uniform2f(d, 0, 0), B.uniform2f(e, 1, 1));
                    B.uniform1f(l, U.opacity);
                    B.uniform3f(g, U.color.r, U.color.g, U.color.b);
                    B.uniform1f(f, U.rotation);
                    B.uniform2fv(h, L);
                    a.setBlending(U.blending, U.blendEquation, U.blendSrc, U.blendDst);
                    a.setDepthTest(U.depthTest);
                    a.setDepthWrite(U.depthWrite);
                    U.map && U.map.image && U.map.image.width ? a.setTexture(U.map, 0) : a.setTexture(A, 0);
                    B.drawElements(B.TRIANGLES, 6, B.UNSIGNED_SHORT, 0)
                }
                B.enable(B.CULL_FACE);
                a.resetGLState()
            }
        }
    };
    THREE.GeometryUtils = {
        merge: function (a, b, d) {
            console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
            var e;
            b instanceof THREE.Mesh && (b.matrixAutoUpdate && b.updateMatrix(), e = b.matrix, b = b.geometry);
            a.merge(b, e, d)
        }, center: function (a) {
            console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.");
            return a.center()
        }
    };
    THREE.ImageUtils = {
        crossOrigin: void 0, loadTexture: function (a, b, d, e) {
            var f = new THREE.ImageLoader;
            f.crossOrigin = this.crossOrigin;
            var h = new THREE.Texture(void 0, b);
            h._loadingimage = f.load(a, function (a) {
                h._loadingimage = null;
                h.image = a;
                h.needsUpdate = !0;
                d && d(h)
            }, void 0, function (a) {
                e && e(a);
                h._loadingimage = null
            });
            h.sourceFile = a;
            return h
        }, loadTextureCube: function (a, b, d, e) {
            var f = new THREE.ImageLoader;
            f.crossOrigin = this.crossOrigin;
            var h = new THREE.CubeTexture([], b);
            h.flipY = !1;
            var g = 0;
            b = function (b) {
                f.load(a[b],
                    function (a) {
                        h.images[b] = a;
                        g += 1;
                        6 === g && (h.needsUpdate = !0, d && d(h))
                    })
            };
            e = 0;
            for (var k = a.length; e < k; ++e) b(e);
            return h
        }, loadCompressedTexture: function () {
            console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
        }, loadCompressedTextureCube: function () {
            console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
        }, getNormalMap: function (a, b) {
            var d = function (a) {
                var b = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
                return [a[0] / b,
                    a[1] / b, a[2] / b]
            };
            b |= 1;
            var e = a.width, f = a.height, h = document.createElement("canvas");
            h.width = e;
            h.height = f;
            var g = h.getContext("2d");
            g.drawImage(a, 0, 0);
            for (var k = g.getImageData(0, 0, e, f).data, l = g.createImageData(e, f), m = l.data, n = 0; n < e; n++) for (var q = 0; q < f; q++) {
                var p = 0 > q - 1 ? 0 : q - 1, r = q + 1 > f - 1 ? f - 1 : q + 1, v = 0 > n - 1 ? 0 : n - 1,
                    u = n + 1 > e - 1 ? e - 1 : n + 1, x = [], w = [0, 0, k[4 * (q * e + n)] / 255 * b];
                x.push([-1, 0, k[4 * (q * e + v)] / 255 * b]);
                x.push([-1, -1, k[4 * (p * e + v)] / 255 * b]);
                x.push([0, -1, k[4 * (p * e + n)] / 255 * b]);
                x.push([1, -1, k[4 * (p * e + u)] / 255 * b]);
                x.push([1, 0,
                    k[4 * (q * e + u)] / 255 * b]);
                x.push([1, 1, k[4 * (r * e + u)] / 255 * b]);
                x.push([0, 1, k[4 * (r * e + n)] / 255 * b]);
                x.push([-1, 1, k[4 * (r * e + v)] / 255 * b]);
                p = [];
                v = x.length;
                for (r = 0; r < v; r++) {
                    var u = x[r], z = x[(r + 1) % v], u = [u[0] - w[0], u[1] - w[1], u[2] - w[2]],
                        z = [z[0] - w[0], z[1] - w[1], z[2] - w[2]];
                    p.push(d([u[1] * z[2] - u[2] * z[1], u[2] * z[0] - u[0] * z[2], u[0] * z[1] - u[1] * z[0]]))
                }
                x = [0, 0, 0];
                for (r = 0; r < p.length; r++) x[0] += p[r][0], x[1] += p[r][1], x[2] += p[r][2];
                x[0] /= p.length;
                x[1] /= p.length;
                x[2] /= p.length;
                w = 4 * (q * e + n);
                m[w] = (x[0] + 1) / 2 * 255 | 0;
                m[w + 1] = (x[1] + 1) / 2 * 255 | 0;
                m[w +
                2] = 255 * x[2] | 0;
                m[w + 3] = 255
            }
            g.putImageData(l, 0, 0);
            return h
        }, generateDataTexture: function (a, b, d) {
            var e = a * b, f = new Uint8Array(3 * e), h = Math.floor(255 * d.r), g = Math.floor(255 * d.g);
            d = Math.floor(255 * d.b);
            for (var k = 0; k < e; k++) f[3 * k] = h, f[3 * k + 1] = g, f[3 * k + 2] = d;
            a = new THREE.DataTexture(f, a, b, THREE.RGBFormat);
            a.needsUpdate = !0;
            return a
        }
    };
    THREE.SceneUtils = {
        createMultiMaterialObject: function (a, b) {
            for (var d = new THREE.Object3D, e = 0, f = b.length; e < f; e++) d.add(new THREE.Mesh(a, b[e]));
            return d
        }, detach: function (a, b, d) {
            a.applyMatrix(b.matrixWorld);
            b.remove(a);
            d.add(a)
        }, attach: function (a, b, d) {
            var e = new THREE.Matrix4;
            e.getInverse(d.matrixWorld);
            a.applyMatrix(e);
            b.remove(a);
            d.add(a)
        }
    };
    THREE.FontUtils = {
        faces: {},
        face: "helvetiker",
        weight: "normal",
        style: "normal",
        size: 150,
        divisions: 10,
        getFace: function () {
            try {
                return this.faces[this.face][this.weight][this.style]
            } catch (a) {
                throw"The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing.";
            }
        },
        loadFace: function (a) {
            var b = a.familyName.toLowerCase();
            this.faces[b] = this.faces[b] || {};
            this.faces[b][a.cssFontWeight] = this.faces[b][a.cssFontWeight] || {};
            this.faces[b][a.cssFontWeight][a.cssFontStyle] = a;
            return this.faces[b][a.cssFontWeight][a.cssFontStyle] =
                a
        },
        drawText: function (a) {
            var b = this.getFace(), d = this.size / b.resolution, e = 0, f = String(a).split(""), h = f.length, g = [];
            for (a = 0; a < h; a++) {
                var k = new THREE.Path, k = this.extractGlyphPoints(f[a], b, d, e, k), e = e + k.offset;
                g.push(k.path)
            }
            return {paths: g, offset: e / 2}
        },
        extractGlyphPoints: function (a, b, d, e, f) {
            var h = [], g, k, l, m, n, q, p, r, v, u, x, w = b.glyphs[a] || b.glyphs["?"];
            if (w) {
                if (w.o) for (b = w._cachedOutline || (w._cachedOutline = w.o.split(" ")), m = b.length, a = 0; a < m;) switch (l = b[a++], l) {
                    case "m":
                        l = b[a++] * d + e;
                        n = b[a++] * d;
                        f.moveTo(l, n);
                        break;
                    case "l":
                        l = b[a++] * d + e;
                        n = b[a++] * d;
                        f.lineTo(l, n);
                        break;
                    case "q":
                        l = b[a++] * d + e;
                        n = b[a++] * d;
                        r = b[a++] * d + e;
                        v = b[a++] * d;
                        f.quadraticCurveTo(r, v, l, n);
                        if (g = h[h.length - 1]) for (q = g.x, p = g.y, g = 1, k = this.divisions; g <= k; g++) {
                            var z = g / k;
                            THREE.Shape.Utils.b2(z, q, r, l);
                            THREE.Shape.Utils.b2(z, p, v, n)
                        }
                        break;
                    case "b":
                        if (l = b[a++] * d + e, n = b[a++] * d, r = b[a++] * d + e, v = b[a++] * d, u = b[a++] * d + e, x = b[a++] * d, f.bezierCurveTo(r, v, u, x, l, n), g = h[h.length - 1]) for (q = g.x, p = g.y, g = 1, k = this.divisions; g <= k; g++) z = g / k, THREE.Shape.Utils.b3(z, q, r, u, l), THREE.Shape.Utils.b3(z,
                            p, v, x, n)
                }
                return {offset: w.ha * d, path: f}
            }
        }
    };
    THREE.FontUtils.generateShapes = function (a, b) {
        b = b || {};
        var d = void 0 !== b.curveSegments ? b.curveSegments : 4, e = void 0 !== b.font ? b.font : "helvetiker",
            f = void 0 !== b.weight ? b.weight : "normal", h = void 0 !== b.style ? b.style : "normal";
        THREE.FontUtils.size = void 0 !== b.size ? b.size : 100;
        THREE.FontUtils.divisions = d;
        THREE.FontUtils.face = e;
        THREE.FontUtils.weight = f;
        THREE.FontUtils.style = h;
        d = THREE.FontUtils.drawText(a).paths;
        e = [];
        f = 0;
        for (h = d.length; f < h; f++) Array.prototype.push.apply(e, d[f].toShapes());
        return e
    };
    (function (a) {
        var b = function (a) {
            for (var b = a.length, f = 0, h = b - 1, g = 0; g < b; h = g++) f += a[h].x * a[g].y - a[g].x * a[h].y;
            return .5 * f
        };
        a.Triangulate = function (a, e) {
            var f = a.length;
            if (3 > f) return null;
            var h = [], g = [], k = [], l, m, n;
            if (0 < b(a)) for (m = 0; m < f; m++) g[m] = m; else for (m = 0; m < f; m++) g[m] = f - 1 - m;
            var q = 2 * f;
            for (m = f - 1; 2 < f;) {
                if (0 >= q--) {
                    console.log("Warning, unable to triangulate polygon!");
                    break
                }
                l = m;
                f <= l && (l = 0);
                m = l + 1;
                f <= m && (m = 0);
                n = m + 1;
                f <= n && (n = 0);
                var p;
                a:{
                    var r = p = void 0, v = void 0, u = void 0, x = void 0, w = void 0, z = void 0, F = void 0,
                        B = void 0,
                        r = a[g[l]].x, v = a[g[l]].y, u = a[g[m]].x, x = a[g[m]].y, w = a[g[n]].x, z = a[g[n]].y;
                    if (1E-10 > (u - r) * (z - v) - (x - v) * (w - r)) p = !1; else {
                        var H = void 0, E = void 0, I = void 0, A = void 0, N = void 0, G = void 0, D = void 0,
                            Y = void 0, C = void 0, K = void 0, C = Y = D = B = F = void 0, H = w - u, E = z - x,
                            I = r - w, A = v - z, N = u - r, G = x - v;
                        for (p = 0; p < f; p++) if (F = a[g[p]].x, B = a[g[p]].y, !(F === r && B === v || F === u && B === x || F === w && B === z) && (D = F - r, Y = B - v, C = F - u, K = B - x, F -= w, B -= z, C = H * K - E * C, D = N * Y - G * D, Y = I * B - A * F, -1E-10 <= C && -1E-10 <= Y && -1E-10 <= D)) {
                            p = !1;
                            break a
                        }
                        p = !0
                    }
                }
                if (p) {
                    h.push([a[g[l]], a[g[m]], a[g[n]]]);
                    k.push([g[l], g[m], g[n]]);
                    l = m;
                    for (n = m + 1; n < f; l++, n++) g[l] = g[n];
                    f--;
                    q = 2 * f
                }
            }
            return e ? k : h
        };
        a.Triangulate.area = b;
        return a
    })(THREE.FontUtils);
    self._typeface_js = {faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace};
    THREE.typeface_js = self._typeface_js;
    THREE.Audio = function (a) {
        THREE.Object3D.call(this);
        this.type = "Audio";
        this.context = a.context;
        this.source = this.context.createBufferSource();
        this.gain = this.context.createGain();
        this.gain.connect(this.context.destination);
        this.panner = this.context.createPanner();
        this.panner.connect(this.gain)
    };
    THREE.Audio.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Audio.prototype.load = function (a) {
        var b = this, d = new XMLHttpRequest;
        d.open("GET", a, !0);
        d.responseType = "arraybuffer";
        d.onload = function (a) {
            b.context.decodeAudioData(this.response, function (a) {
                b.source.buffer = a;
                b.source.connect(b.panner);
                b.source.start(0)
            })
        };
        d.send();
        return this
    };
    THREE.Audio.prototype.setLoop = function (a) {
        this.source.loop = a
    };
    THREE.Audio.prototype.setRefDistance = function (a) {
        this.panner.refDistance = a
    };
    THREE.Audio.prototype.setRolloffFactor = function (a) {
        this.panner.rolloffFactor = a
    };
    THREE.Audio.prototype.updateMatrixWorld = function () {
        var a = new THREE.Vector3;
        return function (b) {
            THREE.Object3D.prototype.updateMatrixWorld.call(this, b);
            a.setFromMatrixPosition(this.matrixWorld);
            this.panner.setPosition(a.x, a.y, a.z)
        }
    }();
    THREE.AudioListener = function () {
        THREE.Object3D.call(this);
        this.type = "AudioListener";
        this.context = new (window.AudioContext || window.webkitAudioContext)
    };
    THREE.AudioListener.prototype = Object.create(THREE.Object3D.prototype);
    THREE.AudioListener.prototype.updateMatrixWorld = function () {
        var a = new THREE.Vector3, b = new THREE.Quaternion, d = new THREE.Vector3, e = new THREE.Vector3,
            f = new THREE.Vector3, h = new THREE.Vector3;
        return function (g) {
            THREE.Object3D.prototype.updateMatrixWorld.call(this, g);
            g = this.context.listener;
            this.matrixWorld.decompose(a, b, d);
            e.set(0, 0, -1).applyQuaternion(b);
            f.subVectors(a, h);
            g.setPosition(a.x, a.y, a.z);
            g.setOrientation(e.x, e.y, e.z, this.up.x, this.up.y, this.up.z);
            g.setVelocity(f.x, f.y, f.z);
            h.copy(a)
        }
    }();
    THREE.Curve = function () {
    };
    THREE.Curve.prototype.getPoint = function (a) {
        console.log("Warning, getPoint() not implemented!");
        return null
    };
    THREE.Curve.prototype.getPointAt = function (a) {
        a = this.getUtoTmapping(a);
        return this.getPoint(a)
    };
    THREE.Curve.prototype.getPoints = function (a) {
        a || (a = 5);
        var b, d = [];
        for (b = 0; b <= a; b++) d.push(this.getPoint(b / a));
        return d
    };
    THREE.Curve.prototype.getSpacedPoints = function (a) {
        a || (a = 5);
        var b, d = [];
        for (b = 0; b <= a; b++) d.push(this.getPointAt(b / a));
        return d
    };
    THREE.Curve.prototype.getLength = function () {
        var a = this.getLengths();
        return a[a.length - 1]
    };
    THREE.Curve.prototype.getLengths = function (a) {
        a || (a = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200);
        if (this.cacheArcLengths && this.cacheArcLengths.length == a + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = !1;
        var b = [], d, e = this.getPoint(0), f, h = 0;
        b.push(0);
        for (f = 1; f <= a; f++) d = this.getPoint(f / a), h += d.distanceTo(e), b.push(h), e = d;
        return this.cacheArcLengths = b
    };
    THREE.Curve.prototype.updateArcLengths = function () {
        this.needsUpdate = !0;
        this.getLengths()
    };
    THREE.Curve.prototype.getUtoTmapping = function (a, b) {
        var d = this.getLengths(), e = 0, f = d.length, h;
        h = b ? b : a * d[f - 1];
        for (var g = 0, k = f - 1, l; g <= k;) if (e = Math.floor(g + (k - g) / 2), l = d[e] - h, 0 > l) g = e + 1; else if (0 < l) k = e - 1; else {
            k = e;
            break
        }
        e = k;
        if (d[e] == h) return e / (f - 1);
        g = d[e];
        return d = (e + (h - g) / (d[e + 1] - g)) / (f - 1)
    };
    THREE.Curve.prototype.getTangent = function (a) {
        var b = a - 1E-4;
        a += 1E-4;
        0 > b && (b = 0);
        1 < a && (a = 1);
        b = this.getPoint(b);
        return this.getPoint(a).clone().sub(b).normalize()
    };
    THREE.Curve.prototype.getTangentAt = function (a) {
        a = this.getUtoTmapping(a);
        return this.getTangent(a)
    };
    THREE.Curve.Utils = {
        tangentQuadraticBezier: function (a, b, d, e) {
            return 2 * (1 - a) * (d - b) + 2 * a * (e - d)
        }, tangentCubicBezier: function (a, b, d, e, f) {
            return -3 * b * (1 - a) * (1 - a) + 3 * d * (1 - a) * (1 - a) - 6 * a * d * (1 - a) + 6 * a * e * (1 - a) - 3 * a * a * e + 3 * a * a * f
        }, tangentSpline: function (a, b, d, e, f) {
            return 6 * a * a - 6 * a + (3 * a * a - 4 * a + 1) + (-6 * a * a + 6 * a) + (3 * a * a - 2 * a)
        }, interpolate: function (a, b, d, e, f) {
            a = .5 * (d - a);
            e = .5 * (e - b);
            var h = f * f;
            return (2 * b - 2 * d + a + e) * f * h + (-3 * b + 3 * d - 2 * a - e) * h + a * f + b
        }
    };
    THREE.Curve.create = function (a, b) {
        a.prototype = Object.create(THREE.Curve.prototype);
        a.prototype.getPoint = b;
        return a
    };
    THREE.CurvePath = function () {
        this.curves = [];
        this.bends = [];
        this.autoClose = !1
    };
    THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype);
    THREE.CurvePath.prototype.add = function (a) {
        this.curves.push(a)
    };
    THREE.CurvePath.prototype.checkConnection = function () {
    };
    THREE.CurvePath.prototype.closePath = function () {
        var a = this.curves[0].getPoint(0), b = this.curves[this.curves.length - 1].getPoint(1);
        a.equals(b) || this.curves.push(new THREE.LineCurve(b, a))
    };
    THREE.CurvePath.prototype.getPoint = function (a) {
        var b = a * this.getLength(), d = this.getCurveLengths();
        for (a = 0; a < d.length;) {
            if (d[a] >= b) return b = d[a] - b, a = this.curves[a], b = 1 - b / a.getLength(), a.getPointAt(b);
            a++
        }
        return null
    };
    THREE.CurvePath.prototype.getLength = function () {
        var a = this.getCurveLengths();
        return a[a.length - 1]
    };
    THREE.CurvePath.prototype.getCurveLengths = function () {
        if (this.cacheLengths && this.cacheLengths.length == this.curves.length) return this.cacheLengths;
        var a = [], b = 0, d, e = this.curves.length;
        for (d = 0; d < e; d++) b += this.curves[d].getLength(), a.push(b);
        return this.cacheLengths = a
    };
    THREE.CurvePath.prototype.getBoundingBox = function () {
        var a = this.getPoints(), b, d, e, f, h, g;
        b = d = Number.NEGATIVE_INFINITY;
        f = h = Number.POSITIVE_INFINITY;
        var k, l, m, n, q = a[0] instanceof THREE.Vector3;
        n = q ? new THREE.Vector3 : new THREE.Vector2;
        l = 0;
        for (m = a.length; l < m; l++) k = a[l], k.x > b ? b = k.x : k.x < f && (f = k.x), k.y > d ? d = k.y : k.y < h && (h = k.y), q && (k.z > e ? e = k.z : k.z < g && (g = k.z)), n.add(k);
        a = {minX: f, minY: h, maxX: b, maxY: d};
        q && (a.maxZ = e, a.minZ = g);
        return a
    };
    THREE.CurvePath.prototype.createPointsGeometry = function (a) {
        a = this.getPoints(a, !0);
        return this.createGeometry(a)
    };
    THREE.CurvePath.prototype.createSpacedPointsGeometry = function (a) {
        a = this.getSpacedPoints(a, !0);
        return this.createGeometry(a)
    };
    THREE.CurvePath.prototype.createGeometry = function (a) {
        for (var b = new THREE.Geometry, d = 0; d < a.length; d++) b.vertices.push(new THREE.Vector3(a[d].x, a[d].y, a[d].z || 0));
        return b
    };
    THREE.CurvePath.prototype.addWrapPath = function (a) {
        this.bends.push(a)
    };
    THREE.CurvePath.prototype.getTransformedPoints = function (a, b) {
        var d = this.getPoints(a), e, f;
        b || (b = this.bends);
        e = 0;
        for (f = b.length; e < f; e++) d = this.getWrapPoints(d, b[e]);
        return d
    };
    THREE.CurvePath.prototype.getTransformedSpacedPoints = function (a, b) {
        var d = this.getSpacedPoints(a), e, f;
        b || (b = this.bends);
        e = 0;
        for (f = b.length; e < f; e++) d = this.getWrapPoints(d, b[e]);
        return d
    };
    THREE.CurvePath.prototype.getWrapPoints = function (a, b) {
        var d = this.getBoundingBox(), e, f, h, g, k, l;
        e = 0;
        for (f = a.length; e < f; e++) h = a[e], g = h.x, k = h.y, l = g / d.maxX, l = b.getUtoTmapping(l, g), g = b.getPoint(l), l = b.getTangent(l), l.set(-l.y, l.x).multiplyScalar(k), h.x = g.x + l.x, h.y = g.y + l.y;
        return a
    };
    THREE.Gyroscope = function () {
        THREE.Object3D.call(this)
    };
    THREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Gyroscope.prototype.updateMatrixWorld = function () {
        var a = new THREE.Vector3, b = new THREE.Quaternion, d = new THREE.Vector3, e = new THREE.Vector3,
            f = new THREE.Quaternion, h = new THREE.Vector3;
        return function (g) {
            this.matrixAutoUpdate && this.updateMatrix();
            if (this.matrixWorldNeedsUpdate || g) this.parent ? (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorld.decompose(e, f, h), this.matrix.decompose(a, b, d), this.matrixWorld.compose(e, b, h)) : this.matrixWorld.copy(this.matrix), this.matrixWorldNeedsUpdate =
                !1, g = !0;
            for (var k = 0, l = this.children.length; k < l; k++) this.children[k].updateMatrixWorld(g)
        }
    }();
    THREE.Path = function (a) {
        THREE.CurvePath.call(this);
        this.actions = [];
        a && this.fromPoints(a)
    };
    THREE.Path.prototype = Object.create(THREE.CurvePath.prototype);
    THREE.PathActions = {
        MOVE_TO: "moveTo",
        LINE_TO: "lineTo",
        QUADRATIC_CURVE_TO: "quadraticCurveTo",
        BEZIER_CURVE_TO: "bezierCurveTo",
        CSPLINE_THRU: "splineThru",
        ARC: "arc",
        ELLIPSE: "ellipse"
    };
    THREE.Path.prototype.fromPoints = function (a) {
        this.moveTo(a[0].x, a[0].y);
        for (var b = 1, d = a.length; b < d; b++) this.lineTo(a[b].x, a[b].y)
    };
    THREE.Path.prototype.moveTo = function (a, b) {
        var d = Array.prototype.slice.call(arguments);
        this.actions.push({action: THREE.PathActions.MOVE_TO, args: d})
    };
    THREE.Path.prototype.lineTo = function (a, b) {
        var d = Array.prototype.slice.call(arguments), e = this.actions[this.actions.length - 1].args,
            e = new THREE.LineCurve(new THREE.Vector2(e[e.length - 2], e[e.length - 1]), new THREE.Vector2(a, b));
        this.curves.push(e);
        this.actions.push({action: THREE.PathActions.LINE_TO, args: d})
    };
    THREE.Path.prototype.quadraticCurveTo = function (a, b, d, e) {
        var f = Array.prototype.slice.call(arguments), h = this.actions[this.actions.length - 1].args,
            h = new THREE.QuadraticBezierCurve(new THREE.Vector2(h[h.length - 2], h[h.length - 1]), new THREE.Vector2(a, b), new THREE.Vector2(d, e));
        this.curves.push(h);
        this.actions.push({action: THREE.PathActions.QUADRATIC_CURVE_TO, args: f})
    };
    THREE.Path.prototype.bezierCurveTo = function (a, b, d, e, f, h) {
        var g = Array.prototype.slice.call(arguments), k = this.actions[this.actions.length - 1].args,
            k = new THREE.CubicBezierCurve(new THREE.Vector2(k[k.length - 2], k[k.length - 1]), new THREE.Vector2(a, b), new THREE.Vector2(d, e), new THREE.Vector2(f, h));
        this.curves.push(k);
        this.actions.push({action: THREE.PathActions.BEZIER_CURVE_TO, args: g})
    };
    THREE.Path.prototype.splineThru = function (a) {
        var b = Array.prototype.slice.call(arguments), d = this.actions[this.actions.length - 1].args,
            d = [new THREE.Vector2(d[d.length - 2], d[d.length - 1])];
        Array.prototype.push.apply(d, a);
        d = new THREE.SplineCurve(d);
        this.curves.push(d);
        this.actions.push({action: THREE.PathActions.CSPLINE_THRU, args: b})
    };
    THREE.Path.prototype.arc = function (a, b, d, e, f, h) {
        var g = this.actions[this.actions.length - 1].args;
        this.absarc(a + g[g.length - 2], b + g[g.length - 1], d, e, f, h)
    };
    THREE.Path.prototype.absarc = function (a, b, d, e, f, h) {
        this.absellipse(a, b, d, d, e, f, h)
    };
    THREE.Path.prototype.ellipse = function (a, b, d, e, f, h, g) {
        var k = this.actions[this.actions.length - 1].args;
        this.absellipse(a + k[k.length - 2], b + k[k.length - 1], d, e, f, h, g)
    };
    THREE.Path.prototype.absellipse = function (a, b, d, e, f, h, g) {
        var k = Array.prototype.slice.call(arguments), l = new THREE.EllipseCurve(a, b, d, e, f, h, g);
        this.curves.push(l);
        l = l.getPoint(1);
        k.push(l.x);
        k.push(l.y);
        this.actions.push({action: THREE.PathActions.ELLIPSE, args: k})
    };
    THREE.Path.prototype.getSpacedPoints = function (a, b) {
        a || (a = 40);
        for (var d = [], e = 0; e < a; e++) d.push(this.getPoint(e / a));
        return d
    };
    THREE.Path.prototype.getPoints = function (a, b) {
        if (this.useSpacedPoints) return this.getSpacedPoints(a, b);
        a = a || 12;
        var d = [], e, f, h, g, k, l, m, n, q, p, r, v, u;
        e = 0;
        for (f = this.actions.length; e < f; e++) switch (h = this.actions[e], g = h.action, h = h.args, g) {
            case THREE.PathActions.MOVE_TO:
                d.push(new THREE.Vector2(h[0], h[1]));
                break;
            case THREE.PathActions.LINE_TO:
                d.push(new THREE.Vector2(h[0], h[1]));
                break;
            case THREE.PathActions.QUADRATIC_CURVE_TO:
                k = h[2];
                l = h[3];
                q = h[0];
                p = h[1];
                0 < d.length ? (g = d[d.length - 1], r = g.x, v = g.y) : (g = this.actions[e -
                1].args, r = g[g.length - 2], v = g[g.length - 1]);
                for (h = 1; h <= a; h++) u = h / a, g = THREE.Shape.Utils.b2(u, r, q, k), u = THREE.Shape.Utils.b2(u, v, p, l), d.push(new THREE.Vector2(g, u));
                break;
            case THREE.PathActions.BEZIER_CURVE_TO:
                k = h[4];
                l = h[5];
                q = h[0];
                p = h[1];
                m = h[2];
                n = h[3];
                0 < d.length ? (g = d[d.length - 1], r = g.x, v = g.y) : (g = this.actions[e - 1].args, r = g[g.length - 2], v = g[g.length - 1]);
                for (h = 1; h <= a; h++) u = h / a, g = THREE.Shape.Utils.b3(u, r, q, m, k), u = THREE.Shape.Utils.b3(u, v, p, n, l), d.push(new THREE.Vector2(g, u));
                break;
            case THREE.PathActions.CSPLINE_THRU:
                g =
                    this.actions[e - 1].args;
                u = [new THREE.Vector2(g[g.length - 2], g[g.length - 1])];
                g = a * h[0].length;
                u = u.concat(h[0]);
                u = new THREE.SplineCurve(u);
                for (h = 1; h <= g; h++) d.push(u.getPointAt(h / g));
                break;
            case THREE.PathActions.ARC:
                k = h[0];
                l = h[1];
                p = h[2];
                m = h[3];
                g = h[4];
                q = !!h[5];
                r = g - m;
                v = 2 * a;
                for (h = 1; h <= v; h++) u = h / v, q || (u = 1 - u), u = m + u * r, g = k + p * Math.cos(u), u = l + p * Math.sin(u), d.push(new THREE.Vector2(g, u));
                break;
            case THREE.PathActions.ELLIPSE:
                for (k = h[0], l = h[1], p = h[2], n = h[3], m = h[4], g = h[5], q = !!h[6], r = g - m, v = 2 * a, h = 1; h <= v; h++) u = h / v, q ||
                (u = 1 - u), u = m + u * r, g = k + p * Math.cos(u), u = l + n * Math.sin(u), d.push(new THREE.Vector2(g, u))
        }
        e = d[d.length - 1];
        1E-10 > Math.abs(e.x - d[0].x) && 1E-10 > Math.abs(e.y - d[0].y) && d.splice(d.length - 1, 1);
        b && d.push(d[0]);
        return d
    };
    THREE.Path.prototype.toShapes = function (a, b) {
        function d(a) {
            for (var b = [], d = 0, e = a.length; d < e; d++) {
                var g = a[d], h = new THREE.Shape;
                h.actions = g.actions;
                h.curves = g.curves;
                b.push(h)
            }
            return b
        }

        function e(a, b) {
            for (var d = b.length, e = !1, g = d - 1, h = 0; h < d; g = h++) {
                var f = b[g], k = b[h], l = k.x - f.x, m = k.y - f.y;
                if (1E-10 < Math.abs(m)) {
                    if (0 > m && (f = b[h], l = -l, k = b[g], m = -m), !(a.y < f.y || a.y > k.y)) if (a.y == f.y) {
                        if (a.x == f.x) return !0
                    } else {
                        g = m * (a.x - f.x) - l * (a.y - f.y);
                        if (0 == g) return !0;
                        0 > g || (e = !e)
                    }
                } else if (a.y == f.y && (k.x <= a.x && a.x <= f.x || f.x <= a.x && a.x <=
                        k.x)) return !0
            }
            return e
        }

        var f = function (a) {
            var b, d, e, g, h = [], f = new THREE.Path;
            b = 0;
            for (d = a.length; b < d; b++) e = a[b], g = e.args, e = e.action, e == THREE.PathActions.MOVE_TO && 0 != f.actions.length && (h.push(f), f = new THREE.Path), f[e].apply(f, g);
            0 != f.actions.length && h.push(f);
            return h
        }(this.actions);
        if (0 == f.length) return [];
        if (!0 === b) return d(f);
        var h, g, k, l = [];
        if (1 == f.length) return g = f[0], k = new THREE.Shape, k.actions = g.actions, k.curves = g.curves, l.push(k), l;
        var m = !THREE.Shape.Utils.isClockWise(f[0].getPoints()), m = a ? !m : m;
        k = [];
        var n = [], q = [], p = 0, r;
        n[p] = void 0;
        q[p] = [];
        var v, u;
        v = 0;
        for (u = f.length; v < u; v++) g = f[v], r = g.getPoints(), h = THREE.Shape.Utils.isClockWise(r), (h = a ? !h : h) ? (!m && n[p] && p++, n[p] = {
            s: new THREE.Shape,
            p: r
        }, n[p].s.actions = g.actions, n[p].s.curves = g.curves, m && p++, q[p] = []) : q[p].push({h: g, p: r[0]});
        if (!n[0]) return d(f);
        if (1 < n.length) {
            v = !1;
            u = [];
            g = 0;
            for (f = n.length; g < f; g++) k[g] = [];
            g = 0;
            for (f = n.length; g < f; g++) for (h = q[g], m = 0; m < h.length; m++) {
                p = h[m];
                r = !0;
                for (var x = 0; x < n.length; x++) e(p.p, n[x].p) && (g != x && u.push({
                    froms: g, tos: x,
                    hole: m
                }), r ? (r = !1, k[x].push(p)) : v = !0);
                r && k[g].push(p)
            }
            0 < u.length && (v || (q = k))
        }
        v = 0;
        for (u = n.length; v < u; v++) for (k = n[v].s, l.push(k), g = q[v], f = 0, h = g.length; f < h; f++) k.holes.push(g[f].h);
        return l
    };
    THREE.Shape = function () {
        THREE.Path.apply(this, arguments);
        this.holes = []
    };
    THREE.Shape.prototype = Object.create(THREE.Path.prototype);
    THREE.Shape.prototype.extrude = function (a) {
        return new THREE.ExtrudeGeometry(this, a)
    };
    THREE.Shape.prototype.makeGeometry = function (a) {
        return new THREE.ShapeGeometry(this, a)
    };
    THREE.Shape.prototype.getPointsHoles = function (a) {
        var b, d = this.holes.length, e = [];
        for (b = 0; b < d; b++) e[b] = this.holes[b].getTransformedPoints(a, this.bends);
        return e
    };
    THREE.Shape.prototype.getSpacedPointsHoles = function (a) {
        var b, d = this.holes.length, e = [];
        for (b = 0; b < d; b++) e[b] = this.holes[b].getTransformedSpacedPoints(a, this.bends);
        return e
    };
    THREE.Shape.prototype.extractAllPoints = function (a) {
        return {shape: this.getTransformedPoints(a), holes: this.getPointsHoles(a)}
    };
    THREE.Shape.prototype.extractPoints = function (a) {
        return this.useSpacedPoints ? this.extractAllSpacedPoints(a) : this.extractAllPoints(a)
    };
    THREE.Shape.prototype.extractAllSpacedPoints = function (a) {
        return {shape: this.getTransformedSpacedPoints(a), holes: this.getSpacedPointsHoles(a)}
    };
    THREE.Shape.Utils = {
        triangulateShape: function (a, b) {
            function d(a, b, d) {
                return a.x != b.x ? a.x < b.x ? a.x <= d.x && d.x <= b.x : b.x <= d.x && d.x <= a.x : a.y < b.y ? a.y <= d.y && d.y <= b.y : b.y <= d.y && d.y <= a.y
            }

            function e(a, b, e, g, h) {
                var f = b.x - a.x, k = b.y - a.y, l = g.x - e.x, m = g.y - e.y, n = a.x - e.x, q = a.y - e.y,
                    I = k * l - f * m, A = k * n - f * q;
                if (1E-10 < Math.abs(I)) {
                    if (0 < I) {
                        if (0 > A || A > I) return [];
                        l = m * n - l * q;
                        if (0 > l || l > I) return []
                    } else {
                        if (0 < A || A < I) return [];
                        l = m * n - l * q;
                        if (0 < l || l < I) return []
                    }
                    if (0 == l) return !h || 0 != A && A != I ? [a] : [];
                    if (l == I) return !h || 0 != A && A != I ? [b] : [];
                    if (0 == A) return [e];
                    if (A == I) return [g];
                    h = l / I;
                    return [{x: a.x + h * f, y: a.y + h * k}]
                }
                if (0 != A || m * n != l * q) return [];
                k = 0 == f && 0 == k;
                l = 0 == l && 0 == m;
                if (k && l) return a.x != e.x || a.y != e.y ? [] : [a];
                if (k) return d(e, g, a) ? [a] : [];
                if (l) return d(a, b, e) ? [e] : [];
                0 != f ? (a.x < b.x ? (f = a, l = a.x, k = b, a = b.x) : (f = b, l = b.x, k = a, a = a.x), e.x < g.x ? (b = e, I = e.x, m = g, e = g.x) : (b = g, I = g.x, m = e, e = e.x)) : (a.y < b.y ? (f = a, l = a.y, k = b, a = b.y) : (f = b, l = b.y, k = a, a = a.y), e.y < g.y ? (b = e, I = e.y, m = g, e = g.y) : (b = g, I = g.y, m = e, e = e.y));
                return l <= I ? a < I ? [] : a == I ? h ? [] : [b] : a <= e ? [b, k] : [b, m] : l > e ? [] : l == e ? h ? [] : [f] : a <= e ? [f, k] :
                    [f, m]
            }

            function f(a, b, d, e) {
                var g = b.x - a.x, h = b.y - a.y;
                b = d.x - a.x;
                d = d.y - a.y;
                var f = e.x - a.x;
                e = e.y - a.y;
                a = g * d - h * b;
                g = g * e - h * f;
                return 1E-10 < Math.abs(a) ? (b = f * d - e * b, 0 < a ? 0 <= g && 0 <= b : 0 <= g || 0 <= b) : 0 < g
            }

            var h, g, k, l, m, n = {};
            k = a.concat();
            h = 0;
            for (g = b.length; h < g; h++) Array.prototype.push.apply(k, b[h]);
            h = 0;
            for (g = k.length; h < g; h++) m = k[h].x + ":" + k[h].y, void 0 !== n[m] && console.log("Duplicate point", m), n[m] = h;
            h = function (a, b) {
                function d(a, b) {
                    var e = k.length - 1, g = a - 1;
                    0 > g && (g = e);
                    var h = a + 1;
                    h > e && (h = 0);
                    e = f(k[a], k[g], k[h], l[b]);
                    if (!e) return !1;
                    e = l.length - 1;
                    g = b - 1;
                    0 > g && (g = e);
                    h = b + 1;
                    h > e && (h = 0);
                    return (e = f(l[b], l[g], l[h], k[a])) ? !0 : !1
                }

                function g(a, b) {
                    var d, h;
                    for (d = 0; d < k.length; d++) if (h = d + 1, h %= k.length, h = e(a, b, k[d], k[h], !0), 0 < h.length) return !0;
                    return !1
                }

                function h(a, d) {
                    var g, f, k, l;
                    for (g = 0; g < m.length; g++) for (f = b[m[g]], k = 0; k < f.length; k++) if (l = k + 1, l %= f.length, l = e(a, d, f[k], f[l], !0), 0 < l.length) return !0;
                    return !1
                }

                var k = a.concat(), l, m = [], n, q, E, I, A, N = [], G, D, Y, C = 0;
                for (n = b.length; C < n; C++) m.push(C);
                G = 0;
                for (var K = 2 * m.length; 0 < m.length;) {
                    K--;
                    if (0 > K) {
                        console.log("Infinite Loop! Holes left:" +
                            m.length + ", Probably Hole outside Shape!");
                        break
                    }
                    for (q = G; q < k.length; q++) {
                        E = k[q];
                        n = -1;
                        for (C = 0; C < m.length; C++) if (I = m[C], A = E.x + ":" + E.y + ":" + I, void 0 === N[A]) {
                            l = b[I];
                            for (D = 0; D < l.length; D++) if (I = l[D], d(q, D) && !g(E, I) && !h(E, I)) {
                                n = D;
                                m.splice(C, 1);
                                G = k.slice(0, q + 1);
                                I = k.slice(q);
                                D = l.slice(n);
                                Y = l.slice(0, n + 1);
                                k = G.concat(D).concat(Y).concat(I);
                                G = q;
                                break
                            }
                            if (0 <= n) break;
                            N[A] = !0
                        }
                        if (0 <= n) break
                    }
                }
                return k
            }(a, b);
            var q = THREE.FontUtils.Triangulate(h, !1);
            h = 0;
            for (g = q.length; h < g; h++) for (l = q[h], k = 0; 3 > k; k++) m = l[k].x + ":" + l[k].y,
                m = n[m], void 0 !== m && (l[k] = m);
            return q.concat()
        }, isClockWise: function (a) {
            return 0 > THREE.FontUtils.Triangulate.area(a)
        }, b2p0: function (a, b) {
            var d = 1 - a;
            return d * d * b
        }, b2p1: function (a, b) {
            return 2 * (1 - a) * a * b
        }, b2p2: function (a, b) {
            return a * a * b
        }, b2: function (a, b, d, e) {
            return this.b2p0(a, b) + this.b2p1(a, d) + this.b2p2(a, e)
        }, b3p0: function (a, b) {
            var d = 1 - a;
            return d * d * d * b
        }, b3p1: function (a, b) {
            var d = 1 - a;
            return 3 * d * d * a * b
        }, b3p2: function (a, b) {
            return 3 * (1 - a) * a * a * b
        }, b3p3: function (a, b) {
            return a * a * a * b
        }, b3: function (a, b, d, e, f) {
            return this.b3p0(a,
                b) + this.b3p1(a, d) + this.b3p2(a, e) + this.b3p3(a, f)
        }
    };
    THREE.LineCurve = function (a, b) {
        this.v1 = a;
        this.v2 = b
    };
    THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype);
    THREE.LineCurve.prototype.getPoint = function (a) {
        var b = this.v2.clone().sub(this.v1);
        b.multiplyScalar(a).add(this.v1);
        return b
    };
    THREE.LineCurve.prototype.getPointAt = function (a) {
        return this.getPoint(a)
    };
    THREE.LineCurve.prototype.getTangent = function (a) {
        return this.v2.clone().sub(this.v1).normalize()
    };
    THREE.QuadraticBezierCurve = function (a, b, d) {
        this.v0 = a;
        this.v1 = b;
        this.v2 = d
    };
    THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype);
    THREE.QuadraticBezierCurve.prototype.getPoint = function (a) {
        var b = new THREE.Vector2;
        b.x = THREE.Shape.Utils.b2(a, this.v0.x, this.v1.x, this.v2.x);
        b.y = THREE.Shape.Utils.b2(a, this.v0.y, this.v1.y, this.v2.y);
        return b
    };
    THREE.QuadraticBezierCurve.prototype.getTangent = function (a) {
        var b = new THREE.Vector2;
        b.x = THREE.Curve.Utils.tangentQuadraticBezier(a, this.v0.x, this.v1.x, this.v2.x);
        b.y = THREE.Curve.Utils.tangentQuadraticBezier(a, this.v0.y, this.v1.y, this.v2.y);
        return b.normalize()
    };
    THREE.CubicBezierCurve = function (a, b, d, e) {
        this.v0 = a;
        this.v1 = b;
        this.v2 = d;
        this.v3 = e
    };
    THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype);
    THREE.CubicBezierCurve.prototype.getPoint = function (a) {
        var b;
        b = THREE.Shape.Utils.b3(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
        a = THREE.Shape.Utils.b3(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
        return new THREE.Vector2(b, a)
    };
    THREE.CubicBezierCurve.prototype.getTangent = function (a) {
        var b;
        b = THREE.Curve.Utils.tangentCubicBezier(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
        a = THREE.Curve.Utils.tangentCubicBezier(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
        b = new THREE.Vector2(b, a);
        b.normalize();
        return b
    };
    THREE.SplineCurve = function (a) {
        this.points = void 0 == a ? [] : a
    };
    THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype);
    THREE.SplineCurve.prototype.getPoint = function (a) {
        var b = this.points;
        a *= b.length - 1;
        var d = Math.floor(a);
        a -= d;
        var e = b[0 == d ? d : d - 1], f = b[d], h = b[d > b.length - 2 ? b.length - 1 : d + 1],
            b = b[d > b.length - 3 ? b.length - 1 : d + 2], d = new THREE.Vector2;
        d.x = THREE.Curve.Utils.interpolate(e.x, f.x, h.x, b.x, a);
        d.y = THREE.Curve.Utils.interpolate(e.y, f.y, h.y, b.y, a);
        return d
    };
    THREE.EllipseCurve = function (a, b, d, e, f, h, g) {
        this.aX = a;
        this.aY = b;
        this.xRadius = d;
        this.yRadius = e;
        this.aStartAngle = f;
        this.aEndAngle = h;
        this.aClockwise = g
    };
    THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype);
    THREE.EllipseCurve.prototype.getPoint = function (a) {
        var b = this.aEndAngle - this.aStartAngle;
        0 > b && (b += 2 * Math.PI);
        b > 2 * Math.PI && (b -= 2 * Math.PI);
        a = !0 === this.aClockwise ? this.aEndAngle + (1 - a) * (2 * Math.PI - b) : this.aStartAngle + a * b;
        b = new THREE.Vector2;
        b.x = this.aX + this.xRadius * Math.cos(a);
        b.y = this.aY + this.yRadius * Math.sin(a);
        return b
    };
    THREE.ArcCurve = function (a, b, d, e, f, h) {
        THREE.EllipseCurve.call(this, a, b, d, d, e, f, h)
    };
    THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype);
    THREE.LineCurve3 = THREE.Curve.create(function (a, b) {
        this.v1 = a;
        this.v2 = b
    }, function (a) {
        var b = new THREE.Vector3;
        b.subVectors(this.v2, this.v1);
        b.multiplyScalar(a);
        b.add(this.v1);
        return b
    });
    THREE.QuadraticBezierCurve3 = THREE.Curve.create(function (a, b, d) {
        this.v0 = a;
        this.v1 = b;
        this.v2 = d
    }, function (a) {
        var b = new THREE.Vector3;
        b.x = THREE.Shape.Utils.b2(a, this.v0.x, this.v1.x, this.v2.x);
        b.y = THREE.Shape.Utils.b2(a, this.v0.y, this.v1.y, this.v2.y);
        b.z = THREE.Shape.Utils.b2(a, this.v0.z, this.v1.z, this.v2.z);
        return b
    });
    THREE.CubicBezierCurve3 = THREE.Curve.create(function (a, b, d, e) {
        this.v0 = a;
        this.v1 = b;
        this.v2 = d;
        this.v3 = e
    }, function (a) {
        var b = new THREE.Vector3;
        b.x = THREE.Shape.Utils.b3(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
        b.y = THREE.Shape.Utils.b3(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
        b.z = THREE.Shape.Utils.b3(a, this.v0.z, this.v1.z, this.v2.z, this.v3.z);
        return b
    });
    THREE.SplineCurve3 = THREE.Curve.create(function (a) {
        this.points = void 0 == a ? [] : a
    }, function (a) {
        var b = this.points;
        a *= b.length - 1;
        var d = Math.floor(a);
        a -= d;
        var e = b[0 == d ? d : d - 1], f = b[d], h = b[d > b.length - 2 ? b.length - 1 : d + 1],
            b = b[d > b.length - 3 ? b.length - 1 : d + 2], d = new THREE.Vector3;
        d.x = THREE.Curve.Utils.interpolate(e.x, f.x, h.x, b.x, a);
        d.y = THREE.Curve.Utils.interpolate(e.y, f.y, h.y, b.y, a);
        d.z = THREE.Curve.Utils.interpolate(e.z, f.z, h.z, b.z, a);
        return d
    });
    THREE.ClosedSplineCurve3 = THREE.Curve.create(function (a) {
        this.points = void 0 == a ? [] : a
    }, function (a) {
        var b = this.points;
        a *= b.length - 0;
        var d = Math.floor(a);
        a -= d;
        var d = d + (0 < d ? 0 : (Math.floor(Math.abs(d) / b.length) + 1) * b.length), e = b[(d - 1) % b.length],
            f = b[d % b.length], h = b[(d + 1) % b.length], b = b[(d + 2) % b.length], d = new THREE.Vector3;
        d.x = THREE.Curve.Utils.interpolate(e.x, f.x, h.x, b.x, a);
        d.y = THREE.Curve.Utils.interpolate(e.y, f.y, h.y, b.y, a);
        d.z = THREE.Curve.Utils.interpolate(e.z, f.z, h.z, b.z, a);
        return d
    });
    THREE.AnimationHandler = {
        LINEAR: 0, CATMULLROM: 1, CATMULLROM_FORWARD: 2, add: function () {
            console.warn("THREE.AnimationHandler.add() has been deprecated.")
        }, get: function () {
            console.warn("THREE.AnimationHandler.get() has been deprecated.")
        }, remove: function () {
            console.warn("THREE.AnimationHandler.remove() has been deprecated.")
        }, animations: [], init: function (a) {
            if (!0 !== a.initialized) {
                for (var b = 0; b < a.hierarchy.length; b++) {
                    for (var d = 0; d < a.hierarchy[b].keys.length; d++) if (0 > a.hierarchy[b].keys[d].time && (a.hierarchy[b].keys[d].time =
                            0), void 0 !== a.hierarchy[b].keys[d].rot && !(a.hierarchy[b].keys[d].rot instanceof THREE.Quaternion)) {
                        var e = a.hierarchy[b].keys[d].rot;
                        a.hierarchy[b].keys[d].rot = (new THREE.Quaternion).fromArray(e)
                    }
                    if (a.hierarchy[b].keys.length && void 0 !== a.hierarchy[b].keys[0].morphTargets) {
                        e = {};
                        for (d = 0; d < a.hierarchy[b].keys.length; d++) for (var f = 0; f < a.hierarchy[b].keys[d].morphTargets.length; f++) {
                            var h = a.hierarchy[b].keys[d].morphTargets[f];
                            e[h] = -1
                        }
                        a.hierarchy[b].usedMorphTargets = e;
                        for (d = 0; d < a.hierarchy[b].keys.length; d++) {
                            var g =
                                {};
                            for (h in e) {
                                for (f = 0; f < a.hierarchy[b].keys[d].morphTargets.length; f++) if (a.hierarchy[b].keys[d].morphTargets[f] === h) {
                                    g[h] = a.hierarchy[b].keys[d].morphTargetsInfluences[f];
                                    break
                                }
                                f === a.hierarchy[b].keys[d].morphTargets.length && (g[h] = 0)
                            }
                            a.hierarchy[b].keys[d].morphTargetsInfluences = g
                        }
                    }
                    for (d = 1; d < a.hierarchy[b].keys.length; d++) a.hierarchy[b].keys[d].time === a.hierarchy[b].keys[d - 1].time && (a.hierarchy[b].keys.splice(d, 1), d--);
                    for (d = 0; d < a.hierarchy[b].keys.length; d++) a.hierarchy[b].keys[d].index = d
                }
                a.initialized =
                    !0;
                return a
            }
        }, parse: function (a) {
            var b = function (a, d) {
                d.push(a);
                for (var e = 0; e < a.children.length; e++) b(a.children[e], d)
            }, d = [];
            if (a instanceof THREE.SkinnedMesh) for (var e = 0; e < a.skeleton.bones.length; e++) d.push(a.skeleton.bones[e]); else b(a, d);
            return d
        }, play: function (a) {
            -1 === this.animations.indexOf(a) && this.animations.push(a)
        }, stop: function (a) {
            a = this.animations.indexOf(a);
            -1 !== a && this.animations.splice(a, 1)
        }, update: function (a) {
            for (var b = 0; b < this.animations.length; b++) this.animations[b].resetBlendWeights();
            for (b = 0; b < this.animations.length; b++) this.animations[b].update(a)
        }
    };
    THREE.Animation = function (a, b) {
        this.root = a;
        this.data = THREE.AnimationHandler.init(b);
        this.hierarchy = THREE.AnimationHandler.parse(a);
        this.currentTime = 0;
        this.timeScale = 1;
        this.isPlaying = !1;
        this.loop = !0;
        this.weight = 0;
        this.interpolationType = THREE.AnimationHandler.LINEAR
    };
    THREE.Animation.prototype.keyTypes = ["pos", "rot", "scl"];
    THREE.Animation.prototype.play = function (a, b) {
        this.currentTime = void 0 !== a ? a : 0;
        this.weight = void 0 !== b ? b : 1;
        this.isPlaying = !0;
        this.reset();
        THREE.AnimationHandler.play(this)
    };
    THREE.Animation.prototype.stop = function () {
        this.isPlaying = !1;
        THREE.AnimationHandler.stop(this)
    };
    THREE.Animation.prototype.reset = function () {
        for (var a = 0, b = this.hierarchy.length; a < b; a++) {
            var d = this.hierarchy[a];
            d.matrixAutoUpdate = !0;
            void 0 === d.animationCache && (d.animationCache = {
                animations: {},
                blending: {positionWeight: 0, quaternionWeight: 0, scaleWeight: 0}
            });
            void 0 === d.animationCache.animations[this.data.name] && (d.animationCache.animations[this.data.name] = {}, d.animationCache.animations[this.data.name].prevKey = {
                pos: 0,
                rot: 0,
                scl: 0
            }, d.animationCache.animations[this.data.name].nextKey = {pos: 0, rot: 0, scl: 0},
                d.animationCache.animations[this.data.name].originalMatrix = d.matrix);
            for (var d = d.animationCache.animations[this.data.name], e = 0; 3 > e; e++) {
                for (var f = this.keyTypes[e], h = this.data.hierarchy[a].keys[0], g = this.getNextKeyWith(f, a, 1); g.time < this.currentTime && g.index > h.index;) h = g, g = this.getNextKeyWith(f, a, g.index + 1);
                d.prevKey[f] = h;
                d.nextKey[f] = g
            }
        }
    };
    THREE.Animation.prototype.resetBlendWeights = function () {
        for (var a = 0, b = this.hierarchy.length; a < b; a++) {
            var d = this.hierarchy[a];
            void 0 !== d.animationCache && (d.animationCache.blending.positionWeight = 0, d.animationCache.blending.quaternionWeight = 0, d.animationCache.blending.scaleWeight = 0)
        }
    };
    THREE.Animation.prototype.update = function () {
        var a = [], b = new THREE.Vector3, d = new THREE.Vector3, e = new THREE.Quaternion, f = function (a, b) {
            var d = [], e = [], f, q, p, r, v, u;
            f = (a.length - 1) * b;
            q = Math.floor(f);
            f -= q;
            d[0] = 0 === q ? q : q - 1;
            d[1] = q;
            d[2] = q > a.length - 2 ? q : q + 1;
            d[3] = q > a.length - 3 ? q : q + 2;
            q = a[d[0]];
            r = a[d[1]];
            v = a[d[2]];
            u = a[d[3]];
            d = f * f;
            p = f * d;
            e[0] = h(q[0], r[0], v[0], u[0], f, d, p);
            e[1] = h(q[1], r[1], v[1], u[1], f, d, p);
            e[2] = h(q[2], r[2], v[2], u[2], f, d, p);
            return e
        }, h = function (a, b, d, e, h, f, p) {
            a = .5 * (d - a);
            e = .5 * (e - b);
            return (2 * (b - d) + a + e) * p +
                (-3 * (b - d) - 2 * a - e) * f + a * h + b
        };
        return function (g) {
            if (!1 !== this.isPlaying && (this.currentTime += g * this.timeScale, 0 !== this.weight)) {
                g = this.data.length;
                if (this.currentTime > g || 0 > this.currentTime) if (this.loop) this.currentTime %= g, 0 > this.currentTime && (this.currentTime += g), this.reset(); else {
                    this.stop();
                    return
                }
                g = 0;
                for (var h = this.hierarchy.length; g < h; g++) for (var l = this.hierarchy[g], m = l.animationCache.animations[this.data.name], n = l.animationCache.blending, q = 0; 3 > q; q++) {
                    var p = this.keyTypes[q], r = m.prevKey[p], v = m.nextKey[p];
                    if (0 < this.timeScale && v.time <= this.currentTime || 0 > this.timeScale && r.time >= this.currentTime) {
                        r = this.data.hierarchy[g].keys[0];
                        for (v = this.getNextKeyWith(p, g, 1); v.time < this.currentTime && v.index > r.index;) r = v, v = this.getNextKeyWith(p, g, v.index + 1);
                        m.prevKey[p] = r;
                        m.nextKey[p] = v
                    }
                    l.matrixAutoUpdate = !0;
                    l.matrixWorldNeedsUpdate = !0;
                    var u = (this.currentTime - r.time) / (v.time - r.time), x = r[p], w = v[p];
                    0 > u && (u = 0);
                    1 < u && (u = 1);
                    if ("pos" === p) if (this.interpolationType === THREE.AnimationHandler.LINEAR) d.x = x[0] + (w[0] - x[0]) * u, d.y =
                        x[1] + (w[1] - x[1]) * u, d.z = x[2] + (w[2] - x[2]) * u, r = this.weight / (this.weight + n.positionWeight), l.position.lerp(d, r), n.positionWeight += this.weight; else {
                        if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) a[0] = this.getPrevKeyWith("pos", g, r.index - 1).pos, a[1] = x, a[2] = w, a[3] = this.getNextKeyWith("pos", g, v.index + 1).pos, u = .33 * u + .33, v = f(a, u), r = this.weight / (this.weight + n.positionWeight), n.positionWeight += this.weight, p = l.position, p.x += (v[0] -
                            p.x) * r, p.y += (v[1] - p.y) * r, p.z += (v[2] - p.z) * r, this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD && (u = f(a, 1.01 * u), b.set(u[0], u[1], u[2]), b.sub(p), b.y = 0, b.normalize(), u = Math.atan2(b.x, b.z), l.rotation.set(0, u, 0))
                    } else "rot" === p ? (THREE.Quaternion.slerp(x, w, e, u), 0 === n.quaternionWeight ? (l.quaternion.copy(e), n.quaternionWeight = this.weight) : (r = this.weight / (this.weight + n.quaternionWeight), THREE.Quaternion.slerp(l.quaternion, e, l.quaternion, r), n.quaternionWeight += this.weight)) : "scl" === p && (d.x = x[0] +
                        (w[0] - x[0]) * u, d.y = x[1] + (w[1] - x[1]) * u, d.z = x[2] + (w[2] - x[2]) * u, r = this.weight / (this.weight + n.scaleWeight), l.scale.lerp(d, r), n.scaleWeight += this.weight)
                }
                return !0
            }
        }
    }();
    THREE.Animation.prototype.getNextKeyWith = function (a, b, d) {
        var e = this.data.hierarchy[b].keys;
        for (d = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? d < e.length - 1 ? d : e.length - 1 : d % e.length; d < e.length; d++) if (void 0 !== e[d][a]) return e[d];
        return this.data.hierarchy[b].keys[0]
    };
    THREE.Animation.prototype.getPrevKeyWith = function (a, b, d) {
        var e = this.data.hierarchy[b].keys;
        for (d = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? 0 < d ? d : 0 : 0 <= d ? d : d + e.length; 0 <= d; d--) if (void 0 !== e[d][a]) return e[d];
        return this.data.hierarchy[b].keys[e.length - 1]
    };
    THREE.KeyFrameAnimation = function (a) {
        this.root = a.node;
        this.data = THREE.AnimationHandler.init(a);
        this.hierarchy = THREE.AnimationHandler.parse(this.root);
        this.currentTime = 0;
        this.timeScale = .001;
        this.isPlaying = !1;
        this.loop = this.isPaused = !0;
        a = 0;
        for (var b = this.hierarchy.length; a < b; a++) {
            var d = this.data.hierarchy[a].sids, e = this.hierarchy[a];
            if (this.data.hierarchy[a].keys.length && d) {
                for (var f = 0; f < d.length; f++) {
                    var h = d[f], g = this.getNextKeyWith(h, a, 0);
                    g && g.apply(h)
                }
                e.matrixAutoUpdate = !1;
                this.data.hierarchy[a].node.updateMatrix();
                e.matrixWorldNeedsUpdate = !0
            }
        }
    };
    THREE.KeyFrameAnimation.prototype.play = function (a) {
        this.currentTime = void 0 !== a ? a : 0;
        if (!1 === this.isPlaying) {
            this.isPlaying = !0;
            var b = this.hierarchy.length, d, e;
            for (a = 0; a < b; a++) d = this.hierarchy[a], e = this.data.hierarchy[a], void 0 === e.animationCache && (e.animationCache = {}, e.animationCache.prevKey = null, e.animationCache.nextKey = null, e.animationCache.originalMatrix = d.matrix), d = this.data.hierarchy[a].keys, d.length && (e.animationCache.prevKey = d[0], e.animationCache.nextKey = d[1], this.startTime = Math.min(d[0].time,
                this.startTime), this.endTime = Math.max(d[d.length - 1].time, this.endTime));
            this.update(0)
        }
        this.isPaused = !1;
        THREE.AnimationHandler.play(this)
    };
    THREE.KeyFrameAnimation.prototype.stop = function () {
        this.isPaused = this.isPlaying = !1;
        THREE.AnimationHandler.stop(this);
        for (var a = 0; a < this.data.hierarchy.length; a++) {
            var b = this.hierarchy[a], d = this.data.hierarchy[a];
            if (void 0 !== d.animationCache) {
                var e = d.animationCache.originalMatrix;
                e.copy(b.matrix);
                b.matrix = e;
                delete d.animationCache
            }
        }
    };
    THREE.KeyFrameAnimation.prototype.update = function (a) {
        if (!1 !== this.isPlaying) {
            this.currentTime += a * this.timeScale;
            a = this.data.length;
            !0 === this.loop && this.currentTime > a && (this.currentTime %= a);
            this.currentTime = Math.min(this.currentTime, a);
            a = 0;
            for (var b = this.hierarchy.length; a < b; a++) {
                var d = this.hierarchy[a], e = this.data.hierarchy[a], f = e.keys, e = e.animationCache;
                if (f.length) {
                    var h = e.prevKey, g = e.nextKey;
                    if (g.time <= this.currentTime) {
                        for (; g.time < this.currentTime && g.index > h.index;) h = g, g = f[h.index + 1];
                        e.prevKey =
                            h;
                        e.nextKey = g
                    }
                    g.time >= this.currentTime ? h.interpolate(g, this.currentTime) : h.interpolate(g, g.time);
                    this.data.hierarchy[a].node.updateMatrix();
                    d.matrixWorldNeedsUpdate = !0
                }
            }
        }
    };
    THREE.KeyFrameAnimation.prototype.getNextKeyWith = function (a, b, d) {
        b = this.data.hierarchy[b].keys;
        for (d %= b.length; d < b.length; d++) if (b[d].hasTarget(a)) return b[d];
        return b[0]
    };
    THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function (a, b, d) {
        b = this.data.hierarchy[b].keys;
        for (d = 0 <= d ? d : d + b.length; 0 <= d; d--) if (b[d].hasTarget(a)) return b[d];
        return b[b.length - 1]
    };
    THREE.MorphAnimation = function (a) {
        this.mesh = a;
        this.frames = a.morphTargetInfluences.length;
        this.currentTime = 0;
        this.duration = 1E3;
        this.loop = !0;
        this.isPlaying = !1
    };
    THREE.MorphAnimation.prototype = {
        play: function () {
            this.isPlaying = !0
        }, pause: function () {
            this.isPlaying = !1
        }, update: function () {
            var a = 0, b = 0;
            return function (d) {
                if (!1 !== this.isPlaying) {
                    this.currentTime += d;
                    !0 === this.loop && this.currentTime > this.duration && (this.currentTime %= this.duration);
                    this.currentTime = Math.min(this.currentTime, this.duration);
                    d = this.duration / this.frames;
                    var e = Math.floor(this.currentTime / d);
                    e != b && (this.mesh.morphTargetInfluences[a] = 0, this.mesh.morphTargetInfluences[b] = 1, this.mesh.morphTargetInfluences[e] =
                        0, a = b, b = e);
                    this.mesh.morphTargetInfluences[e] = this.currentTime % d / d;
                    this.mesh.morphTargetInfluences[a] = 1 - this.mesh.morphTargetInfluences[e]
                }
            }
        }()
    };
    THREE.BoxGeometry = function (a, b, d, e, f, h) {
        function g(a, b, d, e, g, h, f, u) {
            var x, w = k.widthSegments, z = k.heightSegments, F = g / 2, B = h / 2, H = k.vertices.length;
            if ("x" === a && "y" === b || "y" === a && "x" === b) x = "z"; else if ("x" === a && "z" === b || "z" === a && "x" === b) x = "y", z = k.depthSegments; else if ("z" === a && "y" === b || "y" === a && "z" === b) x = "x", w = k.depthSegments;
            var E = w + 1, I = z + 1, A = g / w, N = h / z, G = new THREE.Vector3;
            G[x] = 0 < f ? 1 : -1;
            for (g = 0; g < I; g++) for (h = 0; h < E; h++) {
                var D = new THREE.Vector3;
                D[a] = (h * A - F) * d;
                D[b] = (g * N - B) * e;
                D[x] = f;
                k.vertices.push(D)
            }
            for (g =
                     0; g < z; g++) for (h = 0; h < w; h++) B = h + E * g, a = h + E * (g + 1), b = h + 1 + E * (g + 1), d = h + 1 + E * g, e = new THREE.Vector2(h / w, 1 - g / z), f = new THREE.Vector2(h / w, 1 - (g + 1) / z), x = new THREE.Vector2((h + 1) / w, 1 - (g + 1) / z), F = new THREE.Vector2((h + 1) / w, 1 - g / z), B = new THREE.Face3(B + H, a + H, d + H), B.normal.copy(G), B.vertexNormals.push(G.clone(), G.clone(), G.clone()), B.materialIndex = u, k.faces.push(B), k.faceVertexUvs[0].push([e, f, F]), B = new THREE.Face3(a + H, b + H, d + H), B.normal.copy(G), B.vertexNormals.push(G.clone(), G.clone(), G.clone()), B.materialIndex = u, k.faces.push(B),
                k.faceVertexUvs[0].push([f.clone(), x, F.clone()])
        }

        THREE.Geometry.call(this);
        this.type = "BoxGeometry";
        this.parameters = {width: a, height: b, depth: d, widthSegments: e, heightSegments: f, depthSegments: h};
        this.widthSegments = e || 1;
        this.heightSegments = f || 1;
        this.depthSegments = h || 1;
        var k = this;
        e = a / 2;
        f = b / 2;
        h = d / 2;
        g("z", "y", -1, -1, d, b, e, 0);
        g("z", "y", 1, -1, d, b, -e, 1);
        g("x", "z", 1, 1, a, d, f, 2);
        g("x", "z", 1, -1, a, d, -f, 3);
        g("x", "y", 1, -1, a, b, h, 4);
        g("x", "y", -1, -1, a, b, -h, 5);
        this.mergeVertices()
    };
    THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.CircleGeometry = function (a, b, d, e) {
        THREE.Geometry.call(this);
        this.type = "CircleGeometry";
        this.parameters = {radius: a, segments: b, thetaStart: d, thetaLength: e};
        a = a || 50;
        b = void 0 !== b ? Math.max(3, b) : 8;
        d = void 0 !== d ? d : 0;
        e = void 0 !== e ? e : 2 * Math.PI;
        var f, h = [];
        f = new THREE.Vector3;
        var g = new THREE.Vector2(.5, .5);
        this.vertices.push(f);
        h.push(g);
        for (f = 0; f <= b; f++) {
            var k = new THREE.Vector3, l = d + f / b * e;
            k.x = a * Math.cos(l);
            k.y = a * Math.sin(l);
            this.vertices.push(k);
            h.push(new THREE.Vector2((k.x / a + 1) / 2, (k.y / a + 1) / 2))
        }
        d = new THREE.Vector3(0,
            0, 1);
        for (f = 1; f <= b; f++) this.faces.push(new THREE.Face3(f, f + 1, 0, [d.clone(), d.clone(), d.clone()])), this.faceVertexUvs[0].push([h[f].clone(), h[f + 1].clone(), g.clone()]);
        this.computeFaceNormals();
        this.boundingSphere = new THREE.Sphere(new THREE.Vector3, a)
    };
    THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.CubeGeometry = function (a, b, d, e, f, h) {
        console.warn("THREE.CubeGeometry has been renamed to THREE.BoxGeometry.");
        return new THREE.BoxGeometry(a, b, d, e, f, h)
    };
    THREE.CylinderGeometry = function (a, b, d, e, f, h) {
        THREE.Geometry.call(this);
        this.type = "CylinderGeometry";
        this.parameters = {
            radiusTop: a,
            radiusBottom: b,
            height: d,
            radialSegments: e,
            heightSegments: f,
            openEnded: h
        };
        a = void 0 !== a ? a : 20;
        b = void 0 !== b ? b : 20;
        d = void 0 !== d ? d : 100;
        e = e || 8;
        f = f || 1;
        h = void 0 !== h ? h : !1;
        var g = d / 2, k, l, m = [], n = [];
        for (l = 0; l <= f; l++) {
            var q = [], p = [], r = l / f, v = r * (b - a) + a;
            for (k = 0; k <= e; k++) {
                var u = k / e, x = new THREE.Vector3;
                x.x = v * Math.sin(u * Math.PI * 2);
                x.y = -r * d + g;
                x.z = v * Math.cos(u * Math.PI * 2);
                this.vertices.push(x);
                q.push(this.vertices.length -
                    1);
                p.push(new THREE.Vector2(u, 1 - r))
            }
            m.push(q);
            n.push(p)
        }
        d = (b - a) / d;
        for (k = 0; k < e; k++) for (0 !== a ? (q = this.vertices[m[0][k]].clone(), p = this.vertices[m[0][k + 1]].clone()) : (q = this.vertices[m[1][k]].clone(), p = this.vertices[m[1][k + 1]].clone()), q.setY(Math.sqrt(q.x * q.x + q.z * q.z) * d).normalize(), p.setY(Math.sqrt(p.x * p.x + p.z * p.z) * d).normalize(), l = 0; l < f; l++) {
            var r = m[l][k], v = m[l + 1][k], u = m[l + 1][k + 1], x = m[l][k + 1], w = q.clone(), z = q.clone(),
                F = p.clone(), B = p.clone(), H = n[l][k].clone(), E = n[l + 1][k].clone(), I = n[l + 1][k + 1].clone(),
                A = n[l][k + 1].clone();
            this.faces.push(new THREE.Face3(r, v, x, [w, z, B]));
            this.faceVertexUvs[0].push([H, E, A]);
            this.faces.push(new THREE.Face3(v, u, x, [z.clone(), F, B.clone()]));
            this.faceVertexUvs[0].push([E.clone(), I, A.clone()])
        }
        if (!1 === h && 0 < a) for (this.vertices.push(new THREE.Vector3(0, g, 0)), k = 0; k < e; k++) r = m[0][k], v = m[0][k + 1], u = this.vertices.length - 1, w = new THREE.Vector3(0, 1, 0), z = new THREE.Vector3(0, 1, 0), F = new THREE.Vector3(0, 1, 0), H = n[0][k].clone(), E = n[0][k + 1].clone(), I = new THREE.Vector2(E.x, 0), this.faces.push(new THREE.Face3(r,
            v, u, [w, z, F])), this.faceVertexUvs[0].push([H, E, I]);
        if (!1 === h && 0 < b) for (this.vertices.push(new THREE.Vector3(0, -g, 0)), k = 0; k < e; k++) r = m[l][k + 1], v = m[l][k], u = this.vertices.length - 1, w = new THREE.Vector3(0, -1, 0), z = new THREE.Vector3(0, -1, 0), F = new THREE.Vector3(0, -1, 0), H = n[l][k + 1].clone(), E = n[l][k].clone(), I = new THREE.Vector2(E.x, 1), this.faces.push(new THREE.Face3(r, v, u, [w, z, F])), this.faceVertexUvs[0].push([H, E, I]);
        this.computeFaceNormals()
    };
    THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.ExtrudeGeometry = function (a, b) {
        "undefined" !== typeof a && (THREE.Geometry.call(this), this.type = "ExtrudeGeometry", a = a instanceof Array ? a : [a], this.addShapeList(a, b), this.computeFaceNormals())
    };
    THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.ExtrudeGeometry.prototype.addShapeList = function (a, b) {
        for (var d = a.length, e = 0; e < d; e++) this.addShape(a[e], b)
    };
    THREE.ExtrudeGeometry.prototype.addShape = function (a, b) {
        function d(a, b, d) {
            b || console.log("die");
            return b.clone().multiplyScalar(d).add(a)
        }

        function e(a, b, d) {
            var e = 1, e = a.x - b.x, g = a.y - b.y, h = d.x - a.x, f = d.y - a.y, k = e * e + g * g;
            if (1E-10 < Math.abs(e * f - g * h)) {
                var l = Math.sqrt(k), m = Math.sqrt(h * h + f * f), k = b.x - g / l;
                b = b.y + e / l;
                h = ((d.x - f / m - k) * f - (d.y + h / m - b) * h) / (e * f - g * h);
                d = k + e * h - a.x;
                a = b + g * h - a.y;
                e = d * d + a * a;
                if (2 >= e) return new THREE.Vector2(d, a);
                e = Math.sqrt(e / 2)
            } else a = !1, 1E-10 < e ? 1E-10 < h && (a = !0) : -1E-10 > e ? -1E-10 > h && (a = !0) : Math.sign(g) ==
                Math.sign(f) && (a = !0), a ? (d = -g, a = e, e = Math.sqrt(k)) : (d = e, a = g, e = Math.sqrt(k / 2));
            return new THREE.Vector2(d / e, a / e)
        }

        function f(a, b) {
            var d, e;
            for (M = a.length; 0 <= --M;) {
                d = M;
                e = M - 1;
                0 > e && (e = a.length - 1);
                for (var g = 0, h = r + 2 * n, g = 0; g < h; g++) {
                    var f = S * g, k = S * (g + 1), l = b + d + f, f = b + e + f, m = b + e + k, k = b + d + k,
                        l = l + Y, f = f + Y, m = m + Y, k = k + Y;
                    D.faces.push(new THREE.Face3(l, f, k, null, null, z));
                    D.faces.push(new THREE.Face3(f, m, k, null, null, z));
                    l = F.generateSideWallUV(D, l, f, m, k);
                    D.faceVertexUvs[0].push([l[0], l[1], l[3]]);
                    D.faceVertexUvs[0].push([l[1],
                        l[2], l[3]])
                }
            }
        }

        function h(a, b, d) {
            D.vertices.push(new THREE.Vector3(a, b, d))
        }

        function g(a, b, d) {
            a += Y;
            b += Y;
            d += Y;
            D.faces.push(new THREE.Face3(a, b, d, null, null, w));
            a = F.generateTopUV(D, a, b, d);
            D.faceVertexUvs[0].push(a)
        }

        var k = void 0 !== b.amount ? b.amount : 100, l = void 0 !== b.bevelThickness ? b.bevelThickness : 6,
            m = void 0 !== b.bevelSize ? b.bevelSize : l - 2, n = void 0 !== b.bevelSegments ? b.bevelSegments : 3,
            q = void 0 !== b.bevelEnabled ? b.bevelEnabled : !0, p = void 0 !== b.curveSegments ? b.curveSegments : 12,
            r = void 0 !== b.steps ? b.steps : 1, v = b.extrudePath,
            u, x = !1, w = b.material, z = b.extrudeMaterial,
            F = void 0 !== b.UVGenerator ? b.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator, B, H, E, I;
        v && (u = v.getSpacedPoints(r), x = !0, q = !1, B = void 0 !== b.frames ? b.frames : new THREE.TubeGeometry.FrenetFrames(v, r, !1), H = new THREE.Vector3, E = new THREE.Vector3, I = new THREE.Vector3);
        q || (m = l = n = 0);
        var A, N, G, D = this, Y = this.vertices.length, v = a.extractPoints(p), p = v.shape, C = v.holes;
        if (v = !THREE.Shape.Utils.isClockWise(p)) {
            p = p.reverse();
            N = 0;
            for (G = C.length; N < G; N++) A = C[N], THREE.Shape.Utils.isClockWise(A) &&
            (C[N] = A.reverse());
            v = !1
        }
        var K = THREE.Shape.Utils.triangulateShape(p, C), J = p;
        N = 0;
        for (G = C.length; N < G; N++) A = C[N], p = p.concat(A);
        var L, U, aa, Z, P, S = p.length, da, ca = K.length, v = [], M = 0;
        aa = J.length;
        L = aa - 1;
        for (U = M + 1; M < aa; M++, L++, U++) L === aa && (L = 0), U === aa && (U = 0), v[M] = e(J[M], J[L], J[U]);
        var la = [], ea, ka = v.concat();
        N = 0;
        for (G = C.length; N < G; N++) {
            A = C[N];
            ea = [];
            M = 0;
            aa = A.length;
            L = aa - 1;
            for (U = M + 1; M < aa; M++, L++, U++) L === aa && (L = 0), U === aa && (U = 0), ea[M] = e(A[M], A[L], A[U]);
            la.push(ea);
            ka = ka.concat(ea)
        }
        for (L = 0; L < n; L++) {
            aa = L / n;
            Z = l * (1 - aa);
            U = m * Math.sin(aa * Math.PI / 2);
            M = 0;
            for (aa = J.length; M < aa; M++) P = d(J[M], v[M], U), h(P.x, P.y, -Z);
            N = 0;
            for (G = C.length; N < G; N++) for (A = C[N], ea = la[N], M = 0, aa = A.length; M < aa; M++) P = d(A[M], ea[M], U), h(P.x, P.y, -Z)
        }
        U = m;
        for (M = 0; M < S; M++) P = q ? d(p[M], ka[M], U) : p[M], x ? (E.copy(B.normals[0]).multiplyScalar(P.x), H.copy(B.binormals[0]).multiplyScalar(P.y), I.copy(u[0]).add(E).add(H), h(I.x, I.y, I.z)) : h(P.x, P.y, 0);
        for (aa = 1; aa <= r; aa++) for (M = 0; M < S; M++) P = q ? d(p[M], ka[M], U) : p[M], x ? (E.copy(B.normals[aa]).multiplyScalar(P.x), H.copy(B.binormals[aa]).multiplyScalar(P.y),
            I.copy(u[aa]).add(E).add(H), h(I.x, I.y, I.z)) : h(P.x, P.y, k / r * aa);
        for (L = n - 1; 0 <= L; L--) {
            aa = L / n;
            Z = l * (1 - aa);
            U = m * Math.sin(aa * Math.PI / 2);
            M = 0;
            for (aa = J.length; M < aa; M++) P = d(J[M], v[M], U), h(P.x, P.y, k + Z);
            N = 0;
            for (G = C.length; N < G; N++) for (A = C[N], ea = la[N], M = 0, aa = A.length; M < aa; M++) P = d(A[M], ea[M], U), x ? h(P.x, P.y + u[r - 1].y, u[r - 1].x + Z) : h(P.x, P.y, k + Z)
        }
        (function () {
            if (q) {
                var a;
                a = 0 * S;
                for (M = 0; M < ca; M++) da = K[M], g(da[2] + a, da[1] + a, da[0] + a);
                a = r + 2 * n;
                a *= S;
                for (M = 0; M < ca; M++) da = K[M], g(da[0] + a, da[1] + a, da[2] + a)
            } else {
                for (M = 0; M < ca; M++) da = K[M],
                    g(da[2], da[1], da[0]);
                for (M = 0; M < ca; M++) da = K[M], g(da[0] + S * r, da[1] + S * r, da[2] + S * r)
            }
        })();
        (function () {
            var a = 0;
            f(J, a);
            a += J.length;
            N = 0;
            for (G = C.length; N < G; N++) A = C[N], f(A, a), a += A.length
        })()
    };
    THREE.ExtrudeGeometry.WorldUVGenerator = {
        generateTopUV: function (a, b, d, e) {
            a = a.vertices;
            b = a[b];
            d = a[d];
            e = a[e];
            return [new THREE.Vector2(b.x, b.y), new THREE.Vector2(d.x, d.y), new THREE.Vector2(e.x, e.y)]
        }, generateSideWallUV: function (a, b, d, e, f) {
            a = a.vertices;
            b = a[b];
            d = a[d];
            e = a[e];
            f = a[f];
            return .01 > Math.abs(b.y - d.y) ? [new THREE.Vector2(b.x, 1 - b.z), new THREE.Vector2(d.x, 1 - d.z), new THREE.Vector2(e.x, 1 - e.z), new THREE.Vector2(f.x, 1 - f.z)] : [new THREE.Vector2(b.y, 1 - b.z), new THREE.Vector2(d.y, 1 - d.z), new THREE.Vector2(e.y,
                1 - e.z), new THREE.Vector2(f.y, 1 - f.z)]
        }
    };
    THREE.ShapeGeometry = function (a, b) {
        THREE.Geometry.call(this);
        this.type = "ShapeGeometry";
        !1 === a instanceof Array && (a = [a]);
        this.addShapeList(a, b);
        this.computeFaceNormals()
    };
    THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.ShapeGeometry.prototype.addShapeList = function (a, b) {
        for (var d = 0, e = a.length; d < e; d++) this.addShape(a[d], b);
        return this
    };
    THREE.ShapeGeometry.prototype.addShape = function (a, b) {
        void 0 === b && (b = {});
        var d = b.material, e = void 0 === b.UVGenerator ? THREE.ExtrudeGeometry.WorldUVGenerator : b.UVGenerator, f, h,
            g, k = this.vertices.length;
        f = a.extractPoints(void 0 !== b.curveSegments ? b.curveSegments : 12);
        var l = f.shape, m = f.holes;
        if (!THREE.Shape.Utils.isClockWise(l)) for (l = l.reverse(), f = 0, h = m.length; f < h; f++) g = m[f], THREE.Shape.Utils.isClockWise(g) && (m[f] = g.reverse());
        var n = THREE.Shape.Utils.triangulateShape(l, m);
        f = 0;
        for (h = m.length; f < h; f++) g = m[f],
            l = l.concat(g);
        m = l.length;
        h = n.length;
        for (f = 0; f < m; f++) g = l[f], this.vertices.push(new THREE.Vector3(g.x, g.y, 0));
        for (f = 0; f < h; f++) m = n[f], l = m[0] + k, g = m[1] + k, m = m[2] + k, this.faces.push(new THREE.Face3(l, g, m, null, null, d)), this.faceVertexUvs[0].push(e.generateTopUV(this, l, g, m))
    };
    THREE.LatheGeometry = function (a, b, d, e) {
        THREE.Geometry.call(this);
        this.type = "LatheGeometry";
        this.parameters = {points: a, segments: b, phiStart: d, phiLength: e};
        b = b || 12;
        d = d || 0;
        e = e || 2 * Math.PI;
        for (var f = 1 / (a.length - 1), h = 1 / b, g = 0, k = b; g <= k; g++) for (var l = d + g * h * e, m = Math.cos(l), n = Math.sin(l), l = 0, q = a.length; l < q; l++) {
            var p = a[l], r = new THREE.Vector3;
            r.x = m * p.x - n * p.y;
            r.y = n * p.x + m * p.y;
            r.z = p.z;
            this.vertices.push(r)
        }
        d = a.length;
        g = 0;
        for (k = b; g < k; g++) for (l = 0, q = a.length - 1; l < q; l++) {
            b = n = l + d * g;
            e = n + d;
            var m = n + 1 + d, n = n + 1, p = g * h, r = l * f, v =
                p + h, u = r + f;
            this.faces.push(new THREE.Face3(b, e, n));
            this.faceVertexUvs[0].push([new THREE.Vector2(p, r), new THREE.Vector2(v, r), new THREE.Vector2(p, u)]);
            this.faces.push(new THREE.Face3(e, m, n));
            this.faceVertexUvs[0].push([new THREE.Vector2(v, r), new THREE.Vector2(v, u), new THREE.Vector2(p, u)])
        }
        this.mergeVertices();
        this.computeFaceNormals();
        this.computeVertexNormals()
    };
    THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.PlaneGeometry = function (a, b, d, e) {
        console.info("THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint.");
        THREE.Geometry.call(this);
        this.type = "PlaneGeometry";
        this.parameters = {width: a, height: b, widthSegments: d, heightSegments: e};
        this.fromBufferGeometry(new THREE.PlaneBufferGeometry(a, b, d, e))
    };
    THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.PlaneBufferGeometry = function (a, b, d, e) {
        THREE.BufferGeometry.call(this);
        this.type = "PlaneBufferGeometry";
        this.parameters = {width: a, height: b, widthSegments: d, heightSegments: e};
        var f = a / 2, h = b / 2;
        d = d || 1;
        e = e || 1;
        var g = d + 1, k = e + 1, l = a / d, m = b / e;
        b = new Float32Array(g * k * 3);
        a = new Float32Array(g * k * 3);
        for (var n = new Float32Array(g * k * 2), q = 0, p = 0, r = 0; r < k; r++) for (var v = r * m - h, u = 0; u < g; u++) b[q] = u * l - f, b[q + 1] = -v, a[q + 2] = 1, n[p] = u / d, n[p + 1] = 1 - r / e, q += 3, p += 2;
        q = 0;
        f = new (65535 < b.length / 3 ? Uint32Array : Uint16Array)(d * e * 6);
        for (r = 0; r < e; r++) for (u =
                                         0; u < d; u++) h = u + g * (r + 1), k = u + 1 + g * (r + 1), l = u + 1 + g * r, f[q] = u + g * r, f[q + 1] = h, f[q + 2] = l, f[q + 3] = h, f[q + 4] = k, f[q + 5] = l, q += 6;
        this.addAttribute("index", new THREE.BufferAttribute(f, 1));
        this.addAttribute("position", new THREE.BufferAttribute(b, 3));
        this.addAttribute("normal", new THREE.BufferAttribute(a, 3));
        this.addAttribute("uv", new THREE.BufferAttribute(n, 2))
    };
    THREE.PlaneBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.RingGeometry = function (a, b, d, e, f, h) {
        THREE.Geometry.call(this);
        this.type = "RingGeometry";
        this.parameters = {
            innerRadius: a,
            outerRadius: b,
            thetaSegments: d,
            phiSegments: e,
            thetaStart: f,
            thetaLength: h
        };
        a = a || 0;
        b = b || 50;
        f = void 0 !== f ? f : 0;
        h = void 0 !== h ? h : 2 * Math.PI;
        d = void 0 !== d ? Math.max(3, d) : 8;
        e = void 0 !== e ? Math.max(1, e) : 8;
        var g, k = [], l = a, m = (b - a) / e;
        for (a = 0; a < e + 1; a++) {
            for (g = 0; g < d + 1; g++) {
                var n = new THREE.Vector3, q = f + g / d * h;
                n.x = l * Math.cos(q);
                n.y = l * Math.sin(q);
                this.vertices.push(n);
                k.push(new THREE.Vector2((n.x / b + 1) / 2,
                    (n.y / b + 1) / 2))
            }
            l += m
        }
        b = new THREE.Vector3(0, 0, 1);
        for (a = 0; a < e; a++) for (f = a * (d + 1), g = 0; g < d; g++) h = q = g + f, m = q + d + 1, n = q + d + 2, this.faces.push(new THREE.Face3(h, m, n, [b.clone(), b.clone(), b.clone()])), this.faceVertexUvs[0].push([k[h].clone(), k[m].clone(), k[n].clone()]), h = q, m = q + d + 2, n = q + 1, this.faces.push(new THREE.Face3(h, m, n, [b.clone(), b.clone(), b.clone()])), this.faceVertexUvs[0].push([k[h].clone(), k[m].clone(), k[n].clone()]);
        this.computeFaceNormals();
        this.boundingSphere = new THREE.Sphere(new THREE.Vector3, l)
    };
    THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.SphereGeometry = function (a, b, d, e, f, h, g) {
        THREE.Geometry.call(this);
        this.type = "SphereGeometry";
        this.parameters = {
            radius: a,
            widthSegments: b,
            heightSegments: d,
            phiStart: e,
            phiLength: f,
            thetaStart: h,
            thetaLength: g
        };
        a = a || 50;
        b = Math.max(3, Math.floor(b) || 8);
        d = Math.max(2, Math.floor(d) || 6);
        e = void 0 !== e ? e : 0;
        f = void 0 !== f ? f : 2 * Math.PI;
        h = void 0 !== h ? h : 0;
        g = void 0 !== g ? g : Math.PI;
        var k, l, m = [], n = [];
        for (l = 0; l <= d; l++) {
            var q = [], p = [];
            for (k = 0; k <= b; k++) {
                var r = k / b, v = l / d, u = new THREE.Vector3;
                u.x = -a * Math.cos(e + r * f) * Math.sin(h + v * g);
                u.y = a * Math.cos(h + v * g);
                u.z = a * Math.sin(e + r * f) * Math.sin(h + v * g);
                this.vertices.push(u);
                q.push(this.vertices.length - 1);
                p.push(new THREE.Vector2(r, 1 - v))
            }
            m.push(q);
            n.push(p)
        }
        for (l = 0; l < d; l++) for (k = 0; k < b; k++) {
            e = m[l][k + 1];
            f = m[l][k];
            h = m[l + 1][k];
            g = m[l + 1][k + 1];
            var q = this.vertices[e].clone().normalize(), p = this.vertices[f].clone().normalize(),
                r = this.vertices[h].clone().normalize(), v = this.vertices[g].clone().normalize(),
                u = n[l][k + 1].clone(), x = n[l][k].clone(), w = n[l + 1][k].clone(), z = n[l + 1][k + 1].clone();
            Math.abs(this.vertices[e].y) ===
            a ? (u.x = (u.x + x.x) / 2, this.faces.push(new THREE.Face3(e, h, g, [q, r, v])), this.faceVertexUvs[0].push([u, w, z])) : Math.abs(this.vertices[h].y) === a ? (w.x = (w.x + z.x) / 2, this.faces.push(new THREE.Face3(e, f, h, [q, p, r])), this.faceVertexUvs[0].push([u, x, w])) : (this.faces.push(new THREE.Face3(e, f, g, [q, p, v])), this.faceVertexUvs[0].push([u, x, z]), this.faces.push(new THREE.Face3(f, h, g, [p.clone(), r, v.clone()])), this.faceVertexUvs[0].push([x.clone(), w, z.clone()]))
        }
        this.computeFaceNormals();
        this.boundingSphere = new THREE.Sphere(new THREE.Vector3,
            a)
    };
    THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.TextGeometry = function (a, b) {
        b = b || {};
        var d = THREE.FontUtils.generateShapes(a, b);
        b.amount = void 0 !== b.height ? b.height : 50;
        void 0 === b.bevelThickness && (b.bevelThickness = 10);
        void 0 === b.bevelSize && (b.bevelSize = 8);
        void 0 === b.bevelEnabled && (b.bevelEnabled = !1);
        THREE.ExtrudeGeometry.call(this, d, b);
        this.type = "TextGeometry"
    };
    THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype);
    THREE.TorusGeometry = function (a, b, d, e, f) {
        THREE.Geometry.call(this);
        this.type = "TorusGeometry";
        this.parameters = {radius: a, tube: b, radialSegments: d, tubularSegments: e, arc: f};
        a = a || 100;
        b = b || 40;
        d = d || 8;
        e = e || 6;
        f = f || 2 * Math.PI;
        for (var h = new THREE.Vector3, g = [], k = [], l = 0; l <= d; l++) for (var m = 0; m <= e; m++) {
            var n = m / e * f, q = l / d * Math.PI * 2;
            h.x = a * Math.cos(n);
            h.y = a * Math.sin(n);
            var p = new THREE.Vector3;
            p.x = (a + b * Math.cos(q)) * Math.cos(n);
            p.y = (a + b * Math.cos(q)) * Math.sin(n);
            p.z = b * Math.sin(q);
            this.vertices.push(p);
            g.push(new THREE.Vector2(m /
                e, l / d));
            k.push(p.clone().sub(h).normalize())
        }
        for (l = 1; l <= d; l++) for (m = 1; m <= e; m++) a = (e + 1) * l + m - 1, b = (e + 1) * (l - 1) + m - 1, f = (e + 1) * (l - 1) + m, h = (e + 1) * l + m, n = new THREE.Face3(a, b, h, [k[a].clone(), k[b].clone(), k[h].clone()]), this.faces.push(n), this.faceVertexUvs[0].push([g[a].clone(), g[b].clone(), g[h].clone()]), n = new THREE.Face3(b, f, h, [k[b].clone(), k[f].clone(), k[h].clone()]), this.faces.push(n), this.faceVertexUvs[0].push([g[b].clone(), g[f].clone(), g[h].clone()]);
        this.computeFaceNormals()
    };
    THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.TorusKnotGeometry = function (a, b, d, e, f, h, g) {
        function k(a, b, d, e, g) {
            var h = Math.cos(a), f = Math.sin(a);
            a *= b / d;
            b = Math.cos(a);
            h *= e * (2 + b) * .5;
            f = e * (2 + b) * f * .5;
            e = g * e * Math.sin(a) * .5;
            return new THREE.Vector3(h, f, e)
        }

        THREE.Geometry.call(this);
        this.type = "TorusKnotGeometry";
        this.parameters = {radius: a, tube: b, radialSegments: d, tubularSegments: e, p: f, q: h, heightScale: g};
        a = a || 100;
        b = b || 40;
        d = d || 64;
        e = e || 8;
        f = f || 2;
        h = h || 3;
        g = g || 1;
        for (var l = Array(d), m = new THREE.Vector3, n = new THREE.Vector3, q = new THREE.Vector3, p = 0; p < d; ++p) {
            l[p] =
                Array(e);
            var r = p / d * 2 * f * Math.PI, v = k(r, h, f, a, g), r = k(r + .01, h, f, a, g);
            m.subVectors(r, v);
            n.addVectors(r, v);
            q.crossVectors(m, n);
            n.crossVectors(q, m);
            q.normalize();
            n.normalize();
            for (r = 0; r < e; ++r) {
                var u = r / e * 2 * Math.PI, x = -b * Math.cos(u), u = b * Math.sin(u), w = new THREE.Vector3;
                w.x = v.x + x * n.x + u * q.x;
                w.y = v.y + x * n.y + u * q.y;
                w.z = v.z + x * n.z + u * q.z;
                l[p][r] = this.vertices.push(w) - 1
            }
        }
        for (p = 0; p < d; ++p) for (r = 0; r < e; ++r) f = (p + 1) % d, h = (r + 1) % e, a = l[p][r], b = l[f][r], f = l[f][h], h = l[p][h], g = new THREE.Vector2(p / d, r / e), m = new THREE.Vector2((p + 1) / d,
            r / e), n = new THREE.Vector2((p + 1) / d, (r + 1) / e), q = new THREE.Vector2(p / d, (r + 1) / e), this.faces.push(new THREE.Face3(a, b, h)), this.faceVertexUvs[0].push([g, m, q]), this.faces.push(new THREE.Face3(b, f, h)), this.faceVertexUvs[0].push([m.clone(), n, q.clone()]);
        this.computeFaceNormals();
        this.computeVertexNormals()
    };
    THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.TubeGeometry = function (a, b, d, e, f) {
        THREE.Geometry.call(this);
        this.type = "TubeGeometry";
        this.parameters = {path: a, segments: b, radius: d, radialSegments: e, closed: f};
        b = b || 64;
        d = d || 1;
        e = e || 8;
        f = f || !1;
        var h = [], g, k, l = b + 1, m, n, q, p, r = new THREE.Vector3, v, u, x;
        v = new THREE.TubeGeometry.FrenetFrames(a, b, f);
        u = v.normals;
        x = v.binormals;
        this.tangents = v.tangents;
        this.normals = u;
        this.binormals = x;
        for (v = 0; v < l; v++) for (h[v] = [], m = v / (l - 1), p = a.getPointAt(m), g = u[v], k = x[v], m = 0; m < e; m++) n = m / e * 2 * Math.PI, q = -d * Math.cos(n), n = d * Math.sin(n),
            r.copy(p), r.x += q * g.x + n * k.x, r.y += q * g.y + n * k.y, r.z += q * g.z + n * k.z, h[v][m] = this.vertices.push(new THREE.Vector3(r.x, r.y, r.z)) - 1;
        for (v = 0; v < b; v++) for (m = 0; m < e; m++) l = f ? (v + 1) % b : v + 1, r = (m + 1) % e, a = h[v][m], d = h[l][m], l = h[l][r], r = h[v][r], u = new THREE.Vector2(v / b, m / e), x = new THREE.Vector2((v + 1) / b, m / e), g = new THREE.Vector2((v + 1) / b, (m + 1) / e), k = new THREE.Vector2(v / b, (m + 1) / e), this.faces.push(new THREE.Face3(a, d, r)), this.faceVertexUvs[0].push([u, x, k]), this.faces.push(new THREE.Face3(d, l, r)), this.faceVertexUvs[0].push([x.clone(),
            g, k.clone()]);
        this.computeFaceNormals();
        this.computeVertexNormals()
    };
    THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.TubeGeometry.FrenetFrames = function (a, b, d) {
        new THREE.Vector3;
        var e = new THREE.Vector3;
        new THREE.Vector3;
        var f = [], h = [], g = [], k = new THREE.Vector3, l = new THREE.Matrix4;
        b += 1;
        var m, n, q;
        this.tangents = f;
        this.normals = h;
        this.binormals = g;
        for (m = 0; m < b; m++) n = m / (b - 1), f[m] = a.getTangentAt(n), f[m].normalize();
        h[0] = new THREE.Vector3;
        g[0] = new THREE.Vector3;
        a = Number.MAX_VALUE;
        m = Math.abs(f[0].x);
        n = Math.abs(f[0].y);
        q = Math.abs(f[0].z);
        m <= a && (a = m, e.set(1, 0, 0));
        n <= a && (a = n, e.set(0, 1, 0));
        q <= a && e.set(0, 0, 1);
        k.crossVectors(f[0],
            e).normalize();
        h[0].crossVectors(f[0], k);
        g[0].crossVectors(f[0], h[0]);
        for (m = 1; m < b; m++) h[m] = h[m - 1].clone(), g[m] = g[m - 1].clone(), k.crossVectors(f[m - 1], f[m]), 1E-4 < k.length() && (k.normalize(), e = Math.acos(THREE.Math.clamp(f[m - 1].dot(f[m]), -1, 1)), h[m].applyMatrix4(l.makeRotationAxis(k, e))), g[m].crossVectors(f[m], h[m]);
        if (d) for (e = Math.acos(THREE.Math.clamp(h[0].dot(h[b - 1]), -1, 1)), e /= b - 1, 0 < f[0].dot(k.crossVectors(h[0], h[b - 1])) && (e = -e), m = 1; m < b; m++) h[m].applyMatrix4(l.makeRotationAxis(f[m], e * m)), g[m].crossVectors(f[m],
            h[m])
    };
    THREE.PolyhedronGeometry = function (a, b, d, e) {
        function f(a) {
            var b = a.normalize().clone();
            b.index = l.vertices.push(b) - 1;
            var d = Math.atan2(a.z, -a.x) / 2 / Math.PI + .5;
            a = Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5;
            b.uv = new THREE.Vector2(d, 1 - a);
            return b
        }

        function h(a, b, d) {
            var e = new THREE.Face3(a.index, b.index, d.index, [a.clone(), b.clone(), d.clone()]);
            l.faces.push(e);
            x.copy(a).add(b).add(d).divideScalar(3);
            e = Math.atan2(x.z, -x.x);
            l.faceVertexUvs[0].push([k(a.uv, a, e), k(b.uv, b, e), k(d.uv, d, e)])
        }

        function g(a, b) {
            var d =
                Math.pow(2, b);
            Math.pow(4, b);
            for (var e = f(l.vertices[a.a]), g = f(l.vertices[a.b]), k = f(l.vertices[a.c]), m = [], n = 0; n <= d; n++) {
                m[n] = [];
                for (var p = f(e.clone().lerp(k, n / d)), q = f(g.clone().lerp(k, n / d)), u = d - n, r = 0; r <= u; r++) m[n][r] = 0 == r && n == d ? p : f(p.clone().lerp(q, r / u))
            }
            for (n = 0; n < d; n++) for (r = 0; r < 2 * (d - n) - 1; r++) e = Math.floor(r / 2), 0 == r % 2 ? h(m[n][e + 1], m[n + 1][e], m[n][e]) : h(m[n][e + 1], m[n + 1][e + 1], m[n + 1][e])
        }

        function k(a, b, d) {
            0 > d && 1 === a.x && (a = new THREE.Vector2(a.x - 1, a.y));
            0 === b.x && 0 === b.z && (a = new THREE.Vector2(d / 2 / Math.PI + .5,
                a.y));
            return a.clone()
        }

        THREE.Geometry.call(this);
        this.type = "PolyhedronGeometry";
        this.parameters = {vertices: a, indices: b, radius: d, detail: e};
        d = d || 1;
        e = e || 0;
        for (var l = this, m = 0, n = a.length; m < n; m += 3) f(new THREE.Vector3(a[m], a[m + 1], a[m + 2]));
        a = this.vertices;
        for (var q = [], p = m = 0, n = b.length; m < n; m += 3, p++) {
            var r = a[b[m]], v = a[b[m + 1]], u = a[b[m + 2]];
            q[p] = new THREE.Face3(r.index, v.index, u.index, [r.clone(), v.clone(), u.clone()])
        }
        for (var x = new THREE.Vector3, m = 0, n = q.length; m < n; m++) g(q[m], e);
        m = 0;
        for (n = this.faceVertexUvs[0].length; m <
        n; m++) b = this.faceVertexUvs[0][m], e = b[0].x, a = b[1].x, q = b[2].x, p = Math.max(e, Math.max(a, q)), r = Math.min(e, Math.min(a, q)), .9 < p && .1 > r && (.2 > e && (b[0].x += 1), .2 > a && (b[1].x += 1), .2 > q && (b[2].x += 1));
        m = 0;
        for (n = this.vertices.length; m < n; m++) this.vertices[m].multiplyScalar(d);
        this.mergeVertices();
        this.computeFaceNormals();
        this.boundingSphere = new THREE.Sphere(new THREE.Vector3, d)
    };
    THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.DodecahedronGeometry = function (a, b) {
        this.parameters = {radius: a, detail: b};
        var d = (1 + Math.sqrt(5)) / 2, e = 1 / d;
        THREE.PolyhedronGeometry.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -e, -d, 0, -e, d, 0, e, -d, 0, e, d, -e, -d, 0, -e, d, 0, e, -d, 0, e, d, 0, -d, 0, -e, d, 0, -e, -d, 0, e, d, 0, e], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19,
            11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], a, b)
    };
    THREE.DodecahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.IcosahedronGeometry = function (a, b) {
        var d = (1 + Math.sqrt(5)) / 2;
        THREE.PolyhedronGeometry.call(this, [-1, d, 0, 1, d, 0, -1, -d, 0, 1, -d, 0, 0, -1, d, 0, 1, d, 0, -1, -d, 0, 1, -d, d, 0, -1, d, 0, 1, -d, 0, -1, -d, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], a, b);
        this.type = "IcosahedronGeometry";
        this.parameters = {radius: a, detail: b}
    };
    THREE.IcosahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.OctahedronGeometry = function (a, b) {
        this.parameters = {radius: a, detail: b};
        THREE.PolyhedronGeometry.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], a, b);
        this.type = "OctahedronGeometry";
        this.parameters = {radius: a, detail: b}
    };
    THREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.TetrahedronGeometry = function (a, b) {
        THREE.PolyhedronGeometry.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], a, b);
        this.type = "TetrahedronGeometry";
        this.parameters = {radius: a, detail: b}
    };
    THREE.TetrahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.ParametricGeometry = function (a, b, d) {
        THREE.Geometry.call(this);
        this.type = "ParametricGeometry";
        this.parameters = {func: a, slices: b, stacks: d};
        var e = this.vertices, f = this.faces, h = this.faceVertexUvs[0], g, k, l, m, n = b + 1;
        for (g = 0; g <= d; g++) for (m = g / d, k = 0; k <= b; k++) l = k / b, l = a(l, m), e.push(l);
        var q, p, r, v;
        for (g = 0; g < d; g++) for (k = 0; k < b; k++) a = g * n + k, e = g * n + k + 1, m = (g + 1) * n + k + 1, l = (g + 1) * n + k, q = new THREE.Vector2(k / b, g / d), p = new THREE.Vector2((k + 1) / b, g / d), r = new THREE.Vector2((k + 1) / b, (g + 1) / d), v = new THREE.Vector2(k / b, (g + 1) / d), f.push(new THREE.Face3(a,
            e, l)), h.push([q, p, v]), f.push(new THREE.Face3(e, m, l)), h.push([p.clone(), r, v.clone()]);
        this.computeFaceNormals();
        this.computeVertexNormals()
    };
    THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.AxisHelper = function (a) {
        a = a || 1;
        var b = new Float32Array([0, 0, 0, a, 0, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a]),
            d = new Float32Array([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]);
        a = new THREE.BufferGeometry;
        a.addAttribute("position", new THREE.BufferAttribute(b, 3));
        a.addAttribute("color", new THREE.BufferAttribute(d, 3));
        b = new THREE.LineBasicMaterial({vertexColors: THREE.VertexColors});
        THREE.Line.call(this, a, b, THREE.LinePieces)
    };
    THREE.AxisHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.ArrowHelper = function () {
        var a = new THREE.Geometry;
        a.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0));
        var b = new THREE.CylinderGeometry(0, .5, 1, 5, 1);
        b.applyMatrix((new THREE.Matrix4).makeTranslation(0, -.5, 0));
        return function (d, e, f, h, g, k) {
            THREE.Object3D.call(this);
            void 0 === h && (h = 16776960);
            void 0 === f && (f = 1);
            void 0 === g && (g = .2 * f);
            void 0 === k && (k = .2 * g);
            this.position.copy(e);
            this.line = new THREE.Line(a, new THREE.LineBasicMaterial({color: h}));
            this.line.matrixAutoUpdate = !1;
            this.add(this.line);
            this.cone = new THREE.Mesh(b, new THREE.MeshBasicMaterial({color: h}));
            this.cone.matrixAutoUpdate = !1;
            this.add(this.cone);
            this.setDirection(d);
            this.setLength(f, g, k)
        }
    }();
    THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype);
    THREE.ArrowHelper.prototype.setDirection = function () {
        var a = new THREE.Vector3, b;
        return function (d) {
            .99999 < d.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > d.y ? this.quaternion.set(1, 0, 0, 0) : (a.set(d.z, 0, -d.x).normalize(), b = Math.acos(d.y), this.quaternion.setFromAxisAngle(a, b))
        }
    }();
    THREE.ArrowHelper.prototype.setLength = function (a, b, d) {
        void 0 === b && (b = .2 * a);
        void 0 === d && (d = .2 * b);
        this.line.scale.set(1, a, 1);
        this.line.updateMatrix();
        this.cone.scale.set(d, b, d);
        this.cone.position.y = a;
        this.cone.updateMatrix()
    };
    THREE.ArrowHelper.prototype.setColor = function (a) {
        this.line.material.color.set(a);
        this.cone.material.color.set(a)
    };
    THREE.BoxHelper = function (a) {
        var b = new THREE.BufferGeometry;
        b.addAttribute("position", new THREE.BufferAttribute(new Float32Array(72), 3));
        THREE.Line.call(this, b, new THREE.LineBasicMaterial({color: 16776960}), THREE.LinePieces);
        void 0 !== a && this.update(a)
    };
    THREE.BoxHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.BoxHelper.prototype.update = function (a) {
        var b = a.geometry;
        null === b.boundingBox && b.computeBoundingBox();
        var d = b.boundingBox.min, b = b.boundingBox.max, e = this.geometry.attributes.position.array;
        e[0] = b.x;
        e[1] = b.y;
        e[2] = b.z;
        e[3] = d.x;
        e[4] = b.y;
        e[5] = b.z;
        e[6] = d.x;
        e[7] = b.y;
        e[8] = b.z;
        e[9] = d.x;
        e[10] = d.y;
        e[11] = b.z;
        e[12] = d.x;
        e[13] = d.y;
        e[14] = b.z;
        e[15] = b.x;
        e[16] = d.y;
        e[17] = b.z;
        e[18] = b.x;
        e[19] = d.y;
        e[20] = b.z;
        e[21] = b.x;
        e[22] = b.y;
        e[23] = b.z;
        e[24] = b.x;
        e[25] = b.y;
        e[26] = d.z;
        e[27] = d.x;
        e[28] = b.y;
        e[29] = d.z;
        e[30] = d.x;
        e[31] = b.y;
        e[32] = d.z;
        e[33] = d.x;
        e[34] = d.y;
        e[35] = d.z;
        e[36] = d.x;
        e[37] = d.y;
        e[38] = d.z;
        e[39] = b.x;
        e[40] = d.y;
        e[41] = d.z;
        e[42] = b.x;
        e[43] = d.y;
        e[44] = d.z;
        e[45] = b.x;
        e[46] = b.y;
        e[47] = d.z;
        e[48] = b.x;
        e[49] = b.y;
        e[50] = b.z;
        e[51] = b.x;
        e[52] = b.y;
        e[53] = d.z;
        e[54] = d.x;
        e[55] = b.y;
        e[56] = b.z;
        e[57] = d.x;
        e[58] = b.y;
        e[59] = d.z;
        e[60] = d.x;
        e[61] = d.y;
        e[62] = b.z;
        e[63] = d.x;
        e[64] = d.y;
        e[65] = d.z;
        e[66] = b.x;
        e[67] = d.y;
        e[68] = b.z;
        e[69] = b.x;
        e[70] = d.y;
        e[71] = d.z;
        this.geometry.attributes.position.needsUpdate = !0;
        this.geometry.computeBoundingSphere();
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1
    };
    THREE.BoundingBoxHelper = function (a, b) {
        var d = void 0 !== b ? b : 8947848;
        this.object = a;
        this.box = new THREE.Box3;
        THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({color: d, wireframe: !0}))
    };
    THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype);
    THREE.BoundingBoxHelper.prototype.update = function () {
        this.box.setFromObject(this.object);
        this.box.size(this.scale);
        this.box.center(this.position)
    };
    THREE.CameraHelper = function (a) {
        function b(a, b, e) {
            d(a, e);
            d(b, e)
        }

        function d(a, b) {
            e.vertices.push(new THREE.Vector3);
            e.colors.push(new THREE.Color(b));
            void 0 === h[a] && (h[a] = []);
            h[a].push(e.vertices.length - 1)
        }

        var e = new THREE.Geometry, f = new THREE.LineBasicMaterial({color: 16777215, vertexColors: THREE.FaceColors}),
            h = {};
        b("n1", "n2", 16755200);
        b("n2", "n4", 16755200);
        b("n4", "n3", 16755200);
        b("n3", "n1", 16755200);
        b("f1", "f2", 16755200);
        b("f2", "f4", 16755200);
        b("f4", "f3", 16755200);
        b("f3", "f1", 16755200);
        b("n1", "f1", 16755200);
        b("n2", "f2", 16755200);
        b("n3", "f3", 16755200);
        b("n4", "f4", 16755200);
        b("p", "n1", 16711680);
        b("p", "n2", 16711680);
        b("p", "n3", 16711680);
        b("p", "n4", 16711680);
        b("u1", "u2", 43775);
        b("u2", "u3", 43775);
        b("u3", "u1", 43775);
        b("c", "t", 16777215);
        b("p", "c", 3355443);
        b("cn1", "cn2", 3355443);
        b("cn3", "cn4", 3355443);
        b("cf1", "cf2", 3355443);
        b("cf3", "cf4", 3355443);
        THREE.Line.call(this, e, f, THREE.LinePieces);
        this.camera = a;
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1;
        this.pointMap = h;
        this.update()
    };
    THREE.CameraHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.CameraHelper.prototype.update = function () {
        var a, b, d = new THREE.Vector3, e = new THREE.Camera, f = function (h, g, f, l) {
            d.set(g, f, l).unproject(e);
            h = b[h];
            if (void 0 !== h) for (g = 0, f = h.length; g < f; g++) a.vertices[h[g]].copy(d)
        };
        return function () {
            a = this.geometry;
            b = this.pointMap;
            e.projectionMatrix.copy(this.camera.projectionMatrix);
            f("c", 0, 0, -1);
            f("t", 0, 0, 1);
            f("n1", -1, -1, -1);
            f("n2", 1, -1, -1);
            f("n3", -1, 1, -1);
            f("n4", 1, 1, -1);
            f("f1", -1, -1, 1);
            f("f2", 1, -1, 1);
            f("f3", -1, 1, 1);
            f("f4", 1, 1, 1);
            f("u1", .7, 1.1, -1);
            f("u2", -.7, 1.1,
                -1);
            f("u3", 0, 2, -1);
            f("cf1", -1, 0, 1);
            f("cf2", 1, 0, 1);
            f("cf3", 0, -1, 1);
            f("cf4", 0, 1, 1);
            f("cn1", -1, 0, -1);
            f("cn2", 1, 0, -1);
            f("cn3", 0, -1, -1);
            f("cn4", 0, 1, -1);
            a.verticesNeedUpdate = !0
        }
    }();
    THREE.DirectionalLightHelper = function (a, b) {
        THREE.Object3D.call(this);
        this.light = a;
        this.light.updateMatrixWorld();
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1;
        b = b || 1;
        var d = new THREE.Geometry;
        d.vertices.push(new THREE.Vector3(-b, b, 0), new THREE.Vector3(b, b, 0), new THREE.Vector3(b, -b, 0), new THREE.Vector3(-b, -b, 0), new THREE.Vector3(-b, b, 0));
        var e = new THREE.LineBasicMaterial({fog: !1});
        e.color.copy(this.light.color).multiplyScalar(this.light.intensity);
        this.lightPlane = new THREE.Line(d, e);
        this.add(this.lightPlane);
        d = new THREE.Geometry;
        d.vertices.push(new THREE.Vector3, new THREE.Vector3);
        e = new THREE.LineBasicMaterial({fog: !1});
        e.color.copy(this.light.color).multiplyScalar(this.light.intensity);
        this.targetLine = new THREE.Line(d, e);
        this.add(this.targetLine);
        this.update()
    };
    THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype);
    THREE.DirectionalLightHelper.prototype.dispose = function () {
        this.lightPlane.geometry.dispose();
        this.lightPlane.material.dispose();
        this.targetLine.geometry.dispose();
        this.targetLine.material.dispose()
    };
    THREE.DirectionalLightHelper.prototype.update = function () {
        var a = new THREE.Vector3, b = new THREE.Vector3, d = new THREE.Vector3;
        return function () {
            a.setFromMatrixPosition(this.light.matrixWorld);
            b.setFromMatrixPosition(this.light.target.matrixWorld);
            d.subVectors(b, a);
            this.lightPlane.lookAt(d);
            this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
            this.targetLine.geometry.vertices[1].copy(d);
            this.targetLine.geometry.verticesNeedUpdate = !0;
            this.targetLine.material.color.copy(this.lightPlane.material.color)
        }
    }();
    THREE.EdgesHelper = function (a, b) {
        var d = void 0 !== b ? b : 16777215, e = [0, 0], f = {}, h = function (a, b) {
            return a - b
        }, g = ["a", "b", "c"], k = new THREE.BufferGeometry, l = a.geometry.clone();
        l.mergeVertices();
        l.computeFaceNormals();
        for (var m = l.vertices, l = l.faces, n = 0, q = 0, p = l.length; q < p; q++) for (var r = l[q], v = 0; 3 > v; v++) {
            e[0] = r[g[v]];
            e[1] = r[g[(v + 1) % 3]];
            e.sort(h);
            var u = e.toString();
            void 0 === f[u] ? (f[u] = {vert1: e[0], vert2: e[1], face1: q, face2: void 0}, n++) : f[u].face2 = q
        }
        e = new Float32Array(6 * n);
        h = 0;
        for (u in f) if (g = f[u], void 0 === g.face2 ||
            .9999 > l[g.face1].normal.dot(l[g.face2].normal)) n = m[g.vert1], e[h++] = n.x, e[h++] = n.y, e[h++] = n.z, n = m[g.vert2], e[h++] = n.x, e[h++] = n.y, e[h++] = n.z;
        k.addAttribute("position", new THREE.BufferAttribute(e, 3));
        THREE.Line.call(this, k, new THREE.LineBasicMaterial({color: d}), THREE.LinePieces);
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1
    };
    THREE.EdgesHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.FaceNormalsHelper = function (a, b, d, e) {
        this.object = a;
        this.size = void 0 !== b ? b : 1;
        a = void 0 !== d ? d : 16776960;
        e = void 0 !== e ? e : 1;
        b = new THREE.Geometry;
        d = 0;
        for (var f = this.object.geometry.faces.length; d < f; d++) b.vertices.push(new THREE.Vector3, new THREE.Vector3);
        THREE.Line.call(this, b, new THREE.LineBasicMaterial({color: a, linewidth: e}), THREE.LinePieces);
        this.matrixAutoUpdate = !1;
        this.normalMatrix = new THREE.Matrix3;
        this.update()
    };
    THREE.FaceNormalsHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.FaceNormalsHelper.prototype.update = function () {
        var a = this.geometry.vertices, b = this.object, d = b.geometry.vertices, e = b.geometry.faces,
            f = b.matrixWorld;
        b.updateMatrixWorld(!0);
        this.normalMatrix.getNormalMatrix(f);
        for (var h = b = 0, g = e.length; b < g; b++, h += 2) {
            var k = e[b];
            a[h].copy(d[k.a]).add(d[k.b]).add(d[k.c]).divideScalar(3).applyMatrix4(f);
            a[h + 1].copy(k.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size).add(a[h])
        }
        this.geometry.verticesNeedUpdate = !0;
        return this
    };
    THREE.GridHelper = function (a, b) {
        var d = new THREE.Geometry, e = new THREE.LineBasicMaterial({vertexColors: THREE.VertexColors});
        this.color1 = new THREE.Color(4473924);
        this.color2 = new THREE.Color(8947848);
        for (var f = -a; f <= a; f += b) {
            d.vertices.push(new THREE.Vector3(-a, 0, f), new THREE.Vector3(a, 0, f), new THREE.Vector3(f, 0, -a), new THREE.Vector3(f, 0, a));
            var h = 0 === f ? this.color1 : this.color2;
            d.colors.push(h, h, h, h)
        }
        THREE.Line.call(this, d, e, THREE.LinePieces)
    };
    THREE.GridHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.GridHelper.prototype.setColors = function (a, b) {
        this.color1.set(a);
        this.color2.set(b);
        this.geometry.colorsNeedUpdate = !0
    };
    THREE.HemisphereLightHelper = function (a, b, d, e) {
        THREE.Object3D.call(this);
        this.light = a;
        this.light.updateMatrixWorld();
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1;
        this.colors = [new THREE.Color, new THREE.Color];
        a = new THREE.SphereGeometry(b, 4, 2);
        a.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI / 2));
        for (b = 0; 8 > b; b++) a.faces[b].color = this.colors[4 > b ? 0 : 1];
        b = new THREE.MeshBasicMaterial({vertexColors: THREE.FaceColors, wireframe: !0});
        this.lightSphere = new THREE.Mesh(a, b);
        this.add(this.lightSphere);
        this.update()
    };
    THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype);
    THREE.HemisphereLightHelper.prototype.dispose = function () {
        this.lightSphere.geometry.dispose();
        this.lightSphere.material.dispose()
    };
    THREE.HemisphereLightHelper.prototype.update = function () {
        var a = new THREE.Vector3;
        return function () {
            this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);
            this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);
            this.lightSphere.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate());
            this.lightSphere.geometry.colorsNeedUpdate = !0
        }
    }();
    THREE.PointLightHelper = function (a, b) {
        this.light = a;
        this.light.updateMatrixWorld();
        var d = new THREE.SphereGeometry(b, 4, 2), e = new THREE.MeshBasicMaterial({wireframe: !0, fog: !1});
        e.color.copy(this.light.color).multiplyScalar(this.light.intensity);
        THREE.Mesh.call(this, d, e);
        this.matrix = this.light.matrixWorld;
        this.matrixAutoUpdate = !1
    };
    THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype);
    THREE.PointLightHelper.prototype.dispose = function () {
        this.geometry.dispose();
        this.material.dispose()
    };
    THREE.PointLightHelper.prototype.update = function () {
        this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
    };
    THREE.SkeletonHelper = function (a) {
        this.bones = this.getBoneList(a);
        for (var b = new THREE.Geometry, d = 0; d < this.bones.length; d++) this.bones[d].parent instanceof THREE.Bone && (b.vertices.push(new THREE.Vector3), b.vertices.push(new THREE.Vector3), b.colors.push(new THREE.Color(0, 0, 1)), b.colors.push(new THREE.Color(0, 1, 0)));
        d = new THREE.LineBasicMaterial({
            vertexColors: THREE.VertexColors,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        });
        THREE.Line.call(this, b, d, THREE.LinePieces);
        this.root = a;
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1;
        this.update()
    };
    THREE.SkeletonHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.SkeletonHelper.prototype.getBoneList = function (a) {
        var b = [];
        a instanceof THREE.Bone && b.push(a);
        for (var d = 0; d < a.children.length; d++) b.push.apply(b, this.getBoneList(a.children[d]));
        return b
    };
    THREE.SkeletonHelper.prototype.update = function () {
        for (var a = this.geometry, b = (new THREE.Matrix4).getInverse(this.root.matrixWorld), d = new THREE.Matrix4, e = 0, f = 0; f < this.bones.length; f++) {
            var h = this.bones[f];
            h.parent instanceof THREE.Bone && (d.multiplyMatrices(b, h.matrixWorld), a.vertices[e].setFromMatrixPosition(d), d.multiplyMatrices(b, h.parent.matrixWorld), a.vertices[e + 1].setFromMatrixPosition(d), e += 2)
        }
        a.verticesNeedUpdate = !0;
        a.computeBoundingSphere()
    };
    THREE.SpotLightHelper = function (a) {
        THREE.Object3D.call(this);
        this.light = a;
        this.light.updateMatrixWorld();
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1;
        a = new THREE.CylinderGeometry(0, 1, 1, 8, 1, !0);
        a.applyMatrix((new THREE.Matrix4).makeTranslation(0, -.5, 0));
        a.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI / 2));
        var b = new THREE.MeshBasicMaterial({wireframe: !0, fog: !1});
        this.cone = new THREE.Mesh(a, b);
        this.add(this.cone);
        this.update()
    };
    THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype);
    THREE.SpotLightHelper.prototype.dispose = function () {
        this.cone.geometry.dispose();
        this.cone.material.dispose()
    };
    THREE.SpotLightHelper.prototype.update = function () {
        var a = new THREE.Vector3, b = new THREE.Vector3;
        return function () {
            var d = this.light.distance ? this.light.distance : 1E4, e = d * Math.tan(this.light.angle);
            this.cone.scale.set(e, e, d);
            a.setFromMatrixPosition(this.light.matrixWorld);
            b.setFromMatrixPosition(this.light.target.matrixWorld);
            this.cone.lookAt(b.sub(a));
            this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
        }
    }();
    THREE.VertexNormalsHelper = function (a, b, d, e) {
        this.object = a;
        this.size = void 0 !== b ? b : 1;
        b = void 0 !== d ? d : 16711680;
        e = void 0 !== e ? e : 1;
        d = new THREE.Geometry;
        a = a.geometry.faces;
        for (var f = 0, h = a.length; f < h; f++) for (var g = 0, k = a[f].vertexNormals.length; g < k; g++) d.vertices.push(new THREE.Vector3, new THREE.Vector3);
        THREE.Line.call(this, d, new THREE.LineBasicMaterial({color: b, linewidth: e}), THREE.LinePieces);
        this.matrixAutoUpdate = !1;
        this.normalMatrix = new THREE.Matrix3;
        this.update()
    };
    THREE.VertexNormalsHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.VertexNormalsHelper.prototype.update = function (a) {
        var b = new THREE.Vector3;
        return function (a) {
            a = ["a", "b", "c", "d"];
            this.object.updateMatrixWorld(!0);
            this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
            for (var e = this.geometry.vertices, f = this.object.geometry.vertices, h = this.object.geometry.faces, g = this.object.matrixWorld, k = 0, l = 0, m = h.length; l < m; l++) for (var n = h[l], q = 0, p = n.vertexNormals.length; q < p; q++) {
                var r = n.vertexNormals[q];
                e[k].copy(f[n[a[q]]]).applyMatrix4(g);
                b.copy(r).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
                b.add(e[k]);
                k += 1;
                e[k].copy(b);
                k += 1
            }
            this.geometry.verticesNeedUpdate = !0;
            return this
        }
    }();
    THREE.VertexTangentsHelper = function (a, b, d, e) {
        this.object = a;
        this.size = void 0 !== b ? b : 1;
        b = void 0 !== d ? d : 255;
        e = void 0 !== e ? e : 1;
        d = new THREE.Geometry;
        a = a.geometry.faces;
        for (var f = 0, h = a.length; f < h; f++) for (var g = 0, k = a[f].vertexTangents.length; g < k; g++) d.vertices.push(new THREE.Vector3), d.vertices.push(new THREE.Vector3);
        THREE.Line.call(this, d, new THREE.LineBasicMaterial({color: b, linewidth: e}), THREE.LinePieces);
        this.matrixAutoUpdate = !1;
        this.update()
    };
    THREE.VertexTangentsHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.VertexTangentsHelper.prototype.update = function (a) {
        var b = new THREE.Vector3;
        return function (a) {
            a = ["a", "b", "c", "d"];
            this.object.updateMatrixWorld(!0);
            for (var e = this.geometry.vertices, f = this.object.geometry.vertices, h = this.object.geometry.faces, g = this.object.matrixWorld, k = 0, l = 0, m = h.length; l < m; l++) for (var n = h[l], q = 0, p = n.vertexTangents.length; q < p; q++) {
                var r = n.vertexTangents[q];
                e[k].copy(f[n[a[q]]]).applyMatrix4(g);
                b.copy(r).transformDirection(g).multiplyScalar(this.size);
                b.add(e[k]);
                k += 1;
                e[k].copy(b);
                k += 1
            }
            this.geometry.verticesNeedUpdate = !0;
            return this
        }
    }();
    THREE.WireframeHelper = function (a, b) {
        var d = void 0 !== b ? b : 16777215, e = [0, 0], f = {}, h = function (a, b) {
            return a - b
        }, g = ["a", "b", "c"], k = new THREE.BufferGeometry;
        if (a.geometry instanceof THREE.Geometry) {
            for (var l = a.geometry.vertices, m = a.geometry.faces, n = 0, q = new Uint32Array(6 * m.length), p = 0, r = m.length; p < r; p++) for (var v = m[p], u = 0; 3 > u; u++) {
                e[0] = v[g[u]];
                e[1] = v[g[(u + 1) % 3]];
                e.sort(h);
                var x = e.toString();
                void 0 === f[x] && (q[2 * n] = e[0], q[2 * n + 1] = e[1], f[x] = !0, n++)
            }
            e = new Float32Array(6 * n);
            p = 0;
            for (r = n; p < r; p++) for (u = 0; 2 > u; u++) n =
                l[q[2 * p + u]], g = 6 * p + 3 * u, e[g + 0] = n.x, e[g + 1] = n.y, e[g + 2] = n.z;
            k.addAttribute("position", new THREE.BufferAttribute(e, 3))
        } else if (a.geometry instanceof THREE.BufferGeometry) {
            if (void 0 !== a.geometry.attributes.index) {
                l = a.geometry.attributes.position.array;
                r = a.geometry.attributes.index.array;
                m = a.geometry.drawcalls;
                n = 0;
                0 === m.length && (m = [{count: r.length, index: 0, start: 0}]);
                for (var q = new Uint32Array(2 * r.length), v = 0, w = m.length; v < w; ++v) for (var u = m[v].start, x = m[v].count, g = m[v].index, p = u, z = u + x; p < z; p += 3) for (u = 0; 3 > u; u++) e[0] =
                    g + r[p + u], e[1] = g + r[p + (u + 1) % 3], e.sort(h), x = e.toString(), void 0 === f[x] && (q[2 * n] = e[0], q[2 * n + 1] = e[1], f[x] = !0, n++);
                e = new Float32Array(6 * n);
                p = 0;
                for (r = n; p < r; p++) for (u = 0; 2 > u; u++) g = 6 * p + 3 * u, n = 3 * q[2 * p + u], e[g + 0] = l[n], e[g + 1] = l[n + 1], e[g + 2] = l[n + 2]
            } else for (l = a.geometry.attributes.position.array, n = l.length / 3, q = n / 3, e = new Float32Array(6 * n), p = 0, r = q; p < r; p++) for (u = 0; 3 > u; u++) g = 18 * p + 6 * u, q = 9 * p + 3 * u, e[g + 0] = l[q], e[g + 1] = l[q + 1], e[g + 2] = l[q + 2], n = 9 * p + (u + 1) % 3 * 3, e[g + 3] = l[n], e[g + 4] = l[n + 1], e[g + 5] = l[n + 2];
            k.addAttribute("position", new THREE.BufferAttribute(e,
                3))
        }
        THREE.Line.call(this, k, new THREE.LineBasicMaterial({color: d}), THREE.LinePieces);
        this.matrix = a.matrixWorld;
        this.matrixAutoUpdate = !1
    };
    THREE.WireframeHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.ImmediateRenderObject = function () {
        THREE.Object3D.call(this);
        this.render = function (a) {
        }
    };
    THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype);
    THREE.MorphBlendMesh = function (a, b) {
        THREE.Mesh.call(this, a, b);
        this.animationsMap = {};
        this.animationsList = [];
        var d = this.geometry.morphTargets.length;
        this.createAnimation("__default", 0, d - 1, d / 1);
        this.setAnimationWeight("__default", 1)
    };
    THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype);
    THREE.MorphBlendMesh.prototype.createAnimation = function (a, b, d, e) {
        b = {
            startFrame: b,
            endFrame: d,
            length: d - b + 1,
            fps: e,
            duration: (d - b) / e,
            lastFrame: 0,
            currentFrame: 0,
            active: !1,
            time: 0,
            direction: 1,
            weight: 1,
            directionBackwards: !1,
            mirroredLoop: !1
        };
        this.animationsMap[a] = b;
        this.animationsList.push(b)
    };
    THREE.MorphBlendMesh.prototype.autoCreateAnimations = function (a) {
        for (var b = /([a-z]+)_?(\d+)/, d, e = {}, f = this.geometry, h = 0, g = f.morphTargets.length; h < g; h++) {
            var k = f.morphTargets[h].name.match(b);
            if (k && 1 < k.length) {
                var l = k[1];
                e[l] || (e[l] = {start: Infinity, end: -Infinity});
                k = e[l];
                h < k.start && (k.start = h);
                h > k.end && (k.end = h);
                d || (d = l)
            }
        }
        for (l in e) k = e[l], this.createAnimation(l, k.start, k.end, a);
        this.firstAnimation = d
    };
    THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function (a) {
        if (a = this.animationsMap[a]) a.direction = 1, a.directionBackwards = !1
    };
    THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function (a) {
        if (a = this.animationsMap[a]) a.direction = -1, a.directionBackwards = !0
    };
    THREE.MorphBlendMesh.prototype.setAnimationFPS = function (a, b) {
        var d = this.animationsMap[a];
        d && (d.fps = b, d.duration = (d.end - d.start) / d.fps)
    };
    THREE.MorphBlendMesh.prototype.setAnimationDuration = function (a, b) {
        var d = this.animationsMap[a];
        d && (d.duration = b, d.fps = (d.end - d.start) / d.duration)
    };
    THREE.MorphBlendMesh.prototype.setAnimationWeight = function (a, b) {
        var d = this.animationsMap[a];
        d && (d.weight = b)
    };
    THREE.MorphBlendMesh.prototype.setAnimationTime = function (a, b) {
        var d = this.animationsMap[a];
        d && (d.time = b)
    };
    THREE.MorphBlendMesh.prototype.getAnimationTime = function (a) {
        var b = 0;
        if (a = this.animationsMap[a]) b = a.time;
        return b
    };
    THREE.MorphBlendMesh.prototype.getAnimationDuration = function (a) {
        var b = -1;
        if (a = this.animationsMap[a]) b = a.duration;
        return b
    };
    THREE.MorphBlendMesh.prototype.playAnimation = function (a) {
        var b = this.animationsMap[a];
        b ? (b.time = 0, b.active = !0) : console.warn("animation[" + a + "] undefined")
    };
    THREE.MorphBlendMesh.prototype.stopAnimation = function (a) {
        if (a = this.animationsMap[a]) a.active = !1
    };
    THREE.MorphBlendMesh.prototype.update = function (a) {
        for (var b = 0, d = this.animationsList.length; b < d; b++) {
            var e = this.animationsList[b];
            if (e.active) {
                var f = e.duration / e.length;
                e.time += e.direction * a;
                if (e.mirroredLoop) {
                    if (e.time > e.duration || 0 > e.time) e.direction *= -1, e.time > e.duration && (e.time = e.duration, e.directionBackwards = !0), 0 > e.time && (e.time = 0, e.directionBackwards = !1)
                } else e.time %= e.duration, 0 > e.time && (e.time += e.duration);
                var h = e.startFrame + THREE.Math.clamp(Math.floor(e.time / f), 0, e.length - 1), g = e.weight;
                h !== e.currentFrame && (this.morphTargetInfluences[e.lastFrame] = 0, this.morphTargetInfluences[e.currentFrame] = 1 * g, this.morphTargetInfluences[h] = 0, e.lastFrame = e.currentFrame, e.currentFrame = h);
                f = e.time % f / f;
                e.directionBackwards && (f = 1 - f);
                this.morphTargetInfluences[e.currentFrame] = f * g;
                this.morphTargetInfluences[e.lastFrame] = (1 - f) * g
            }
        }
    };
    (function (a) {
        !1 === "performance" in a && (a.performance = {});
        Date.now = Date.now || function () {
            return (new Date).getTime()
        };
        if (!1 === "now" in a.performance) {
            var b = a.performance.timing && a.performance.timing.navigationStart ? performance.timing.navigationStart : Date.now();
            a.performance.now = function () {
                return Date.now() - b
            }
        }
    })(this);
    var TWEEN = TWEEN || function () {
        var a = [];
        return {
            REVISION: "14", getAll: function () {
                return a
            }, removeAll: function () {
                a = []
            }, add: function (b) {
                a.push(b)
            }, remove: function (b) {
                b = a.indexOf(b);
                -1 !== b && a.splice(b, 1)
            }, update: function (b) {
                if (0 === a.length) return !1;
                var d = 0;
                for (b = void 0 !== b ? b : window.performance.now(); d < a.length;) a[d].update(b) ? d++ : a.splice(d, 1);
                return !0
            }
        }
    }();
    TWEEN.Tween = function (a) {
        var b = {}, d = {}, e = {}, f = 1E3, h = 0, g = !1, k = !1, l = 0, m = null, n = TWEEN.Easing.Linear.None,
            q = TWEEN.Interpolation.Linear, p = [], r = null, v = !1, u = null, x = null, w = null, z;
        for (z in a) b[z] = parseFloat(a[z], 10);
        this.to = function (a, b) {
            void 0 !== b && (f = b);
            d = a;
            return this
        };
        this.start = function (g) {
            TWEEN.add(this);
            k = !0;
            v = !1;
            m = void 0 !== g ? g : window.performance.now();
            m += l;
            for (var h in d) {
                if (d[h] instanceof Array) {
                    if (0 === d[h].length) continue;
                    d[h] = [a[h]].concat(d[h])
                }
                b[h] = a[h];
                !1 === b[h] instanceof Array && (b[h] *= 1);
                e[h] =
                    b[h] || 0
            }
            return this
        };
        this.stop = function () {
            if (!k) return this;
            TWEEN.remove(this);
            k = !1;
            null !== w && w.call(a);
            this.stopChainedTweens();
            return this
        };
        this.stopChainedTweens = function () {
            for (var a = 0, b = p.length; a < b; a++) p[a].stop()
        };
        this.delay = function (a) {
            l = a;
            return this
        };
        this.repeat = function (a) {
            h = a;
            return this
        };
        this.yoyo = function (a) {
            g = a;
            return this
        };
        this.easing = function (a) {
            n = a;
            return this
        };
        this.interpolation = function (a) {
            q = a;
            return this
        };
        this.chain = function () {
            p = arguments;
            return this
        };
        this.onStart = function (a) {
            r =
                a;
            return this
        };
        this.onUpdate = function (a) {
            u = a;
            return this
        };
        this.onComplete = function (a) {
            x = a;
            return this
        };
        this.onStop = function (a) {
            w = a;
            return this
        };
        this.update = function (k) {
            var w;
            if (k < m) return !0;
            !1 === v && (null !== r && r.call(a), v = !0);
            var z = (k - m) / f, z = 1 < z ? 1 : z, E = n(z);
            for (w in d) {
                var I = b[w] || 0, A = d[w];
                A instanceof Array ? a[w] = q(A, E) : ("string" === typeof A && (A = I + parseFloat(A, 10)), "number" === typeof A && (a[w] = I + (A - I) * E))
            }
            null !== u && u.call(a, E);
            if (1 == z) if (0 < h) {
                isFinite(h) && h--;
                for (w in e) "string" === typeof d[w] && (e[w] +=
                    parseFloat(d[w], 10)), g && (z = e[w], e[w] = d[w], d[w] = z), b[w] = e[w];
                m = k + l
            } else {
                null !== x && x.call(a);
                w = 0;
                for (z = p.length; w < z; w++) p[w].start(k);
                return !1
            }
            return !0
        }
    };
    TWEEN.Easing = {
        Linear: {
            None: function (a) {
                return a
            }
        }, Quadratic: {
            In: function (a) {
                return a * a
            }, Out: function (a) {
                return a * (2 - a)
            }, InOut: function (a) {
                return 1 > (a *= 2) ? .5 * a * a : -.5 * (--a * (a - 2) - 1)
            }
        }, Cubic: {
            In: function (a) {
                return a * a * a
            }, Out: function (a) {
                return --a * a * a + 1
            }, InOut: function (a) {
                return 1 > (a *= 2) ? .5 * a * a * a : .5 * ((a -= 2) * a * a + 2)
            }
        }, Quartic: {
            In: function (a) {
                return a * a * a * a
            }, Out: function (a) {
                return 1 - --a * a * a * a
            }, InOut: function (a) {
                return 1 > (a *= 2) ? .5 * a * a * a * a : -.5 * ((a -= 2) * a * a * a - 2)
            }
        }, Quintic: {
            In: function (a) {
                return a * a * a * a * a
            }, Out: function (a) {
                return --a *
                    a * a * a * a + 1
            }, InOut: function (a) {
                return 1 > (a *= 2) ? .5 * a * a * a * a * a : .5 * ((a -= 2) * a * a * a * a + 2)
            }
        }, Sinusoidal: {
            In: function (a) {
                return 1 - Math.cos(a * Math.PI / 2)
            }, Out: function (a) {
                return Math.sin(a * Math.PI / 2)
            }, InOut: function (a) {
                return .5 * (1 - Math.cos(Math.PI * a))
            }
        }, Exponential: {
            In: function (a) {
                return 0 === a ? 0 : Math.pow(1024, a - 1)
            }, Out: function (a) {
                return 1 === a ? 1 : 1 - Math.pow(2, -10 * a)
            }, InOut: function (a) {
                return 0 === a ? 0 : 1 === a ? 1 : 1 > (a *= 2) ? .5 * Math.pow(1024, a - 1) : .5 * (-Math.pow(2, -10 * (a - 1)) + 2)
            }
        }, Circular: {
            In: function (a) {
                return 1 - Math.sqrt(1 -
                    a * a)
            }, Out: function (a) {
                return Math.sqrt(1 - --a * a)
            }, InOut: function (a) {
                return 1 > (a *= 2) ? -.5 * (Math.sqrt(1 - a * a) - 1) : .5 * (Math.sqrt(1 - (a -= 2) * a) + 1)
            }
        }, Elastic: {
            In: function (a) {
                var b, d = .1;
                if (0 === a) return 0;
                if (1 === a) return 1;
                !d || 1 > d ? (d = 1, b = .1) : b = .4 * Math.asin(1 / d) / (2 * Math.PI);
                return -(d * Math.pow(2, 10 * --a) * Math.sin(2 * (a - b) * Math.PI / .4))
            }, Out: function (a) {
                var b, d = .1;
                if (0 === a) return 0;
                if (1 === a) return 1;
                !d || 1 > d ? (d = 1, b = .1) : b = .4 * Math.asin(1 / d) / (2 * Math.PI);
                return d * Math.pow(2, -10 * a) * Math.sin(2 * (a - b) * Math.PI / .4) + 1
            }, InOut: function (a) {
                var b,
                    d = .1;
                if (0 === a) return 0;
                if (1 === a) return 1;
                !d || 1 > d ? (d = 1, b = .1) : b = .4 * Math.asin(1 / d) / (2 * Math.PI);
                return 1 > (a *= 2) ? -.5 * d * Math.pow(2, 10 * --a) * Math.sin(2 * (a - b) * Math.PI / .4) : d * Math.pow(2, -10 * --a) * Math.sin(2 * (a - b) * Math.PI / .4) * .5 + 1
            }
        }, Back: {
            In: function (a) {
                return a * a * (2.70158 * a - 1.70158)
            }, Out: function (a) {
                return --a * a * (2.70158 * a + 1.70158) + 1
            }, InOut: function (a) {
                return 1 > (a *= 2) ? .5 * a * a * (3.5949095 * a - 2.5949095) : .5 * ((a -= 2) * a * (3.5949095 * a + 2.5949095) + 2)
            }
        }, Bounce: {
            In: function (a) {
                return 1 - TWEEN.Easing.Bounce.Out(1 - a)
            }, Out: function (a) {
                return a <
                1 / 2.75 ? 7.5625 * a * a : a < 2 / 2.75 ? 7.5625 * (a -= 1.5 / 2.75) * a + .75 : a < 2.5 / 2.75 ? 7.5625 * (a -= 2.25 / 2.75) * a + .9375 : 7.5625 * (a -= 2.625 / 2.75) * a + .984375
            }, InOut: function (a) {
                return .5 > a ? .5 * TWEEN.Easing.Bounce.In(2 * a) : .5 * TWEEN.Easing.Bounce.Out(2 * a - 1) + .5
            }
        }
    };
    TWEEN.Interpolation = {
        Linear: function (a, b) {
            var d = a.length - 1, e = d * b, f = Math.floor(e), h = TWEEN.Interpolation.Utils.Linear;
            return 0 > b ? h(a[0], a[1], e) : 1 < b ? h(a[d], a[d - 1], d - e) : h(a[f], a[f + 1 > d ? d : f + 1], e - f)
        }, Bezier: function (a, b) {
            var d = 0, e = a.length - 1, f = Math.pow, h = TWEEN.Interpolation.Utils.Bernstein, g;
            for (g = 0; g <= e; g++) d += f(1 - b, e - g) * f(b, g) * a[g] * h(e, g);
            return d
        }, CatmullRom: function (a, b) {
            var d = a.length - 1, e = d * b, f = Math.floor(e), h = TWEEN.Interpolation.Utils.CatmullRom;
            return a[0] === a[d] ? (0 > b && (f = Math.floor(e = d * (1 + b))), h(a[(f -
                1 + d) % d], a[f], a[(f + 1) % d], a[(f + 2) % d], e - f)) : 0 > b ? a[0] - (h(a[0], a[0], a[1], a[1], -e) - a[0]) : 1 < b ? a[d] - (h(a[d], a[d], a[d - 1], a[d - 1], e - d) - a[d]) : h(a[f ? f - 1 : 0], a[f], a[d < f + 1 ? d : f + 1], a[d < f + 2 ? d : f + 2], e - f)
        }, Utils: {
            Linear: function (a, b, d) {
                return (b - a) * d + a
            }, Bernstein: function (a, b) {
                var d = TWEEN.Interpolation.Utils.Factorial;
                return d(a) / d(b) / d(a - b)
            }, Factorial: function () {
                var a = [1];
                return function (b) {
                    var d = 1, e;
                    if (a[b]) return a[b];
                    for (e = b; 1 < e; e--) d *= e;
                    return a[b] = d
                }
            }(), CatmullRom: function (a, b, d, e, f) {
                a = .5 * (d - a);
                e = .5 * (e - b);
                var h = f *
                    f;
                return (2 * b - 2 * d + a + e) * f * h + (-3 * b + 3 * d - 2 * a - e) * h + a * f + b
            }
        }
    };
    (function (a) {
        "function" === typeof define && define.amd ? define([], function () {
            return TWEEN
        }) : "object" === typeof exports ? module.exports = TWEEN : a.TWEEN = TWEEN
    })(this);
    var Proj4js = {
        defaultDatum: "WGS84",
        transform: function (a, b, d) {
            if (!a.readyToUse) return this.reportError("Proj4js initialization for:" + a.srsCode + " not yet complete"), d;
            if (!b.readyToUse) return this.reportError("Proj4js initialization for:" + b.srsCode + " not yet complete"), d;
            if ("900913" == a.srsProjNumber && "WGS84" != b.datumCode && !b.datum_params || "900913" == b.srsProjNumber && "WGS84" != a.datumCode && !a.datum_params) {
                var e = Proj4js.WGS84;
                this.transform(a, e, d);
                a = e
            }
            "enu" != a.axis && this.adjust_axis(a, !1, d);
            "longlat" == a.projName ?
                (d.x *= Proj4js.common.D2R, d.y *= Proj4js.common.D2R) : (a.to_meter && (d.x *= a.to_meter, d.y *= a.to_meter), a.inverse(d));
            a.from_greenwich && (d.x += a.from_greenwich);
            d = this.datum_transform(a.datum, b.datum, d);
            b.from_greenwich && (d.x -= b.from_greenwich);
            "longlat" == b.projName ? (d.x *= Proj4js.common.R2D, d.y *= Proj4js.common.R2D) : (b.forward(d), b.to_meter && (d.x /= b.to_meter, d.y /= b.to_meter));
            "enu" != b.axis && this.adjust_axis(b, !0, d);
            return d
        },
        datum_transform: function (a, b, d) {
            if (a.compare_datums(b) || a.datum_type == Proj4js.common.PJD_NODATUM ||
                b.datum_type == Proj4js.common.PJD_NODATUM) return d;
            a.datum_type == Proj4js.common.PJD_GRIDSHIFT && alert("ERROR: Grid shift transformations are not implemented yet.");
            b.datum_type == Proj4js.common.PJD_GRIDSHIFT && alert("ERROR: Grid shift transformations are not implemented yet.");
            if (a.es != b.es || a.a != b.a || a.datum_type == Proj4js.common.PJD_3PARAM || a.datum_type == Proj4js.common.PJD_7PARAM || b.datum_type == Proj4js.common.PJD_3PARAM || b.datum_type == Proj4js.common.PJD_7PARAM) a.geodetic_to_geocentric(d), a.datum_type !=
            Proj4js.common.PJD_3PARAM && a.datum_type != Proj4js.common.PJD_7PARAM || a.geocentric_to_wgs84(d), b.datum_type != Proj4js.common.PJD_3PARAM && b.datum_type != Proj4js.common.PJD_7PARAM || b.geocentric_from_wgs84(d), b.geocentric_to_geodetic(d);
            b.datum_type == Proj4js.common.PJD_GRIDSHIFT && alert("ERROR: Grid shift transformations are not implemented yet.");
            return d
        },
        adjust_axis: function (a, b, d) {
            for (var e = d.x, f = d.y, h = d.z || 0, g, k, l = 0; 3 > l; l++) if (!b || 2 != l || void 0 !== d.z) switch (0 == l ? (g = e, k = "x") : 1 == l ? (g = f, k = "y") : (g = h, k = "z"),
                a.axis[l]) {
                case "e":
                    d[k] = g;
                    break;
                case "w":
                    d[k] = -g;
                    break;
                case "n":
                    d[k] = g;
                    break;
                case "s":
                    d[k] = -g;
                    break;
                case "u":
                    void 0 !== d[k] && (d.z = g);
                    break;
                case "d":
                    void 0 !== d[k] && (d.z = -g);
                    break;
                default:
                    return alert("ERROR: unknow axis (" + a.axis[l] + ") - check definition of " + a.projName), null
            }
            return d
        },
        reportError: function (a) {
        },
        extend: function (a, b) {
            a = a || {};
            if (b) for (var d in b) {
                var e = b[d];
                void 0 !== e && (a[d] = e)
            }
            return a
        },
        Class: function () {
            for (var a = function () {
                this.initialize.apply(this, arguments)
            }, b = {}, d, e = 0; e < arguments.length; ++e) d =
                "function" == typeof arguments[e] ? arguments[e].prototype : arguments[e], Proj4js.extend(b, d);
            a.prototype = b;
            return a
        },
        bind: function (a, b) {
            var d = Array.prototype.slice.apply(arguments, [2]);
            return function () {
                var e = d.concat(Array.prototype.slice.apply(arguments, [0]));
                return a.apply(b, e)
            }
        },
        scriptName: "proj4js.js",
        defsLookupService: "http://spatialreference.org/ref",
        libPath: null,
        getScriptLocation: function () {
            if (this.libPath) return this.libPath;
            for (var a = this.scriptName, b = a.length, d = document.getElementsByTagName("script"),
                     e = 0; e < d.length; e++) {
                var f = d[e].getAttribute("src");
                if (f) {
                    var h = f.lastIndexOf(a);
                    if (-1 < h && h + b == f.length) {
                        this.libPath = f.slice(0, -b);
                        break
                    }
                }
            }
            return this.libPath || ""
        },
        loadScript: function (a, b, d, e) {
            var f = document.createElement("script");
            f.defer = !1;
            f.type = "text/javascript";
            f.id = a;
            f.src = a;
            f.onload = b;
            f.onerror = d;
            f.loadCheck = e;
            /MSIE/.test(navigator.userAgent) && (f.onreadystatechange = this.checkReadyState);
            document.getElementsByTagName("head")[0].appendChild(f)
        },
        checkReadyState: function () {
            if ("loaded" == this.readyState) if (this.loadCheck()) this.onload();
            else this.onerror()
        }
    };
    Proj4js.Proj = Proj4js.Class({
        readyToUse: !1,
        title: null,
        projName: null,
        units: null,
        datum: null,
        x0: 0,
        y0: 0,
        localCS: !1,
        queue: null,
        initialize: function (a, b) {
            this.srsCodeInput = a;
            this.queue = [];
            b && this.queue.push(b);
            if (0 <= a.indexOf("GEOGCS") || 0 <= a.indexOf("GEOCCS") || 0 <= a.indexOf("PROJCS") || 0 <= a.indexOf("LOCAL_CS")) this.parseWKT(a), this.deriveConstants(), this.loadProjCode(this.projName); else {
                if (0 == a.indexOf("urn:")) {
                    var d = a.split(":");
                    "ogc" != d[1] && "x-ogc" != d[1] || "def" != d[2] || "crs" != d[3] || (a = d[4] + ":" + d[d.length -
                    1])
                } else 0 == a.indexOf("http://") && (d = a.split("#"), d[0].match(/epsg.org/) ? a = "EPSG:" + d[1] : d[0].match(/RIG.xml/) && (a = "IGNF:" + d[1]));
                this.srsCode = a.toUpperCase();
                0 == this.srsCode.indexOf("EPSG") ? (this.srsCode = this.srsCode, this.srsAuth = "epsg", this.srsProjNumber = this.srsCode.substring(5)) : 0 == this.srsCode.indexOf("IGNF") ? (this.srsCode = this.srsCode, this.srsAuth = "IGNF", this.srsProjNumber = this.srsCode.substring(5)) : 0 == this.srsCode.indexOf("CRS") ? (this.srsCode = this.srsCode, this.srsAuth = "CRS", this.srsProjNumber =
                    this.srsCode.substring(4)) : (this.srsAuth = "", this.srsProjNumber = this.srsCode);
                this.loadProjDefinition()
            }
        },
        loadProjDefinition: function () {
            if (Proj4js.defs[this.srsCode]) this.defsLoaded(); else {
                var a = Proj4js.getScriptLocation() + "defs/" + this.srsAuth.toUpperCase() + this.srsProjNumber + ".js";
                Proj4js.loadScript(a, Proj4js.bind(this.defsLoaded, this), Proj4js.bind(this.loadFromService, this), Proj4js.bind(this.checkDefsLoaded, this))
            }
        },
        loadFromService: function () {
            Proj4js.loadScript(Proj4js.defsLookupService + "/" + this.srsAuth +
                "/" + this.srsProjNumber + "/proj4js/", Proj4js.bind(this.defsLoaded, this), Proj4js.bind(this.defsFailed, this), Proj4js.bind(this.checkDefsLoaded, this))
        },
        defsLoaded: function () {
            this.parseDefs();
            this.loadProjCode(this.projName)
        },
        checkDefsLoaded: function () {
            return Proj4js.defs[this.srsCode] ? !0 : !1
        },
        defsFailed: function () {
            Proj4js.reportError("failed to load projection definition for: " + this.srsCode);
            Proj4js.defs[this.srsCode] = Proj4js.defs.WGS84;
            this.defsLoaded()
        },
        loadProjCode: function (a) {
            if (Proj4js.Proj[a]) this.initTransforms();
            else {
                var b = Proj4js.getScriptLocation() + "projCode/" + a + ".js";
                Proj4js.loadScript(b, Proj4js.bind(this.loadProjCodeSuccess, this, a), Proj4js.bind(this.loadProjCodeFailure, this, a), Proj4js.bind(this.checkCodeLoaded, this, a))
            }
        },
        loadProjCodeSuccess: function (a) {
            Proj4js.Proj[a].dependsOn ? this.loadProjCode(Proj4js.Proj[a].dependsOn) : this.initTransforms()
        },
        loadProjCodeFailure: function (a) {
            Proj4js.reportError("failed to find projection file for: " + a)
        },
        checkCodeLoaded: function (a) {
            return Proj4js.Proj[a] ? !0 : !1
        },
        initTransforms: function () {
            Proj4js.extend(this,
                Proj4js.Proj[this.projName]);
            this.init();
            this.readyToUse = !0;
            if (this.queue) for (var a; a = this.queue.shift();) a.call(this, this)
        },
        wktRE: /^(\w+)\[(.*)\]$/,
        parseWKT: function (a) {
            if (a = a.match(this.wktRE)) {
                var b = a[1], d = a[2].split(","), e;
                e = "TOWGS84" == b.toUpperCase() ? b : d.shift();
                e = e.replace(/^\"/, "");
                e = e.replace(/\"$/, "");
                a = [];
                for (var f = 0, h = "", g = 0; g < d.length; ++g) {
                    for (var k = d[g], l = 0; l < k.length; ++l) "[" == k.charAt(l) && ++f, "]" == k.charAt(l) && --f;
                    h += k;
                    0 === f ? (a.push(h), h = "") : h += ","
                }
                switch (b) {
                    case "LOCAL_CS":
                        this.projName =
                            "identity";
                        this.localCS = !0;
                        this.srsCode = e;
                        break;
                    case "GEOGCS":
                        this.projName = "longlat";
                        this.geocsCode = e;
                        this.srsCode || (this.srsCode = e);
                        break;
                    case "PROJCS":
                        this.srsCode = e;
                        break;
                    case "PROJECTION":
                        this.projName = Proj4js.wktProjections[e];
                        break;
                    case "DATUM":
                        this.datumName = e;
                        break;
                    case "LOCAL_DATUM":
                        this.datumCode = "none";
                        break;
                    case "SPHEROID":
                        this.ellps = e;
                        this.a = parseFloat(a.shift());
                        this.rf = parseFloat(a.shift());
                        break;
                    case "PRIMEM":
                        this.from_greenwich = parseFloat(a.shift());
                        break;
                    case "UNIT":
                        this.units =
                            e;
                        this.unitsPerMeter = parseFloat(a.shift());
                        break;
                    case "PARAMETER":
                        b = e.toLowerCase();
                        d = parseFloat(a.shift());
                        switch (b) {
                            case "false_easting":
                                this.x0 = d;
                                break;
                            case "false_northing":
                                this.y0 = d;
                                break;
                            case "scale_factor":
                                this.k0 = d;
                                break;
                            case "central_meridian":
                                this.long0 = d * Proj4js.common.D2R;
                                break;
                            case "latitude_of_origin":
                                this.lat0 = d * Proj4js.common.D2R
                        }
                        break;
                    case "TOWGS84":
                        this.datum_params = a;
                        break;
                    case "AXIS":
                        b = e.toLowerCase();
                        d = a.shift();
                        switch (d) {
                            case "EAST":
                                d = "e";
                                break;
                            case "WEST":
                                d = "w";
                                break;
                            case "NORTH":
                                d =
                                    "n";
                                break;
                            case "SOUTH":
                                d = "s";
                                break;
                            case "UP":
                                d = "u";
                                break;
                            case "DOWN":
                                d = "d";
                                break;
                            default:
                                d = " "
                        }
                        this.axis || (this.axis = "enu");
                        switch (b) {
                            case "X":
                                this.axis = d + this.axis.substr(1, 2);
                                break;
                            case "Y":
                                this.axis = this.axis.substr(0, 1) + d + this.axis.substr(2, 1);
                                break;
                            case "Z":
                                this.axis = this.axis.substr(0, 2) + d
                        }
                }
                for (g = 0; g < a.length; ++g) this.parseWKT(a[g])
            }
        },
        parseDefs: function () {
            this.defData = Proj4js.defs[this.srsCode];
            var a, b;
            if (this.defData) {
                for (var d = this.defData.split("+"), e = 0; e < d.length; e++) switch (b = d[e].split("="),
                    a = b[0].toLowerCase(), b = b[1], a.replace(/\s/gi, "")) {
                    case "title":
                        this.title = b;
                        break;
                    case "proj":
                        this.projName = b.replace(/\s/gi, "");
                        break;
                    case "units":
                        this.units = b.replace(/\s/gi, "");
                        break;
                    case "datum":
                        this.datumCode = b.replace(/\s/gi, "");
                        break;
                    case "nadgrids":
                        this.nagrids = b.replace(/\s/gi, "");
                        break;
                    case "ellps":
                        this.ellps = b.replace(/\s/gi, "");
                        break;
                    case "a":
                        this.a = parseFloat(b);
                        break;
                    case "b":
                        this.b = parseFloat(b);
                        break;
                    case "rf":
                        this.rf = parseFloat(b);
                        break;
                    case "lat_0":
                        this.lat0 = b * Proj4js.common.D2R;
                        break;
                    case "lat_1":
                        this.lat1 = b * Proj4js.common.D2R;
                        break;
                    case "lat_2":
                        this.lat2 = b * Proj4js.common.D2R;
                        break;
                    case "lat_ts":
                        this.lat_ts = b * Proj4js.common.D2R;
                        break;
                    case "lon_0":
                        this.long0 = b * Proj4js.common.D2R;
                        break;
                    case "alpha":
                        this.alpha = parseFloat(b) * Proj4js.common.D2R;
                        break;
                    case "lonc":
                        this.longc = b * Proj4js.common.D2R;
                        break;
                    case "x_0":
                        this.x0 = parseFloat(b);
                        break;
                    case "y_0":
                        this.y0 = parseFloat(b);
                        break;
                    case "k_0":
                        this.k0 = parseFloat(b);
                        break;
                    case "k":
                        this.k0 = parseFloat(b);
                        break;
                    case "r_a":
                        this.R_A = !0;
                        break;
                    case "zone":
                        this.zone = parseInt(b);
                        break;
                    case "south":
                        this.utmSouth = !0;
                        break;
                    case "towgs84":
                        this.datum_params = b.split(",");
                        break;
                    case "to_meter":
                        this.to_meter = parseFloat(b);
                        break;
                    case "from_greenwich":
                        this.from_greenwich = b * Proj4js.common.D2R;
                        break;
                    case "pm":
                        b = b.replace(/\s/gi, "");
                        this.from_greenwich = Proj4js.PrimeMeridian[b] ? Proj4js.PrimeMeridian[b] : parseFloat(b);
                        this.from_greenwich *= Proj4js.common.D2R;
                        break;
                    case "axis":
                        b = b.replace(/\s/gi, ""), 3 == b.length && -1 != "ewnsud".indexOf(b.substr(0, 1)) && -1 != "ewnsud".indexOf(b.substr(1,
                            1)) && -1 != "ewnsud".indexOf(b.substr(2, 1)) && (this.axis = b)
                }
                this.deriveConstants()
            }
        },
        deriveConstants: function () {
            "@null" == this.nagrids && (this.datumCode = "none");
            if (this.datumCode && "none" != this.datumCode) {
                var a = Proj4js.Datum[this.datumCode];
                a && (this.datum_params = a.towgs84 ? a.towgs84.split(",") : null, this.ellps = a.ellipse, this.datumName = a.datumName ? a.datumName : this.datumCode)
            }
            this.a || Proj4js.extend(this, Proj4js.Ellipsoid[this.ellps] ? Proj4js.Ellipsoid[this.ellps] : Proj4js.Ellipsoid.WGS84);
            this.rf && !this.b && (this.b =
                (1 - 1 / this.rf) * this.a);
            Math.abs(this.a - this.b) < Proj4js.common.EPSLN && (this.sphere = !0, this.b = this.a);
            this.a2 = this.a * this.a;
            this.b2 = this.b * this.b;
            this.es = (this.a2 - this.b2) / this.a2;
            this.e = Math.sqrt(this.es);
            this.R_A && (this.a *= 1 - this.es * (Proj4js.common.SIXTH + this.es * (Proj4js.common.RA4 + this.es * Proj4js.common.RA6)), this.a2 = this.a * this.a, this.b2 = this.b * this.b, this.es = 0);
            this.ep2 = (this.a2 - this.b2) / this.b2;
            this.k0 || (this.k0 = 1);
            this.axis || (this.axis = "enu");
            this.datum = new Proj4js.datum(this)
        }
    });
    Proj4js.Proj.longlat = {
        init: function () {
        }, forward: function (a) {
            return a
        }, inverse: function (a) {
            return a
        }
    };
    Proj4js.Proj.identity = Proj4js.Proj.longlat;
    Proj4js.defs = {
        WGS84: "+title=long/lat:WGS84 +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees",
        "EPSG:4326": "+title=long/lat:WGS84 +proj=longlat +a=6378137.0 +b=6356752.31424518 +ellps=WGS84 +datum=WGS84 +units=degrees",
        "EPSG:4269": "+title=long/lat:NAD83 +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees",
        "EPSG:3785": "+title= Google Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"
    };
    Proj4js.defs.GOOGLE = Proj4js.defs["EPSG:3785"];
    Proj4js.defs["EPSG:900913"] = Proj4js.defs["EPSG:3785"];
    Proj4js.defs["EPSG:102113"] = Proj4js.defs["EPSG:3785"];
    Proj4js.common = {
        PI: 3.141592653589793,
        HALF_PI: 1.5707963267948966,
        TWO_PI: 6.283185307179586,
        FORTPI: .7853981633974483,
        R2D: 57.29577951308232,
        D2R: .017453292519943295,
        SEC_TO_RAD: 4.84813681109536E-6,
        EPSLN: 1E-10,
        MAX_ITER: 20,
        COS_67P5: .3826834323650898,
        AD_C: 1.0026,
        PJD_UNKNOWN: 0,
        PJD_3PARAM: 1,
        PJD_7PARAM: 2,
        PJD_GRIDSHIFT: 3,
        PJD_WGS84: 4,
        PJD_NODATUM: 5,
        SRS_WGS84_SEMIMAJOR: 6378137,
        SIXTH: .16666666666666666,
        RA4: .04722222222222222,
        RA6: .022156084656084655,
        RV4: .06944444444444445,
        RV6: .04243827160493827,
        msfnz: function (a, b,
                         d) {
            a *= b;
            return d / Math.sqrt(1 - a * a)
        },
        tsfnz: function (a, b, d) {
            d *= a;
            d = Math.pow((1 - d) / (1 + d), .5 * a);
            return Math.tan(.5 * (this.HALF_PI - b)) / d
        },
        phi2z: function (a, b) {
            for (var d = .5 * a, e, f = this.HALF_PI - 2 * Math.atan(b), h = 0; 15 >= h; h++) if (e = a * Math.sin(f), e = this.HALF_PI - 2 * Math.atan(b * Math.pow((1 - e) / (1 + e), d)) - f, f += e, 1E-10 >= Math.abs(e)) return f;
            alert("phi2z has NoConvergence");
            return -9999
        },
        qsfnz: function (a, b) {
            var d;
            return 1E-7 < a ? (d = a * b, (1 - a * a) * (b / (1 - d * d) - .5 / a * Math.log((1 - d) / (1 + d)))) : 2 * b
        },
        asinz: function (a) {
            1 < Math.abs(a) && (a =
                1 < a ? 1 : -1);
            return Math.asin(a)
        },
        e0fn: function (a) {
            return 1 - .25 * a * (1 + a / 16 * (3 + 1.25 * a))
        },
        e1fn: function (a) {
            return .375 * a * (1 + .25 * a * (1 + .46875 * a))
        },
        e2fn: function (a) {
            return .05859375 * a * a * (1 + .75 * a)
        },
        e3fn: function (a) {
            return 35 / 3072 * a * a * a
        },
        mlfn: function (a, b, d, e, f) {
            return a * f - b * Math.sin(2 * f) + d * Math.sin(4 * f) - e * Math.sin(6 * f)
        },
        srat: function (a, b) {
            return Math.pow((1 - a) / (1 + a), b)
        },
        sign: function (a) {
            return 0 > a ? -1 : 1
        },
        adjust_lon: function (a) {
            return a = Math.abs(a) < this.PI ? a : a - this.sign(a) * this.TWO_PI
        },
        adjust_lat: function (a) {
            return a =
                Math.abs(a) < this.HALF_PI ? a : a - this.sign(a) * this.PI
        },
        latiso: function (a, b, d) {
            if (Math.abs(b) > this.HALF_PI) return +Number.NaN;
            if (b == this.HALF_PI) return Number.POSITIVE_INFINITY;
            if (b == -1 * this.HALF_PI) return -1 * Number.POSITIVE_INFINITY;
            d *= a;
            return Math.log(Math.tan((this.HALF_PI + b) / 2)) + a * Math.log((1 - d) / (1 + d)) / 2
        },
        fL: function (a, b) {
            return 2 * Math.atan(a * Math.exp(b)) - this.HALF_PI
        },
        invlatiso: function (a, b) {
            var d = this.fL(1, b), e = 0, f = 0;
            do e = d, f = a * Math.sin(e), d = this.fL(Math.exp(a * Math.log((1 + f) / (1 - f)) / 2), b); while (1E-12 <
            Math.abs(d - e));
            return d
        },
        sinh: function (a) {
            a = Math.exp(a);
            return (a - 1 / a) / 2
        },
        cosh: function (a) {
            a = Math.exp(a);
            return (a + 1 / a) / 2
        },
        tanh: function (a) {
            a = Math.exp(a);
            return (a - 1 / a) / (a + 1 / a)
        },
        asinh: function (a) {
            return (0 <= a ? 1 : -1) * Math.log(Math.abs(a) + Math.sqrt(a * a + 1))
        },
        acosh: function (a) {
            return 2 * Math.log(Math.sqrt((a + 1) / 2) + Math.sqrt((a - 1) / 2))
        },
        atanh: function (a) {
            return Math.log((a - 1) / (a + 1)) / 2
        },
        gN: function (a, b, d) {
            b *= d;
            return a / Math.sqrt(1 - b * b)
        }
    };
    Proj4js.datum = Proj4js.Class({
        initialize: function (a) {
            this.datum_type = Proj4js.common.PJD_WGS84;
            a.datumCode && "none" == a.datumCode && (this.datum_type = Proj4js.common.PJD_NODATUM);
            if (a && a.datum_params) {
                for (var b = 0; b < a.datum_params.length; b++) a.datum_params[b] = parseFloat(a.datum_params[b]);
                if (0 != a.datum_params[0] || 0 != a.datum_params[1] || 0 != a.datum_params[2]) this.datum_type = Proj4js.common.PJD_3PARAM;
                3 < a.datum_params.length && (0 != a.datum_params[3] || 0 != a.datum_params[4] || 0 != a.datum_params[5] || 0 != a.datum_params[6]) &&
                (this.datum_type = Proj4js.common.PJD_7PARAM, a.datum_params[3] *= Proj4js.common.SEC_TO_RAD, a.datum_params[4] *= Proj4js.common.SEC_TO_RAD, a.datum_params[5] *= Proj4js.common.SEC_TO_RAD, a.datum_params[6] = a.datum_params[6] / 1E6 + 1)
            }
            a && (this.a = a.a, this.b = a.b, this.es = a.es, this.ep2 = a.ep2, this.datum_params = a.datum_params)
        }, compare_datums: function (a) {
            return this.datum_type != a.datum_type || this.a != a.a || 5E-11 < Math.abs(this.es - a.es) ? !1 : this.datum_type == Proj4js.common.PJD_3PARAM ? this.datum_params[0] == a.datum_params[0] &&
                this.datum_params[1] == a.datum_params[1] && this.datum_params[2] == a.datum_params[2] : this.datum_type == Proj4js.common.PJD_7PARAM ? this.datum_params[0] == a.datum_params[0] && this.datum_params[1] == a.datum_params[1] && this.datum_params[2] == a.datum_params[2] && this.datum_params[3] == a.datum_params[3] && this.datum_params[4] == a.datum_params[4] && this.datum_params[5] == a.datum_params[5] && this.datum_params[6] == a.datum_params[6] : this.datum_type == Proj4js.common.PJD_GRIDSHIFT ? (alert("ERROR: Grid shift transformations are not implemented yet."),
                !1) : !0
        }, geodetic_to_geocentric: function (a) {
            var b = a.x, d = a.y, e = a.z ? a.z : 0, f, h, g;
            if (d < -Proj4js.common.HALF_PI && d > -1.001 * Proj4js.common.HALF_PI) d = -Proj4js.common.HALF_PI; else if (d > Proj4js.common.HALF_PI && d < 1.001 * Proj4js.common.HALF_PI) d = Proj4js.common.HALF_PI; else if (d < -Proj4js.common.HALF_PI || d > Proj4js.common.HALF_PI) return Proj4js.reportError("geocent:lat out of range:" + d), null;
            b > Proj4js.common.PI && (b -= 2 * Proj4js.common.PI);
            h = Math.sin(d);
            g = Math.cos(d);
            f = this.a / Math.sqrt(1 - this.es * h * h);
            d = (f + e) * g * Math.cos(b);
            b = (f + e) * g * Math.sin(b);
            e = (f * (1 - this.es) + e) * h;
            a.x = d;
            a.y = b;
            a.z = e;
            return 0
        }, geocentric_to_geodetic: function (a) {
            var b, d, e, f, h, g, k, l, m, n, q = a.x;
            e = a.y;
            var p = a.z ? a.z : 0;
            b = Math.sqrt(q * q + e * e);
            d = Math.sqrt(q * q + e * e + p * p);
            if (1E-12 > b / this.a) {
                if (q = 0, 1E-12 > d / this.a) return
            } else q = Math.atan2(e, q);
            e = p / d;
            f = b / d;
            h = 1 / Math.sqrt(1 - this.es * (2 - this.es) * f * f);
            k = f * (1 - this.es) * h;
            l = e * h;
            n = 0;
            do n++, g = this.a / Math.sqrt(1 - this.es * l * l), d = b * k + p * l - g * (1 - this.es * l * l), g = this.es * g / (g + d), h = 1 / Math.sqrt(1 - g * (2 - g) * f * f), g = f * (1 - g) * h, h *= e, m = h * k - g * l, k =
                g, l = h; while (1E-24 < m * m && 30 > n);
            b = Math.atan(h / Math.abs(g));
            a.x = q;
            a.y = b;
            a.z = d;
            return a
        }, geocentric_to_geodetic_noniter: function (a) {
            var b = a.x, d = a.y, e = a.z ? a.z : 0, f, h, g, k, l, b = parseFloat(b), d = parseFloat(d),
                e = parseFloat(e);
            l = !1;
            if (0 != b) f = Math.atan2(d, b); else if (0 < d) f = Proj4js.common.HALF_PI; else if (0 > d) f = -Proj4js.common.HALF_PI; else if (l = !0, f = 0, 0 < e) h = Proj4js.common.HALF_PI; else if (0 > e) h = -Proj4js.common.HALF_PI; else return;
            g = b * b + d * d;
            b = Math.sqrt(g);
            d = e * Proj4js.common.AD_C;
            g = Math.sqrt(d * d + g);
            d /= g;
            g = b / g;
            d = e + this.b *
                this.ep2 * d * d * d;
            k = b - this.a * this.es * g * g * g;
            g = Math.sqrt(d * d + k * k);
            d /= g;
            g = k / g;
            k = this.a / Math.sqrt(1 - this.es * d * d);
            e = g >= Proj4js.common.COS_67P5 ? b / g - k : g <= -Proj4js.common.COS_67P5 ? b / -g - k : e / d + k * (this.es - 1);
            0 == l && (h = Math.atan(d / g));
            a.x = f;
            a.y = h;
            a.z = e;
            return a
        }, geocentric_to_wgs84: function (a) {
            if (this.datum_type == Proj4js.common.PJD_3PARAM) a.x += this.datum_params[0], a.y += this.datum_params[1], a.z += this.datum_params[2]; else if (this.datum_type == Proj4js.common.PJD_7PARAM) {
                var b = this.datum_params[3], d = this.datum_params[4],
                    e = this.datum_params[5], f = this.datum_params[6],
                    h = f * (e * a.x + a.y - b * a.z) + this.datum_params[1],
                    b = f * (-d * a.x + b * a.y + a.z) + this.datum_params[2];
                a.x = f * (a.x - e * a.y + d * a.z) + this.datum_params[0];
                a.y = h;
                a.z = b
            }
        }, geocentric_from_wgs84: function (a) {
            if (this.datum_type == Proj4js.common.PJD_3PARAM) a.x -= this.datum_params[0], a.y -= this.datum_params[1], a.z -= this.datum_params[2]; else if (this.datum_type == Proj4js.common.PJD_7PARAM) {
                var b = this.datum_params[3], d = this.datum_params[4], e = this.datum_params[5],
                    f = this.datum_params[6], h = (a.x -
                    this.datum_params[0]) / f, g = (a.y - this.datum_params[1]) / f,
                    f = (a.z - this.datum_params[2]) / f;
                a.x = h + e * g - d * f;
                a.y = -e * h + g + b * f;
                a.z = d * h - b * g + f
            }
        }
    });
    Proj4js.Point = Proj4js.Class({
        initialize: function (a, b, d) {
            "object" == typeof a ? (this.x = a[0], this.y = a[1], this.z = a[2] || 0) : "string" == typeof a && "undefined" == typeof b ? (a = a.split(","), this.x = parseFloat(a[0]), this.y = parseFloat(a[1]), this.z = parseFloat(a[2]) || 0) : (this.x = a, this.y = b, this.z = d || 0)
        }, clone: function () {
            return new Proj4js.Point(this.x, this.y, this.z)
        }, toString: function () {
            return "x=" + this.x + ",y=" + this.y
        }, toShortString: function () {
            return this.x + ", " + this.y
        }
    });
    Proj4js.PrimeMeridian = {
        greenwich: 0,
        lisbon: -9.131906111111,
        paris: 2.337229166667,
        bogota: -74.080916666667,
        madrid: -3.687938888889,
        rome: 12.452333333333,
        bern: 7.439583333333,
        jakarta: 106.807719444444,
        ferro: -17.666666666667,
        brussels: 4.367975,
        stockholm: 18.058277777778,
        athens: 23.7163375,
        oslo: 10.722916666667
    };
    Proj4js.Ellipsoid = {
        MERIT: {a: 6378137, rf: 298.257, ellipseName: "MERIT 1983"},
        SGS85: {a: 6378136, rf: 298.257, ellipseName: "Soviet Geodetic System 85"},
        GRS80: {a: 6378137, rf: 298.257222101, ellipseName: "GRS 1980(IUGG, 1980)"},
        IAU76: {a: 6378140, rf: 298.257, ellipseName: "IAU 1976"},
        airy: {a: 6377563.396, b: 6356256.91, ellipseName: "Airy 1830"},
        "APL4.": {a: 6378137, rf: 298.25, ellipseName: "Appl. Physics. 1965"},
        NWL9D: {a: 6378145, rf: 298.25, ellipseName: "Naval Weapons Lab., 1965"},
        mod_airy: {a: 6377340.189, b: 6356034.446, ellipseName: "Modified Airy"},
        andrae: {a: 6377104.43, rf: 300, ellipseName: "Andrae 1876 (Den., Iclnd.)"},
        aust_SA: {a: 6378160, rf: 298.25, ellipseName: "Australian Natl & S. Amer. 1969"},
        GRS67: {a: 6378160, rf: 298.247167427, ellipseName: "GRS 67(IUGG 1967)"},
        bessel: {a: 6377397.155, rf: 299.1528128, ellipseName: "Bessel 1841"},
        bess_nam: {a: 6377483.865, rf: 299.1528128, ellipseName: "Bessel 1841 (Namibia)"},
        clrk66: {a: 6378206.4, b: 6356583.8, ellipseName: "Clarke 1866"},
        clrk80: {a: 6378249.145, rf: 293.4663, ellipseName: "Clarke 1880 mod."},
        CPM: {
            a: 6375738.7, rf: 334.29,
            ellipseName: "Comm. des Poids et Mesures 1799"
        },
        delmbr: {a: 6376428, rf: 311.5, ellipseName: "Delambre 1810 (Belgium)"},
        engelis: {a: 6378136.05, rf: 298.2566, ellipseName: "Engelis 1985"},
        evrst30: {a: 6377276.345, rf: 300.8017, ellipseName: "Everest 1830"},
        evrst48: {a: 6377304.063, rf: 300.8017, ellipseName: "Everest 1948"},
        evrst56: {a: 6377301.243, rf: 300.8017, ellipseName: "Everest 1956"},
        evrst69: {a: 6377295.664, rf: 300.8017, ellipseName: "Everest 1969"},
        evrstSS: {a: 6377298.556, rf: 300.8017, ellipseName: "Everest (Sabah & Sarawak)"},
        fschr60: {a: 6378166, rf: 298.3, ellipseName: "Fischer (Mercury Datum) 1960"},
        fschr60m: {a: 6378155, rf: 298.3, ellipseName: "Fischer 1960"},
        fschr68: {a: 6378150, rf: 298.3, ellipseName: "Fischer 1968"},
        helmert: {a: 6378200, rf: 298.3, ellipseName: "Helmert 1906"},
        hough: {a: 6378270, rf: 297, ellipseName: "Hough"},
        intl: {a: 6378388, rf: 297, ellipseName: "International 1909 (Hayford)"},
        kaula: {a: 6378163, rf: 298.24, ellipseName: "Kaula 1961"},
        lerch: {a: 6378139, rf: 298.257, ellipseName: "Lerch 1979"},
        mprts: {a: 6397300, rf: 191, ellipseName: "Maupertius 1738"},
        new_intl: {a: 6378157.5, b: 6356772.2, ellipseName: "New International 1967"},
        plessis: {a: 6376523, rf: 6355863, ellipseName: "Plessis 1817 (France)"},
        krass: {a: 6378245, rf: 298.3, ellipseName: "Krassovsky, 1942"},
        SEasia: {a: 6378155, b: 6356773.3205, ellipseName: "Southeast Asia"},
        walbeck: {a: 6376896, b: 6355834.8467, ellipseName: "Walbeck"},
        WGS60: {a: 6378165, rf: 298.3, ellipseName: "WGS 60"},
        WGS66: {a: 6378145, rf: 298.25, ellipseName: "WGS 66"},
        WGS72: {a: 6378135, rf: 298.26, ellipseName: "WGS 72"},
        WGS84: {a: 6378137, rf: 298.257223563, ellipseName: "WGS 84"},
        sphere: {a: 6370997, b: 6370997, ellipseName: "Normal Sphere (r=6370997)"}
    };
    Proj4js.Datum = {
        WGS84: {towgs84: "0,0,0", ellipse: "WGS84", datumName: "WGS84"},
        GGRS87: {towgs84: "-199.87,74.79,246.62", ellipse: "GRS80", datumName: "Greek_Geodetic_Reference_System_1987"},
        NAD83: {towgs84: "0,0,0", ellipse: "GRS80", datumName: "North_American_Datum_1983"},
        NAD27: {
            nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
            ellipse: "clrk66",
            datumName: "North_American_Datum_1927"
        },
        potsdam: {towgs84: "606.0,23.0,413.0", ellipse: "bessel", datumName: "Potsdam Rauenberg 1950 DHDN"},
        carthage: {
            towgs84: "-263.0,6.0,431.0",
            ellipse: "clark80", datumName: "Carthage 1934 Tunisia"
        },
        hermannskogel: {towgs84: "653.0,-212.0,449.0", ellipse: "bessel", datumName: "Hermannskogel"},
        ire65: {
            towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
            ellipse: "mod_airy",
            datumName: "Ireland 1965"
        },
        nzgd49: {
            towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
            ellipse: "intl",
            datumName: "New Zealand Geodetic Datum 1949"
        },
        OSGB36: {
            towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
            ellipse: "airy",
            datumName: "Airy 1830"
        }
    };
    Proj4js.WGS84 = new Proj4js.Proj("WGS84");
    Proj4js.Datum.OSB36 = Proj4js.Datum.OSGB36;
    Proj4js.wktProjections = {
        "Lambert Tangential Conformal Conic Projection": "lcc",
        Mercator: "merc",
        "Popular Visualisation Pseudo Mercator": "merc",
        Transverse_Mercator: "tmerc",
        "Transverse Mercator": "tmerc",
        "Lambert Azimuthal Equal Area": "laea",
        "Universal Transverse Mercator System": "utm"
    };
    Proj4js.defs.UTM31 = "+proj=utm +zone=31 +ellps=WGS84 +units=m +nadgrids=@null +no_defs";
    Proj4js.defs.UTM40 = "+proj=utm +zone=40 +ellps=WGS84 +units=m +nadgrids=@null +no_defs";
    Proj4js.Proj.utm = {
        dependsOn: "tmerc", init: function () {
            this.zone ? (this.lat0 = 0, this.long0 = (6 * Math.abs(this.zone) - 183) * Proj4js.common.D2R, this.x0 = 5E5, this.y0 = this.utmSouth ? 1E7 : 0, this.k0 = .9996, Proj4js.Proj.tmerc.init.apply(this), this.forward = Proj4js.Proj.tmerc.forward, this.inverse = Proj4js.Proj.tmerc.inverse) : Proj4js.reportError("utm:init: zone must be specified for UTM")
        }
    };
    Proj4js.Proj.lcc = {
        init: function () {
            this.lat2 || (this.lat2 = this.lat0);
            this.k0 || (this.k0 = 1);
            if (Math.abs(this.lat1 + this.lat2) < Proj4js.common.EPSLN) Proj4js.reportError("lcc:init: Equal Latitudes"); else {
                var a = this.b / this.a;
                this.e = Math.sqrt(1 - a * a);
                var a = Math.sin(this.lat1), b = Math.cos(this.lat1), b = Proj4js.common.msfnz(this.e, a, b),
                    d = Proj4js.common.tsfnz(this.e, this.lat1, a), e = Math.sin(this.lat2), f = Math.cos(this.lat2),
                    f = Proj4js.common.msfnz(this.e, e, f), e = Proj4js.common.tsfnz(this.e, this.lat2, e),
                    h = Proj4js.common.tsfnz(this.e,
                        this.lat0, Math.sin(this.lat0));
                Math.abs(this.lat1 - this.lat2) > Proj4js.common.EPSLN ? this.ns = Math.log(b / f) / Math.log(d / e) : this.ns = a;
                this.f0 = b / (this.ns * Math.pow(d, this.ns));
                this.rh = this.a * this.f0 * Math.pow(h, this.ns);
                this.title || (this.title = "Lambert Conformal Conic")
            }
        }, forward: function (a) {
            var b = a.x, d = a.y;
            if (!(90 >= d && -90 <= d && 180 >= b && -180 <= b)) return Proj4js.reportError("lcc:forward: llInputOutOfRange: " + b + " : " + d), null;
            var e = Math.abs(Math.abs(d) - Proj4js.common.HALF_PI);
            if (e > Proj4js.common.EPSLN) d = Proj4js.common.tsfnz(this.e,
                d, Math.sin(d)), d = this.a * this.f0 * Math.pow(d, this.ns); else {
                e = d * this.ns;
                if (0 >= e) return Proj4js.reportError("lcc:forward: No Projection"), null;
                d = 0
            }
            b = this.ns * Proj4js.common.adjust_lon(b - this.long0);
            a.x = this.k0 * d * Math.sin(b) + this.x0;
            a.y = this.k0 * (this.rh - d * Math.cos(b)) + this.y0;
            return a
        }, inverse: function (a) {
            var b, d, e, f = (a.x - this.x0) / this.k0, h = this.rh - (a.y - this.y0) / this.k0;
            0 < this.ns ? (b = Math.sqrt(f * f + h * h), d = 1) : (b = -Math.sqrt(f * f + h * h), d = -1);
            e = 0;
            0 != b && (e = Math.atan2(d * f, d * h));
            if (0 != b || 0 < this.ns) {
                if (d = 1 / this.ns,
                        b = Math.pow(b / (this.a * this.f0), d), b = Proj4js.common.phi2z(this.e, b), -9999 == b) return null
            } else b = -Proj4js.common.HALF_PI;
            e = Proj4js.common.adjust_lon(e / this.ns + this.long0);
            a.x = e;
            a.y = b;
            return a
        }
    };
    Proj4js.Proj.tmerc = {
        init: function () {
            this.e0 = Proj4js.common.e0fn(this.es);
            this.e1 = Proj4js.common.e1fn(this.es);
            this.e2 = Proj4js.common.e2fn(this.es);
            this.e3 = Proj4js.common.e3fn(this.es);
            this.ml0 = this.a * Proj4js.common.mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0)
        }, forward: function (a) {
            var b = a.y, d = Proj4js.common.adjust_lon(a.x - this.long0), e, f;
            e = Math.sin(b);
            var h = Math.cos(b);
            if (this.sphere) {
                var g = h * Math.sin(d);
                if (1E-10 > Math.abs(Math.abs(g) - 1)) return Proj4js.reportError("tmerc:forward: Point projects into infinity"),
                    93;
                f = .5 * this.a * this.k0 * Math.log((1 + g) / (1 - g));
                e = Math.acos(h * Math.cos(d) / Math.sqrt(1 - g * g));
                0 > b && (e = -e);
                b = this.a * this.k0 * (e - this.lat0)
            } else {
                f = h * d;
                var d = Math.pow(f, 2), h = this.ep2 * Math.pow(h, 2), g = Math.tan(b), k = Math.pow(g, 2);
                e = 1 - this.es * Math.pow(e, 2);
                e = this.a / Math.sqrt(e);
                b = this.a * Proj4js.common.mlfn(this.e0, this.e1, this.e2, this.e3, b);
                f = this.k0 * e * f * (1 + d / 6 * (1 - k + h + d / 20 * (5 - 18 * k + Math.pow(k, 2) + 72 * h - 58 * this.ep2))) + this.x0;
                b = this.k0 * (b - this.ml0 + e * g * d * (.5 + d / 24 * (5 - k + 9 * h + 4 * Math.pow(h, 2) + d / 30 * (61 - 58 * k + Math.pow(k, 2) +
                    600 * h - 330 * this.ep2)))) + this.y0
            }
            a.x = f;
            a.y = b;
            return a
        }, inverse: function (a) {
            var b, d, e, f;
            if (this.sphere) {
                d = Math.exp(a.x / (this.a * this.k0));
                var h = .5 * (d - 1 / d);
                e = this.lat0 + a.y / (this.a * this.k0);
                f = Math.cos(e);
                b = Math.sqrt((1 - f * f) / (1 + h * h));
                d = Proj4js.common.asinz(b);
                0 > e && (d = -d);
                b = 0 == h && 0 == f ? this.long0 : Proj4js.common.adjust_lon(Math.atan2(h, f) + this.long0)
            } else {
                var h = a.x - this.x0, g = a.y - this.y0;
                d = b = (this.ml0 + g / this.k0) / this.a;
                for (f = 0; ; f++) {
                    e = (b + this.e1 * Math.sin(2 * d) - this.e2 * Math.sin(4 * d) + this.e3 * Math.sin(6 * d)) / this.e0 -
                        d;
                    d += e;
                    if (Math.abs(e) <= Proj4js.common.EPSLN) break;
                    if (6 <= f) return Proj4js.reportError("tmerc:inverse: Latitude failed to converge"), 95
                }
                if (Math.abs(d) < Proj4js.common.HALF_PI) {
                    b = Math.sin(d);
                    e = Math.cos(d);
                    var k = Math.tan(d);
                    f = this.ep2 * Math.pow(e, 2);
                    var g = Math.pow(f, 2), l = Math.pow(k, 2), m = Math.pow(l, 2);
                    b = 1 - this.es * Math.pow(b, 2);
                    var n = this.a / Math.sqrt(b);
                    b = n * (1 - this.es) / b;
                    var h = h / (n * this.k0), q = Math.pow(h, 2);
                    d -= n * k * q / b * (.5 - q / 24 * (5 + 3 * l + 10 * f - 4 * g - 9 * this.ep2 - q / 30 * (61 + 90 * l + 298 * f + 45 * m - 252 * this.ep2 - 3 * g)));
                    b = Proj4js.common.adjust_lon(this.long0 +
                        h * (1 - q / 6 * (1 + 2 * l + f - q / 20 * (5 - 2 * f + 28 * l - 3 * g + 8 * this.ep2 + 24 * m))) / e)
                } else d = Proj4js.common.HALF_PI * Proj4js.common.sign(g), b = this.long0
            }
            a.x = b;
            a.y = d;
            return a
        }
    };
    Proj4js.Proj.somerc = {
        init: function () {
            var a = this.lat0;
            this.lambda0 = this.long0;
            var b = Math.sin(a), d = this.a, e = 1 / this.rf, e = 2 * e - Math.pow(e, 2), f = this.e = Math.sqrt(e);
            this.R = this.k0 * d * Math.sqrt(1 - e) / (1 - e * Math.pow(b, 2));
            this.alpha = Math.sqrt(1 + e / (1 - e) * Math.pow(Math.cos(a), 4));
            this.b0 = Math.asin(b / this.alpha);
            this.K = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)) - this.alpha * Math.log(Math.tan(Math.PI / 4 + a / 2)) + this.alpha * f / 2 * Math.log((1 + f * b) / (1 - f * b))
        }, forward: function (a) {
            var b = Math.log(Math.tan(Math.PI / 4 - a.y / 2)), d = this.e /
                2 * Math.log((1 + this.e * Math.sin(a.y)) / (1 - this.e * Math.sin(a.y))),
                d = 2 * (Math.atan(Math.exp(-this.alpha * (b + d) + this.K)) - Math.PI / 4),
                e = this.alpha * (a.x - this.lambda0),
                b = Math.atan(Math.sin(e) / (Math.sin(this.b0) * Math.tan(d) + Math.cos(this.b0) * Math.cos(e))),
                d = Math.asin(Math.cos(this.b0) * Math.sin(d) - Math.sin(this.b0) * Math.cos(d) * Math.cos(e));
            a.y = this.R / 2 * Math.log((1 + Math.sin(d)) / (1 - Math.sin(d))) + this.y0;
            a.x = this.R * b + this.x0;
            return a
        }, inverse: function (a) {
            for (var b = (a.x - this.x0) / this.R, d = 2 * (Math.atan(Math.exp((a.y -
                this.y0) / this.R)) - Math.PI / 4), e = Math.asin(Math.cos(this.b0) * Math.sin(d) + Math.sin(this.b0) * Math.cos(d) * Math.cos(b)), b = Math.atan(Math.sin(b) / (Math.cos(this.b0) * Math.cos(b) - Math.sin(this.b0) * Math.tan(d))), b = this.lambda0 + b / this.alpha, d = 0, f = e, h = -1E3, g = 0; 1E-7 < Math.abs(f - h);) {
                if (20 < ++g) {
                    Proj4js.reportError("omercFwdInfinity");
                    return
                }
                d = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + e / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(f)) / 2));
                h = f;
                f = 2 * Math.atan(Math.exp(d)) - Math.PI / 2
            }
            a.x = b;
            a.y = f;
            return a
        }
    };
    (function (a, b, d, e) {
        function f(a, b, d) {
            return setTimeout(n(a, d), b)
        }

        function h(a, b, d) {
            return Array.isArray(a) ? (g(a, d[b], d), !0) : !1
        }

        function g(a, b, d) {
            var g;
            if (a) if (a.forEach) a.forEach(b, d); else if (a.length !== e) for (g = 0; g < a.length;) b.call(d, a[g], g, a), g++; else for (g in a) a.hasOwnProperty(g) && b.call(d, a[g], g, a)
        }

        function k(a, b, d) {
            for (var g = Object.keys(b), h = 0; h < g.length;) {
                if (!d || d && a[g[h]] === e) a[g[h]] = b[g[h]];
                h++
            }
            return a
        }

        function l(a, b) {
            return k(a, b, !0)
        }

        function m(a, b, d) {
            b = b.prototype;
            var e;
            e = a.prototype = Object.create(b);
            e.constructor = a;
            e._super = b;
            d && k(e, d)
        }

        function n(a, b) {
            return function () {
                return a.apply(b, arguments)
            }
        }

        function q(a, b) {
            return "function" == typeof a ? a.apply(b ? b[0] || e : e, b) : a
        }

        function p(a, b, d) {
            g(u(b), function (b) {
                a.addEventListener(b, d, !1)
            })
        }

        function r(a, b, d) {
            g(u(b), function (b) {
                a.removeEventListener(b, d, !1)
            })
        }

        function v(a, b) {
            for (; a;) {
                if (a == b) return !0;
                a = a.parentNode
            }
            return !1
        }

        function u(a) {
            return a.trim().split(/\s+/g)
        }

        function x(a, b, d) {
            if (a.indexOf && !d) return a.indexOf(b);
            for (var e = 0; e < a.length;) {
                if (d && a[e][d] ==
                    b || !d && a[e] === b) return e;
                e++
            }
            return -1
        }

        function w(a) {
            return Array.prototype.slice.call(a, 0)
        }

        function z(a, b, d) {
            for (var e = [], g = [], h = 0; h < a.length;) {
                var f = b ? a[h][b] : a[h];
                0 > x(g, f) && e.push(a[h]);
                g[h] = f;
                h++
            }
            d && (e = b ? e.sort(function (a, d) {
                return a[b] > d[b]
            }) : e.sort());
            return e
        }

        function F(a, b) {
            for (var d, g = b[0].toUpperCase() + b.slice(1), h = 0; h < ya.length;) {
                d = (d = ya[h]) ? d + g : b;
                if (d in a) return d;
                h++
            }
            return e
        }

        function B(a) {
            a = a.ownerDocument;
            return a.defaultView || a.parentWindow
        }

        function H(a, b) {
            var d = this;
            this.manager =
                a;
            this.callback = b;
            this.element = a.element;
            this.target = a.options.inputTarget;
            this.domHandler = function (b) {
                q(a.options.enable, [a]) && d.handler(b)
            };
            this.init()
        }

        function E(a) {
            var b = a.options.inputClass;
            return new (b ? b : bb ? K : Sa ? L : ja ? aa : C)(a, I)
        }

        function I(a, b, d) {
            var g = d.pointers.length, h = d.changedPointers.length, f = b & 1 && 0 === g - h;
            d.isFirst = !!f;
            d.isFinal = !!(b & 12 && 0 === g - h);
            f && (a.session = {});
            d.eventType = b;
            b = a.session;
            g = d.pointers;
            h = g.length;
            b.firstInput || (b.firstInput = A(d));
            1 < h && !b.firstMultiple ? b.firstMultiple =
                A(d) : 1 === h && (b.firstMultiple = !1);
            var f = b.firstInput, k = (h = b.firstMultiple) ? h.center : f.center, l = d.center = N(g);
            d.timeStamp = vb();
            d.deltaTime = d.timeStamp - f.timeStamp;
            d.angle = Y(k, l);
            d.distance = D(k, l);
            var f = d.center, k = b.offsetDelta || {}, l = b.prevDelta || {}, m = b.prevInput || {};
            if (1 === d.eventType || 4 === m.eventType) l = b.prevDelta = {
                x: m.deltaX || 0,
                y: m.deltaY || 0
            }, k = b.offsetDelta = {x: f.x, y: f.y};
            d.deltaX = l.x + (f.x - k.x);
            d.deltaY = l.y + (f.y - k.y);
            d.offsetDirection = G(d.deltaX, d.deltaY);
            h ? (f = h.pointers, f = D(g[0], g[1], Ya) / D(f[0],
                f[1], Ya)) : f = 1;
            d.scale = f;
            h ? (h = h.pointers, g = Y(g[1], g[0], Ya) - Y(h[1], h[0], Ya)) : g = 0;
            d.rotation = g;
            k = b.lastInterval || d;
            g = d.timeStamp - k.timeStamp;
            8 != d.eventType && (25 < g || k.velocity === e) ? (f = k.deltaX - d.deltaX, k = k.deltaY - d.deltaY, l = f / g || 0, m = k / g || 0, g = l, h = m, l = $a(l) > $a(m) ? l : m, f = G(f, k), b.lastInterval = d) : (l = k.velocity, g = k.velocityX, h = k.velocityY, f = k.direction);
            d.velocity = l;
            d.velocityX = g;
            d.velocityY = h;
            d.direction = f;
            b = a.element;
            v(d.srcEvent.target, b) && (b = d.srcEvent.target);
            d.target = b;
            a.emit("hammer.input", d);
            a.recognize(d);
            a.session.prevInput = d
        }

        function A(a) {
            for (var b = [], d = 0; d < a.pointers.length;) b[d] = {
                clientX: ma(a.pointers[d].clientX),
                clientY: ma(a.pointers[d].clientY)
            }, d++;
            return {timeStamp: vb(), pointers: b, center: N(b), deltaX: a.deltaX, deltaY: a.deltaY}
        }

        function N(a) {
            var b = a.length;
            if (1 === b) return {x: ma(a[0].clientX), y: ma(a[0].clientY)};
            for (var d = 0, e = 0, g = 0; g < b;) d += a[g].clientX, e += a[g].clientY, g++;
            return {x: ma(d / b), y: ma(e / b)}
        }

        function G(a, b) {
            return a === b ? 1 : $a(a) >= $a(b) ? 0 < a ? 2 : 4 : 0 < b ? 8 : 16
        }

        function D(a, b, d) {
            d || (d = Ea);
            var e = b[d[0]] -
                a[d[0]];
            a = b[d[1]] - a[d[1]];
            return Math.sqrt(e * e + a * a)
        }

        function Y(a, b, d) {
            d || (d = Ea);
            return 180 * Math.atan2(b[d[1]] - a[d[1]], b[d[0]] - a[d[0]]) / Math.PI
        }

        function C() {
            this.evEl = cb;
            this.evWin = y;
            this.allow = !0;
            this.pressed = !1;
            H.apply(this, arguments)
        }

        function K() {
            this.evEl = Qa;
            this.evWin = ta;
            H.apply(this, arguments);
            this.store = this.manager.session.pointerEvents = []
        }

        function J() {
            this.evTarget = "touchstart";
            this.evWin = "touchstart touchmove touchend touchcancel";
            this.started = !1;
            H.apply(this, arguments)
        }

        function L() {
            this.evTarget =
                Aa;
            this.targetIds = {};
            H.apply(this, arguments)
        }

        function U(a, b) {
            var d = w(a.touches), e = this.targetIds;
            if (b & 3 && 1 === d.length) return e[d[0].identifier] = !0, [d, d];
            var g, h = w(a.changedTouches), f = [], k = this.target;
            g = d.filter(function (a) {
                return v(a.target, k)
            });
            if (1 === b) for (d = 0; d < g.length;) e[g[d].identifier] = !0, d++;
            for (d = 0; d < h.length;) e[h[d].identifier] && f.push(h[d]), b & 12 && delete e[h[d].identifier], d++;
            if (f.length) return [z(g.concat(f), "identifier", !0), f]
        }

        function aa() {
            H.apply(this, arguments);
            var a = n(this.handler,
                this);
            this.touch = new L(this.manager, a);
            this.mouse = new C(this.manager, a)
        }

        function Z(a, b) {
            this.manager = a;
            this.set(b)
        }

        function P(a) {
            if (-1 < a.indexOf("none")) return "none";
            var b = -1 < a.indexOf("pan-x"), d = -1 < a.indexOf("pan-y");
            return b && d ? "pan-x pan-y" : b || d ? b ? "pan-x" : "pan-y" : -1 < a.indexOf("manipulation") ? "manipulation" : "auto"
        }

        function S(a) {
            this.id = Q++;
            this.manager = null;
            this.options = l(a || {}, this.defaults);
            a = this.options.enable;
            this.options.enable = a === e ? !0 : a;
            this.state = 1;
            this.simultaneous = {};
            this.requireFail =
                []
        }

        function da(a) {
            return 16 == a ? "down" : 8 == a ? "up" : 2 == a ? "left" : 4 == a ? "right" : ""
        }

        function ca(a, b) {
            var d = b.manager;
            return d ? d.get(a) : a
        }

        function M() {
            S.apply(this, arguments)
        }

        function la() {
            M.apply(this, arguments);
            this.pY = this.pX = null
        }

        function ea() {
            M.apply(this, arguments)
        }

        function ka() {
            S.apply(this, arguments);
            this._input = this._timer = null
        }

        function na() {
            M.apply(this, arguments)
        }

        function T() {
            M.apply(this, arguments)
        }

        function X() {
            S.apply(this, arguments);
            this.pCenter = this.pTime = !1;
            this._input = this._timer = null;
            this.count =
                0
        }

        function ra(a, b) {
            b = b || {};
            var d = b.recognizers;
            b.recognizers = d === e ? ra.defaults.preset : d;
            return new Fa(a, b)
        }

        function Fa(a, b) {
            b = b || {};
            this.options = l(b, ra.defaults);
            this.options.inputTarget = this.options.inputTarget || a;
            this.handlers = {};
            this.session = {};
            this.recognizers = [];
            this.element = a;
            this.input = E(this);
            this.touchAction = new Z(this, this.options.touchAction);
            va(this, !0);
            g(b.recognizers, function (a) {
                var b = this.add(new a[0](a[1]));
                a[2] && b.recognizeWith(a[2]);
                a[3] && b.requireFailure(a[3])
            }, this)
        }

        function va(a,
                    b) {
            var d = a.element;
            g(a.options.cssProps, function (a, e) {
                d.style[F(d.style, e)] = b ? a : ""
            })
        }

        function Va(a, d) {
            var e = b.createEvent("Event");
            e.initEvent(a, !0, !0);
            e.gesture = d;
            d.target.dispatchEvent(e)
        }

        var ya = " webkit moz MS ms o".split(" "), nb = b.createElement("div"), ma = Math.round, $a = Math.abs,
            vb = Date.now, Q = 1, lb = /mobile|tablet|ip(ad|hone|od)|android/i, ja = "ontouchstart" in a,
            bb = F(a, "PointerEvent") !== e, Sa = ja && lb.test(navigator.userAgent), Ea = ["x", "y"],
            Ya = ["clientX", "clientY"];
        H.prototype = {
            handler: function () {
            }, init: function () {
                this.evEl &&
                p(this.element, this.evEl, this.domHandler);
                this.evTarget && p(this.target, this.evTarget, this.domHandler);
                this.evWin && p(B(this.element), this.evWin, this.domHandler)
            }, destroy: function () {
                this.evEl && r(this.element, this.evEl, this.domHandler);
                this.evTarget && r(this.target, this.evTarget, this.domHandler);
                this.evWin && r(B(this.element), this.evWin, this.domHandler)
            }
        };
        var Cb = {mousedown: 1, mousemove: 2, mouseup: 4}, cb = "mousedown", y = "mousemove mouseup";
        m(C, H, {
            handler: function (a) {
                var b = Cb[a.type];
                b & 1 && 0 === a.button && (this.pressed =
                    !0);
                b & 2 && 1 !== a.which && (b = 4);
                this.pressed && this.allow && (b & 4 && (this.pressed = !1), this.callback(this.manager, b, {
                    pointers: [a],
                    changedPointers: [a],
                    pointerType: "mouse",
                    srcEvent: a
                }))
            }
        });
        var La = {pointerdown: 1, pointermove: 2, pointerup: 4, pointercancel: 8, pointerout: 8},
            ob = {2: "touch", 3: "pen", 4: "mouse", 5: "kinect"}, Qa = "pointerdown",
            ta = "pointermove pointerup pointercancel";
        a.MSPointerEvent && (Qa = "MSPointerDown", ta = "MSPointerMove MSPointerUp MSPointerCancel");
        m(K, H, {
            handler: function (a) {
                var b = this.store, d = !1, e = a.type.toLowerCase().replace("ms",
                    ""), e = La[e], g = ob[a.pointerType] || a.pointerType, h = "touch" == g,
                    f = x(b, a.pointerId, "pointerId");
                e & 1 && (0 === a.button || h) ? 0 > f && (b.push(a), f = b.length - 1) : e & 12 && (d = !0);
                0 > f || (b[f] = a, this.callback(this.manager, e, {
                    pointers: b,
                    changedPointers: [a],
                    pointerType: g,
                    srcEvent: a
                }), d && b.splice(f, 1))
            }
        });
        var Za = {touchstart: 1, touchmove: 2, touchend: 4, touchcancel: 8};
        m(J, H, {
            handler: function (a) {
                var b = Za[a.type];
                1 === b && (this.started = !0);
                if (this.started) {
                    var d;
                    d = w(a.touches);
                    var e = w(a.changedTouches);
                    b & 12 && (d = z(d.concat(e), "identifier",
                        !0));
                    d = [d, e];
                    b & 12 && 0 === d[0].length - d[1].length && (this.started = !1);
                    this.callback(this.manager, b, {
                        pointers: d[0],
                        changedPointers: d[1],
                        pointerType: "touch",
                        srcEvent: a
                    })
                }
            }
        });
        var Ja = {touchstart: 1, touchmove: 2, touchend: 4, touchcancel: 8},
            Aa = "touchstart touchmove touchend touchcancel";
        m(L, H, {
            handler: function (a) {
                var b = Ja[a.type], d = U.call(this, a, b);
                d && this.callback(this.manager, b, {
                    pointers: d[0],
                    changedPointers: d[1],
                    pointerType: "touch",
                    srcEvent: a
                })
            }
        });
        m(aa, H, {
            handler: function (a, b, d) {
                var e = "mouse" == d.pointerType;
                if ("touch" == d.pointerType) this.mouse.allow = !1; else if (e && !this.mouse.allow) return;
                b & 12 && (this.mouse.allow = !0);
                this.callback(a, b, d)
            }, destroy: function () {
                this.touch.destroy();
                this.mouse.destroy()
            }
        });
        var Pa = F(nb.style, "touchAction"), Ta = Pa !== e;
        Z.prototype = {
            set: function (a) {
                "compute" == a && (a = this.compute());
                Ta && (this.manager.element.style[Pa] = a);
                this.actions = a.toLowerCase().trim()
            }, update: function () {
                this.set(this.manager.options.touchAction)
            }, compute: function () {
                var a = [];
                g(this.manager.recognizers, function (b) {
                    q(b.options.enable,
                        [b]) && (a = a.concat(b.getTouchAction()))
                });
                return P(a.join(" "))
            }, preventDefaults: function (a) {
                if (!Ta) {
                    var b = a.srcEvent;
                    a = a.offsetDirection;
                    if (this.manager.session.prevented) b.preventDefault(); else {
                        var d = this.actions, e = -1 < d.indexOf("none"), g = -1 < d.indexOf("pan-y"),
                            d = -1 < d.indexOf("pan-x");
                        if (e || g && a & 6 || d && a & 24) return this.preventSrc(b)
                    }
                }
            }, preventSrc: function (a) {
                this.manager.session.prevented = !0;
                a.preventDefault()
            }
        };
        S.prototype = {
            defaults: {}, set: function (a) {
                k(this.options, a);
                this.manager && this.manager.touchAction.update();
                return this
            }, recognizeWith: function (a) {
                if (h(a, "recognizeWith", this)) return this;
                var b = this.simultaneous;
                a = ca(a, this);
                b[a.id] || (b[a.id] = a, a.recognizeWith(this));
                return this
            }, dropRecognizeWith: function (a) {
                if (h(a, "dropRecognizeWith", this)) return this;
                a = ca(a, this);
                delete this.simultaneous[a.id];
                return this
            }, requireFailure: function (a) {
                if (h(a, "requireFailure", this)) return this;
                var b = this.requireFail;
                a = ca(a, this);
                -1 === x(b, a) && (b.push(a), a.requireFailure(this));
                return this
            }, dropRequireFailure: function (a) {
                if (h(a,
                        "dropRequireFailure", this)) return this;
                a = ca(a, this);
                a = x(this.requireFail, a);
                -1 < a && this.requireFail.splice(a, 1);
                return this
            }, hasRequireFailures: function () {
                return 0 < this.requireFail.length
            }, canRecognizeWith: function (a) {
                return !!this.simultaneous[a.id]
            }, emit: function (a) {
                function b(g) {
                    d.manager.emit(d.options.event + (g ? e & 16 ? "cancel" : e & 8 ? "end" : e & 4 ? "move" : e & 2 ? "start" : "" : ""), a)
                }

                var d = this, e = this.state;
                8 > e && b(!0);
                b();
                8 <= e && b(!0)
            }, tryEmit: function (a) {
                if (this.canEmit()) return this.emit(a);
                this.state = 32
            }, canEmit: function () {
                for (var a =
                    0; a < this.requireFail.length;) {
                    if (!(this.requireFail[a].state & 33)) return !1;
                    a++
                }
                return !0
            }, recognize: function (a) {
                a = k({}, a);
                q(this.options.enable, [this, a]) ? (this.state & 56 && (this.state = 1), this.state = this.process(a), this.state & 30 && this.tryEmit(a)) : (this.reset(), this.state = 32)
            }, process: function (a) {
            }, getTouchAction: function () {
            }, reset: function () {
            }
        };
        m(M, S, {
            defaults: {pointers: 1}, attrTest: function (a) {
                var b = this.options.pointers;
                return 0 === b || a.pointers.length === b
            }, process: function (a) {
                var b = this.state, d = a.eventType,
                    e = b & 6;
                a = this.attrTest(a);
                return e && (d & 8 || !a) ? b | 16 : e || a ? d & 4 ? b | 8 : b & 2 ? b | 4 : 2 : 32
            }
        });
        m(la, M, {
            defaults: {event: "pan", threshold: 10, pointers: 1, direction: 30}, getTouchAction: function () {
                var a = this.options.direction, b = [];
                a & 6 && b.push("pan-y");
                a & 24 && b.push("pan-x");
                return b
            }, directionTest: function (a) {
                var b = this.options, d = !0, e = a.distance, g = a.direction, h = a.deltaX, f = a.deltaY;
                g & b.direction || (b.direction & 6 ? (g = 0 === h ? 1 : 0 > h ? 2 : 4, d = h != this.pX, e = Math.abs(a.deltaX)) : (g = 0 === f ? 1 : 0 > f ? 8 : 16, d = f != this.pY, e = Math.abs(a.deltaY)));
                a.direction =
                    g;
                return d && e > b.threshold && g & b.direction
            }, attrTest: function (a) {
                return M.prototype.attrTest.call(this, a) && (this.state & 2 || !(this.state & 2) && this.directionTest(a))
            }, emit: function (a) {
                this.pX = a.deltaX;
                this.pY = a.deltaY;
                var b = da(a.direction);
                b && this.manager.emit(this.options.event + b, a);
                this._super.emit.call(this, a)
            }
        });
        m(ea, M, {
            defaults: {event: "pinch", threshold: 0, pointers: 2}, getTouchAction: function () {
                return ["none"]
            }, attrTest: function (a) {
                return this._super.attrTest.call(this, a) && (Math.abs(a.scale - 1) > this.options.threshold ||
                    this.state & 2)
            }, emit: function (a) {
                this._super.emit.call(this, a);
                1 !== a.scale && this.manager.emit(this.options.event + (1 > a.scale ? "in" : "out"), a)
            }
        });
        m(ka, S, {
            defaults: {event: "press", pointers: 1, time: 500, threshold: 5}, getTouchAction: function () {
                return ["auto"]
            }, process: function (a) {
                var b = this.options, d = a.pointers.length === b.pointers, e = a.distance < b.threshold,
                    g = a.deltaTime > b.time;
                this._input = a;
                if (!e || !d || a.eventType & 12 && !g) this.reset(); else if (a.eventType & 1) this.reset(), this._timer = f(function () {
                        this.state = 8;
                        this.tryEmit()
                    },
                    b.time, this); else if (a.eventType & 4) return 8;
                return 32
            }, reset: function () {
                clearTimeout(this._timer)
            }, emit: function (a) {
                8 === this.state && (a && a.eventType & 4 ? this.manager.emit(this.options.event + "up", a) : (this._input.timeStamp = vb(), this.manager.emit(this.options.event, this._input)))
            }
        });
        m(na, M, {
            defaults: {event: "rotate", threshold: 0, pointers: 2}, getTouchAction: function () {
                return ["none"]
            }, attrTest: function (a) {
                return this._super.attrTest.call(this, a) && (Math.abs(a.rotation) > this.options.threshold || this.state & 2)
            }
        });
        m(T, M, {
            defaults: {event: "swipe", threshold: 10, velocity: .65, direction: 30, pointers: 1},
            getTouchAction: function () {
                return la.prototype.getTouchAction.call(this)
            },
            attrTest: function (a) {
                var b = this.options.direction, d;
                b & 30 ? d = a.velocity : b & 6 ? d = a.velocityX : b & 24 && (d = a.velocityY);
                return this._super.attrTest.call(this, a) && b & a.direction && a.distance > this.options.threshold && $a(d) > this.options.velocity && a.eventType & 4
            },
            emit: function (a) {
                var b = da(a.direction);
                b && this.manager.emit(this.options.event + b, a);
                this.manager.emit(this.options.event,
                    a)
            }
        });
        m(X, S, {
            defaults: {event: "tap", pointers: 1, taps: 1, interval: 300, time: 250, threshold: 2, posThreshold: 10},
            getTouchAction: function () {
                return ["manipulation"]
            },
            process: function (a) {
                var b = this.options, d = a.pointers.length === b.pointers, e = a.distance < b.threshold,
                    g = a.deltaTime < b.time;
                this.reset();
                if (a.eventType & 1 && 0 === this.count) return this.failTimeout();
                if (e && g && d) {
                    if (4 != a.eventType) return this.failTimeout();
                    d = this.pTime ? a.timeStamp - this.pTime < b.interval : !0;
                    e = !this.pCenter || D(this.pCenter, a.center) < b.posThreshold;
                    this.pTime = a.timeStamp;
                    this.pCenter = a.center;
                    this.count = e && d ? this.count + 1 : 1;
                    this._input = a;
                    if (0 === this.count % b.taps) return this.hasRequireFailures() ? (this._timer = f(function () {
                        this.state = 8;
                        this.tryEmit()
                    }, b.interval, this), 2) : 8
                }
                return 32
            },
            failTimeout: function () {
                this._timer = f(function () {
                    this.state = 32
                }, this.options.interval, this);
                return 32
            },
            reset: function () {
                clearTimeout(this._timer)
            },
            emit: function () {
                8 == this.state && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input))
            }
        });
        ra.VERSION =
            "2.0.4";
        ra.defaults = {
            domEvents: !1,
            touchAction: "compute",
            enable: !0,
            inputTarget: null,
            inputClass: null,
            preset: [[na, {enable: !1}], [ea, {enable: !1}, ["rotate"]], [T, {direction: 6}], [la, {direction: 6}, ["swipe"]], [X], [X, {
                event: "doubletap",
                taps: 2
            }, ["tap"]], [ka]],
            cssProps: {
                userSelect: "none",
                touchSelect: "none",
                touchCallout: "none",
                contentZooming: "none",
                userDrag: "none",
                tapHighlightColor: "rgba(0,0,0,0)"
            }
        };
        Fa.prototype = {
            set: function (a) {
                k(this.options, a);
                a.touchAction && this.touchAction.update();
                a.inputTarget && (this.input.destroy(),
                    this.input.target = a.inputTarget, this.input.init());
                return this
            }, stop: function (a) {
                this.session.stopped = a ? 2 : 1
            }, recognize: function (a) {
                var b = this.session;
                if (!b.stopped) {
                    this.touchAction.preventDefaults(a);
                    var d, e = this.recognizers, g = b.curRecognizer;
                    if (!g || g && g.state & 8) g = b.curRecognizer = null;
                    for (var h = 0; h < e.length;) d = e[h], 2 === b.stopped || g && d != g && !d.canRecognizeWith(g) ? d.reset() : d.recognize(a), !g && d.state & 14 && (g = b.curRecognizer = d), h++
                }
            }, get: function (a) {
                if (a instanceof S) return a;
                for (var b = this.recognizers,
                         d = 0; d < b.length; d++) if (b[d].options.event == a) return b[d];
                return null
            }, add: function (a) {
                if (h(a, "add", this)) return this;
                var b = this.get(a.options.event);
                b && this.remove(b);
                this.recognizers.push(a);
                a.manager = this;
                this.touchAction.update();
                return a
            }, remove: function (a) {
                if (h(a, "remove", this)) return this;
                var b = this.recognizers;
                a = this.get(a);
                b.splice(x(b, a), 1);
                this.touchAction.update();
                return this
            }, on: function (a, b) {
                var d = this.handlers;
                g(u(a), function (a) {
                    d[a] = d[a] || [];
                    d[a].push(b)
                });
                return this
            }, off: function (a,
                              b) {
                var d = this.handlers;
                g(u(a), function (a) {
                    b ? d[a].splice(x(d[a], b), 1) : delete d[a]
                });
                return this
            }, emit: function (a, b) {
                this.options.domEvents && Va(a, b);
                var d = this.handlers[a] && this.handlers[a].slice();
                if (d && d.length) {
                    b.type = a;
                    b.preventDefault = function () {
                        b.srcEvent.preventDefault()
                    };
                    for (var e = 0; e < d.length;) d[e](b), e++
                }
            }, destroy: function () {
                this.element && va(this, !1);
                this.handlers = {};
                this.session = {};
                this.input.destroy();
                this.element = null
            }
        };
        k(ra, {
            INPUT_START: 1,
            INPUT_MOVE: 2,
            INPUT_END: 4,
            INPUT_CANCEL: 8,
            STATE_POSSIBLE: 1,
            STATE_BEGAN: 2,
            STATE_CHANGED: 4,
            STATE_ENDED: 8,
            STATE_RECOGNIZED: 8,
            STATE_CANCELLED: 16,
            STATE_FAILED: 32,
            DIRECTION_NONE: 1,
            DIRECTION_LEFT: 2,
            DIRECTION_RIGHT: 4,
            DIRECTION_UP: 8,
            DIRECTION_DOWN: 16,
            DIRECTION_HORIZONTAL: 6,
            DIRECTION_VERTICAL: 24,
            DIRECTION_ALL: 30,
            Manager: Fa,
            Input: H,
            TouchAction: Z,
            TouchInput: L,
            MouseInput: C,
            PointerEventInput: K,
            TouchMouseInput: aa,
            SingleTouchInput: J,
            Recognizer: S,
            AttrRecognizer: M,
            Tap: X,
            Pan: la,
            Swipe: T,
            Pinch: ea,
            Rotate: na,
            Press: ka,
            on: p,
            off: r,
            each: g,
            merge: l,
            extend: k,
            inherit: m,
            bindFn: n,
            prefixed: F
        });
        "function" == typeof define && define.amd ? define(function () {
            return ra
        }) : "undefined" != typeof module && module.exports ? module.exports = ra : a[d] = ra
    })(window, document, "Hammer");
    (function (a) {
        function b(b) {
            var d = b || window.event, e = [].slice.call(arguments, 1), k = 0, l = 0, m = 0;
            b = a.event.fix(d);
            b.type = "mousewheel";
            d.wheelDelta && (k = d.wheelDelta / 120);
            d.detail && (k = -d.detail / 3);
            m = k;
            void 0 !== d.axis && d.axis === d.HORIZONTAL_AXIS && (m = 0, l = -1 * k);
            void 0 !== d.wheelDeltaY && (m = d.wheelDeltaY / 120);
            void 0 !== d.wheelDeltaX && (l = -1 * d.wheelDeltaX / 120);
            e.unshift(b, k, l, m);
            return (a.event.dispatch || a.event.handle).apply(this, e)
        }

        var d = ["DOMMouseScroll", "mousewheel"];
        if (a.event.fixHooks) for (var e = d.length; e;) a.event.fixHooks[d[--e]] =
            a.event.mouseHooks;
        a.event.special.mousewheel = {
            setup: function () {
                if (this.addEventListener) for (var a = d.length; a;) this.addEventListener(d[--a], b, !1); else this.onmousewheel = b
            }, teardown: function () {
                if (this.removeEventListener) for (var a = d.length; a;) this.removeEventListener(d[--a], b, !1); else this.onmousewheel = null
            }
        };
        a.fn.extend({
            mousewheel: function (a) {
                return a ? this.bind("mousewheel", a) : this.trigger("mousewheel")
            }, unmousewheel: function (a) {
                return this.unbind("mousewheel", a)
            }
        })
    })(jQuery);
    define("com/visioglobe/web/helpers/StringUtils", [], function () {
        var a = function () {
        };
        a.ucfirst = function (a) {
            return a.charAt(0).toUpperCase() + a.slice(1)
        };
        return a
    });
    define("com/visioglobe/web/helpers/MathUtils", [], function () {
        var a = function () {
        };
        a.sign = function (a) {
            return 0 === a ? 0 : 0 < a ? 1 : -1
        };
        a.DEG2RAD = Math.PI / 180;
        a.RAD2DEG = 180 / Math.PI;
        return a
    });
    define("com/visioglobe/web/helpers/CachedTexture", [], function () {
        return function (a, b, d, e) {
            "undefined" === typeof d && (d = !0);
            var f, h;
            "undefined" === typeof a.textures[b] ? (h = {
                loaded: !1,
                postFunctions: [],
                debugURL: b
            }, a.textures[b] = h, e && h.postFunctions.push(e), d || (f = new THREE.Texture, f.vg = {nbRefs: 1}, h.pending = [f]), a.loaderStatistics.textures++, h.texture = THREE.ImageUtils.loadTexture(b, void 0, function (b) {
                a.loaderStatistics.textures--;
                if (!d) for (var e in h.pending) h.pending[e].image = b.image, h.pending[e].needsUpdate =
                    !0;
                h.loaded = !0;
                for (e in h.postFunctions) h.postFunctions[e](h);
                h.postFunctions = null;
                a.requestRedraw()
            }, function () {
                a.loaderStatistics.textures--
            }), h.texture.needsUpdate = !0, d && (f = h.texture, f.vg = {nbRefs: 1})) : (h = a.textures[b], d || (f = new THREE.Texture, f.vg = {nbRefs: 1}), d ? (f = h.texture, f.vg.nbRefs++, e && (h.loaded ? (e(h), e = null) : h.postFunctions.push(e))) : h.loaded ? (f.image = h.texture.image, f.needsUpdate = !0) : h.pending.push(f));
            return f
        }
    });
    define("com/visioglobe/web/Camera", ["require", "com/visioglobe/web/helpers/MathUtils"], function (a) {
        function b(a) {
            0 > a && (a += 360 * (-a / 360 + 1 | 0));
            return a % 360
        }

        var d = a("com/visioglobe/web/helpers/MathUtils");
        return function (a) {
            var f = !1, h = !1, g = !1;
            Object.defineProperty(this, "pitch", {
                get: function () {
                    return a.manipulator.orientation.x * d.RAD2DEG
                }, set: function (b) {
                    b = THREE.Math.clamp(b * d.DEG2RAD, a.manipulator.rotationXMin, a.manipulator.rotationXMax);
                    a.manipulator.orientation.x != b && (a.manipulator.orientation.x = b, a.manipulator.update())
                }
            });
            Object.defineProperty(this, "minPitch", {
                get: function () {
                    return a.manipulator.rotationXMin * d.RAD2DEG
                }, set: function (b) {
                    a.manipulator.rotationXMin = b * d.DEG2RAD;
                    b = THREE.Math.clamp(a.manipulator.orientation.x, a.manipulator.rotationXMin, a.manipulator.rotationXMax);
                    a.manipulator.orientation.x != b && (a.manipulator.orientation.x = b, a.manipulator.update())
                }
            });
            Object.defineProperty(this, "maxPitch", {
                get: function () {
                    return a.manipulator.rotationXMax * d.RAD2DEG
                }, set: function (b) {
                    a.manipulator.rotationXMax = b * d.DEG2RAD;
                    b =
                        THREE.Math.clamp(a.manipulator.orientation.x, a.manipulator.rotationXMin, a.manipulator.rotationXMax);
                    a.manipulator.orientation.x != b && (a.manipulator.orientation.x = b, a.manipulator.update())
                }
            });
            Object.defineProperty(this, "minRadius", {
                get: function () {
                    return a.manipulator.minRadius
                }, set: function (b) {
                    a.manipulator.minRadius = b;
                    a.manipulator.update()
                }
            });
            Object.defineProperty(this, "maxRadius", {
                get: function () {
                    return a.manipulator.maxRadius
                }, set: function (b) {
                    a.manipulator.maxRadius = b;
                    a.manipulator.update()
                }
            });
            Object.defineProperty(this,
                "position", {
                    get: function () {
                        return {x: a.manipulator.target.x, y: a.manipulator.target.y, radius: a.manipulator.radius}
                    }, set: function (b) {
                        if (!1 !== b) {
                            var d = !1;
                            if (a.manipulator.target.x != b.x || a.manipulator.target.y != b.y) a.manipulator.target.x = b.x, a.manipulator.target.y = b.y, d = !0;
                            "undefined" !== typeof b.radius && a.manipulator.radius != b.radius && (a.manipulator.radius = b.radius, d = !0);
                            d && a.manipulator.update()
                        }
                    }
                });
            Object.defineProperty(this, "rotation", {
                get: function () {
                    return b(a.manipulator.orientation.z * d.RAD2DEG + 90)
                },
                set: function (b) {
                    b = (b - 90) * d.DEG2RAD;
                    a.manipulator.orientation.z != b && (a.manipulator.orientation.z = b, a.manipulator.update())
                }
            });
            Object.defineProperty(this, "heading", {
                get: function () {
                    return b((a.cameraNorthRotation ? a.cameraNorthRotation : 0) - this.rotation)
                }, set: function (b) {
                    this.rotation = (a.cameraNorthRotation ? a.cameraNorthRotation : 0) - b
                }
            });
            Object.defineProperty(this, "pitchManipulatorEnabled", {
                get: function () {
                    return a.manipulator.pitchManipulatorEnabled
                }, set: function (b) {
                    a.manipulator.pitchManipulatorEnabled =
                        b ? !0 : !1
                }
            });
            Object.defineProperty(this, "rotationManipulatorEnabled", {
                get: function () {
                    return a.manipulator.rotationManipulatorEnabled
                }, set: function (b) {
                    a.manipulator.rotationManipulatorEnabled = b ? !0 : !1
                }
            });
            Object.defineProperty(this, "zoomManipulatorEnabled", {
                get: function () {
                    return a.manipulator.zoomManipulatorEnabled
                }, set: function (b) {
                    a.manipulator.zoomManipulatorEnabled = b ? !0 : !1
                }
            });
            Object.defineProperty(this, "panManipulatorEnabled", {
                get: function () {
                    return a.manipulator.panManipulatorEnabled
                }, set: function (b) {
                    a.manipulator.panManipulatorEnabled =
                        b ? !0 : !1
                }
            });
            this.getBoundary = function () {
                var b = a.manipulator.minTarget, d = a.manipulator.maxTarget;
                return {min: {x: b.x, y: b.y}, max: {x: d.x, y: d.y}}
            };
            this.setBoundary = function (b) {
                if (b && b.min && b.max) {
                    var d = a.manipulator.minTarget, g = a.manipulator.maxTarget;
                    d.x = Math.min(b.min.x, b.max.x);
                    g.x = Math.max(b.min.x, b.max.x);
                    d.y = Math.min(b.min.y, b.max.y);
                    g.y = Math.max(b.min.y, b.max.y);
                    a.manipulator.update()
                }
            };
            this.setManipulator = function (b) {
                switch (b) {
                    case "map":
                    case "trackball":
                    case "none":
                        a.manipulatorTypeName = b
                }
            };
            this.getManipulator =
                function () {
                    return a.manipulatorTypeName
                };
            this.setCustomPreManipulatorListener = function (b) {
                a.customPreManipulatorListener = "function" == typeof b ? b : !1
            };
            this.getCustomPreManipulatorListener = function () {
                return a.customPreManipulatorListener
            };
            this.setCustomPostManipulatorListener = function (b) {
                a.customPostManipulatorListener = "function" == typeof b ? b : !1
            };
            this.getCustomPostManipulatorListener = function () {
                return a.customPostManipulatorListener
            };
            this.removeCustomPreManipulatorListener = function () {
                a.customPreManipulatorListener =
                    !1
            };
            this.removeCustomPostManipulatorListener = function () {
                a.customPostManipulatorListener = !1
            };
            this.goTo = function (b, d) {
                !1 !== g && "pending" === g.state() && (void 0 !== g.vgTimeoutID && clearTimeout(g.vgTimeoutID), g.reject());
                g = jQuery.Deferred();
                var m = g.promise(), n = 500;
                d && "undefined" !== typeof d.animationDuration && (n = d.animationDuration, 0 > n && (n = 0));
                if ("undefined" === typeof b || "string" === typeof b && (b = a.getPlace(b), !1 === b)) return g.reject(), m;
                var q = new THREE.Vector3, p = a.manipulator.radius;
                if ("object" === typeof b && "object" ===
                    typeof b.vg && "object" === typeof b.vg.position && "undefined" !== typeof b.vg.position.x && "undefined" !== typeof b.vg.position.y && "undefined" !== typeof b.vg.radius) p = b.vg.radius, q.x = b.vg.position.x, q.y = b.vg.position.y; else if ("object" === typeof b && "undefined" !== typeof b.x && "undefined" !== typeof b.y) q.x = b.x, q.y = b.y, "undefined" !== typeof b.radius && (p = b.radius); else return g.reject(), m;
                !1 !== f && (f.stop(), f = !1, a.manipulator.update(), a.decrementUpdatableObjects());
                !1 !== h && (h.stop(), h = !1);
                if (0 === n) this.position = {
                    x: q.x,
                    y: q.y, radius: p
                }, g.vgTimeoutID = setTimeout(function () {
                    g.resolve()
                }, 0); else {
                    var r = a.manipulator.radius, v = a.manipulator.target.x, u = a.manipulator.target.y,
                        x = Math.max(a.manipulator.minRadius, p), w = q.x, z = q.y;
                    h = a.animateValue(0, 1, {
                        duration: n, easing: "linear", step: function (b) {
                            a.publicCamera.position = {x: v + b * (w - v), y: u + b * (z - u), radius: r + b * (x - r)}
                        }, complete: function () {
                            h = !1;
                            a.publicCamera.position = {x: w, y: z, radius: x};
                            g.resolve()
                        }
                    })
                }
                return m
            }
        }
    });
    define("com/visioglobe/web/helpers/ExtrudeGeometry", ["require", "com/visioglobe/web/helpers/MathUtils"], function (a) {
        var b = a("com/visioglobe/web/helpers/MathUtils");
        a = function (a, b) {
            THREE.ExtrudeGeometry.call(this, a, b)
        };
        a.prototype = new THREE.ExtrudeGeometry;
        a.prototype.addShape = function (a, e) {
            function f(a, b, d) {
                b || console.log("die");
                return b.clone().multiplyScalar(d).add(a)
            }

            function h(a, d, e) {
                var g = 1, g = a.x - d.x, h = a.y - d.y, f = e.x - a.x, k = e.y - a.y, l = g * g + h * h;
                if (1E-10 < Math.abs(g * k - h * f)) {
                    var m = Math.sqrt(l), n = Math.sqrt(f *
                        f + k * k), l = d.x - h / m;
                    d = d.y + g / m;
                    f = ((e.x - k / n - l) * k - (e.y + f / n - d) * f) / (g * k - h * f);
                    e = l + g * f - a.x;
                    a = d + h * f - a.y;
                    g = e * e + a * a;
                    if (2 >= g) return new THREE.Vector2(e, a);
                    g = Math.sqrt(g / 2)
                } else a = !1, 1E-10 < g ? 1E-10 < f && (a = !0) : -1E-10 > g ? -1E-10 > f && (a = !0) : b.sign(h) === b.sign(k) && (a = !0), a ? (e = -h, a = g, g = Math.sqrt(l)) : (e = g, a = h, g = Math.sqrt(l / 2));
                return new THREE.Vector2(e / g, a / g)
            }

            function g() {
                var a = 0;
                k(S, a);
                a += S.length;
                J = 0;
                for (L = Z.length; J < L; J++) K = Z[J], k(K, a), a += K.length
            }

            function k(a, b) {
                var d, e;
                for (X = a.length; 0 <= --X;) {
                    d = X;
                    e = X - 1;
                    0 > e && (e = a.length -
                        1);
                    for (var g = 0, h = x + 2 * v, g = 0; g < h; g++) {
                        var f = ka * g, k = ka * (g + 1), l = b + d + f, f = b + e + f, m = b + e + k, k = b + d + k,
                            l = l + aa, f = f + aa, m = m + aa, k = k + aa;
                        U.faces.push(new THREE.Face3(l, f, k, null, null, E));
                        U.faces.push(new THREE.Face3(f, m, k, null, null, E));
                        n && (l = Va.generateSideWallUV(U, l, f, m, k), U.faceVertexUvs[0].push([l[0], l[1], l[3]]), U.faceVertexUvs[0].push([l[1], l[2], l[3]]))
                    }
                }
            }

            function l(a, b, d) {
                U.vertices.push(new THREE.Vector3(a, b, d))
            }

            function m(a, b, d, e) {
                a += aa;
                b += aa;
                d += aa;
                U.faces.push(new THREE.Face3(a, b, d, null, null, H));
                n && (a = Va.generateTopUV(U,
                    a, b, d), U.faceVertexUvs[0].push(a))
            }

            var n = e.useUVs, q = void 0 !== e.amount ? e.amount : 100,
                p = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                r = void 0 !== e.bevelSize ? e.bevelSize : p - 2, v = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
                u = void 0 !== e.bevelEnabled ? e.bevelEnabled : !0, x = void 0 !== e.steps ? e.steps : 1,
                w = e.bendPath, z = e.extrudePath, F, B = !1, H = e.material, E = e.extrudeMaterial,
                I = void 0 !== e.generateTop ? e.generateTop : !0,
                A = void 0 !== e.generateBottom ? e.generateBottom : !0,
                N = void 0 !== e.generateSides ? e.generateSides : !0, G, D, Y, C;
            z &&
            (F = z.getSpacedPoints(x), B = !0, u = !1, G = new THREE.TubeGeometry.FrenetFrames(z, x, !1), D = new THREE.Vector3, Y = new THREE.Vector3, C = new THREE.Vector3);
            u || (r = p = v = 0);
            var K, J, L, U = this, aa = this.vertices.length;
            w && a.addWrapPath(w);
            var z = a.extractPoints(), w = z.shape, Z = z.holes;
            if (z = !THREE.Shape.Utils.isClockWise(w)) {
                w = w.reverse();
                J = 0;
                for (L = Z.length; J < L; J++) K = Z[J], THREE.Shape.Utils.isClockWise(K) && (Z[J] = K.reverse());
                z = !1
            }
            var P = THREE.Shape.Utils.triangulateShape(w, Z), S = w;
            J = 0;
            for (L = Z.length; J < L; J++) K = Z[J], w = w.concat(K);
            var da, ca, M, la, ea, ka = w.length, na, T = P.length, z = [], X = 0;
            M = S.length;
            da = M - 1;
            for (ca = X + 1; X < M; X++, da++, ca++) da === M && (da = 0), ca === M && (ca = 0), z[X] = h(S[X], S[da], S[ca]);
            var ra = [], Fa, va = z.concat();
            J = 0;
            for (L = Z.length; J < L; J++) {
                K = Z[J];
                Fa = [];
                X = 0;
                M = K.length;
                da = M - 1;
                for (ca = X + 1; X < M; X++, da++, ca++) da === M && (da = 0), ca === M && (ca = 0), Fa[X] = h(K[X], K[da], K[ca]);
                ra.push(Fa);
                va = va.concat(Fa)
            }
            for (da = 0; da < v; da++) {
                M = da / v;
                la = p * (1 - M);
                ca = r * Math.sin(M * Math.PI / 2);
                X = 0;
                for (M = S.length; X < M; X++) ea = f(S[X], z[X], ca), l(ea.x, ea.y, -la);
                J = 0;
                for (L = Z.length; J <
                L; J++) for (K = Z[J], Fa = ra[J], X = 0, M = K.length; X < M; X++) ea = f(K[X], Fa[X], ca), l(ea.x, ea.y, -la)
            }
            ca = r;
            for (X = 0; X < ka; X++) ea = u ? f(w[X], va[X], ca) : w[X], B ? (Y.copy(G.normals[0]).multiplyScalar(ea.x), D.copy(G.binormals[0]).multiplyScalar(ea.y), C.copy(F[0]).add(Y).add(D), l(C.x, C.y, C.z)) : l(ea.x, ea.y, 0);
            for (M = 1; M <= x; M++) for (X = 0; X < ka; X++) ea = u ? f(w[X], va[X], ca) : w[X], B ? (Y.copy(G.normals[M]).multiplyScalar(ea.x), D.copy(G.binormals[M]).multiplyScalar(ea.y), C.copy(F[M]).add(Y).add(D), l(C.x, C.y, C.z)) : l(ea.x, ea.y, q / x * M);
            for (da =
                     v - 1; 0 <= da; da--) {
                M = da / v;
                la = p * (1 - M);
                ca = r * Math.sin(M * Math.PI / 2);
                X = 0;
                for (M = S.length; X < M; X++) ea = f(S[X], z[X], ca), l(ea.x, ea.y, q + la);
                J = 0;
                for (L = Z.length; J < L; J++) for (K = Z[J], Fa = ra[J], X = 0, M = K.length; X < M; X++) ea = f(K[X], Fa[X], ca), B ? l(ea.x, ea.y + F[x - 1].y, F[x - 1].x + la) : l(ea.x, ea.y, q + la)
            }
            var Va = THREE.ExtrudeGeometry.WorldUVGenerator;
            (function () {
                if (u) {
                    var a;
                    a = 0 * ka;
                    if (A) for (X = 0; X < T; X++) na = P[X], m(na[2] + a, na[1] + a, na[0] + a, !0);
                    a = x + 2 * v;
                    a *= ka;
                    if (I) for (X = 0; X < T; X++) na = P[X], m(na[0] + a, na[1] + a, na[2] + a, !1)
                } else {
                    if (A) for (X = 0; X < T; X++) na =
                        P[X], m(na[2], na[1], na[0], !0);
                    if (I) for (X = 0; X < T; X++) na = P[X], m(na[0] + ka * x, na[1] + ka * x, na[2] + ka * x, !1)
                }
            })();
            N && g()
        };
        return a
    });
    define("com/visioglobe/web/LOD", [], function () {
        var a = function (a) {
            this.setEnabled = function () {
                return a.setEnabled.apply(a, arguments)
            };
            this.isEnabled = function () {
                return a.isEnabled.apply(a, arguments)
            }
        }, b = function (a, b, f) {
            this.index = f;
            this.mapviewer = a;
            this.node = new THREE.Object3D;
            this.node.visible = !1;
            this.node.matrixAutoUpdate = !1;
            this.contentNode = new THREE.Object3D;
            this.contentNode.matrixAutoUpdate = !1;
            this.floor = b;
            this.pickables = [];
            this.cameraUpdatableObjects = [];
            this.pathObjects = [];
            this.rampObjects = [];
            this.groundObjects =
                [];
            this.layers = {};
            this.publicLOD = this.active = !1;
            this.node.add(this.contentNode);
            b.node.add(this.node)
        };
        b.prototype.getPublicLOD = function () {
            return this.publicLOD = this.publicLOD || new a(this)
        };
        b.prototype.setContentEnabled = function (a) {
            this.contentNode.visible != a && (this.contentNode.visible = a, this.mapviewer.requestRedraw())
        };
        b.prototype.isContentEnabled = function () {
            return this.contentNode.visible
        };
        b.prototype.setEnabled = function (a) {
            this.node.visible != a && (this.node.visible = a, this.setActive(a), this.mapviewer.requestRedraw())
        };
        b.prototype.isEnabled = function () {
            return this.node.visible
        };
        b.prototype.getOrCreateLayer = function (a) {
            if ("undefined" === typeof this.layers[a]) {
                var b = new THREE.Object3D;
                b.matrixAutoUpdate = !1;
                this.layers[a] = b;
                this.node.add(b)
            }
            return this.layers[a]
        };
        b.prototype.setActive = function (a) {
            this.active === a || a && !1 === this.floor.isEnabled() || (a ? this.mapviewer.addActiveLOD(this) : this.mapviewer.removeActiveLOD(this), this.active = a, this.mapviewer.mustUpdateCameraObjects = !0, this.mapviewer.requestRedraw())
        };
        b.prototype.isActive =
            function () {
                return this.active
            };
        return b
    });
    define("com/visioglobe/web/Floor", ["require", "com/visioglobe/web/LOD"], function (a) {
        var b = a("com/visioglobe/web/LOD"), d = function (a) {
            this.name = a.name;
            this.index = a.index;
            this.heightMin = a.heightMin;
            this.heightMax = a.heightMax;
            this.setEnabled = function () {
                return a.setEnabled.apply(a, arguments)
            };
            this.isEnabled = function () {
                return a.isEnabled.apply(a, arguments)
            };
            this.setContentEnabled = function () {
                return a.setContentEnabled.apply(a, arguments)
            };
            this.isContentEnabled = function () {
                return a.isContentEnabled.apply(a, arguments)
            };
            this.getPosition = function () {
                return a.getPosition.apply(a, arguments)
            };
            this.setPosition = function () {
                return a.setPosition.apply(a, arguments)
            };
            this.getLODs = function () {
                return a.getPublicLODs()
            };
            this.setAutoUpdateLOD = function () {
                return a.setAutoUpdateLOD.apply(a, arguments)
            };
            this.isAutoUpdateLOD = function () {
                return a.isAutoUpdateLOD.apply(a, arguments)
            }
        };
        a = function (a, d) {
            this.name = d;
            this.lods = [];
            this.node = new THREE.Object3D;
            this.node.visible = !1;
            this.node.matrixAutoUpdate = !1;
            this.mapviewer = a;
            this.floorContentLOD =
                new b(a, this, -1);
            this.floorContentLOD.setEnabled(!0);
            this.positionUpdatableLinks = [];
            this.publicLODs = this.publicFloor = !1;
            this.autoUpdateLOD = !0;
            this.setContentEnabled(!0)
        };
        a.prototype.getPublicFloor = function () {
            return this.publicFloor = this.publicFloor || new d(this)
        };
        a.prototype.getPublicLODs = function () {
            if (!this.publicLODs) {
                this.publicLODs = [];
                for (var a = 0, b = this.lods.length; a < b; a++) this.publicLODs.push(this.lods[a].getPublicLOD())
            }
            return this.publicLODs
        };
        a.prototype.createLOD = function (a) {
            var d = new b(this.mapviewer,
                this, a, this.name);
            return this.lods[a] = d
        };
        a.prototype.getLOD = function (a) {
            for (var b = null, d = 0; d < this.lods.length; ++d) {
                var g = this.lods[d];
                if (void 0 !== g && g.index === a) {
                    b = g;
                    break
                }
            }
            return b
        };
        a.prototype.info = function () {
            var a = this.node.position;
            console.log("==============");
            console.log("Floor " + this.name + " visible " + this.node.visible + " content " + this.floorContentLOD.node.visible + " pos(" + a.x + "," + a.y + "," + a.z + ")");
            for (var a = 0, b = this.lods.length; a < b; ++a) {
                var d = this.lods[a].node.position;
                console.log("  LOD  " +
                    a + " visible " + this.lods[a].node.visible + " pos (" + d.x + "," + d.y + "," + d.z + ")")
            }
            console.log("this.positionUpdatableLinks.length: " + this.positionUpdatableLinks.length)
        };
        a.prototype.setEnabled = function (a) {
            if (this.node.visible !== a) {
                this.node.visible = a;
                this.floorContentLOD.isEnabled() && this.floorContentLOD.setActive(a);
                for (var b = 0; b < this.lods.length; ++b) {
                    var d = this.lods[b];
                    d.isEnabled() && d.setActive(a)
                }
                this.mapviewer.requestRedraw()
            }
        };
        a.prototype.isEnabled = function () {
            return this.node.visible
        };
        a.prototype.setContentEnabled =
            function (a) {
                this.floorContentLOD.setContentEnabled(a);
                for (var b = 0; b < this.lods.length; ++b) this.lods[b].setContentEnabled(a)
            };
        a.prototype.isContentEnabled = function () {
            return this.floorContentLOD.isContentEnabled()
        };
        a.prototype.getPosition = function () {
            var a = this.node.position;
            return {x: a.x, y: a.y, z: a.z}
        };
        a.prototype.setPosition = function (a) {
            var b = this.node.position;
            if (b.x != a.x || b.y != a.y || b.z != a.z) {
                a.z = a.z || 0;
                this.node.position.copy(a);
                a = 0;
                for (b = this.positionUpdatableLinks.length; a < b; a++) {
                    var d = this.positionUpdatableLinks[a],
                        g = !1;
                    if (d.linkOptions.startFloor === this || d.linkOptions.endFloor === this) var g = d.linkOptions.endPoint,
                        k = d.linkOptions.startFloor.getPosition(), l = d.linkOptions.endFloor.getPosition(),
                        g = {x: l.x - k.x + g.x, y: l.y - k.y + g.y, z: l.z - k.z + g.z};
                    g && d.updateEndPoints(!1, g)
                }
                this.mapviewer.mustUpdateCameraObjects = !0;
                this.node.updateMatrix();
                this.node.updateMatrixWorld(!0);
                this.mapviewer.requestRedraw()
            }
        };
        a.prototype.removeLink = function (a) {
            for (var b = 0, d = this.positionUpdatableLinks.length; b < d; b++) if (this.positionUpdatableLinks[b] ===
                a) return this.positionUpdatableLinks.splice(b, 1), !0;
            return !1
        };
        a.prototype.addLink = function (a) {
            this.positionUpdatableLinks.push(a)
        };
        a.prototype.isAutoUpdateLOD = function () {
            return this.autoUpdateLOD
        };
        a.prototype.setAutoUpdateLOD = function (a) {
            if (this.autoUpdateLOD = a) this.mapviewer.mustUpdateCameraObjects = !0, this.mapviewer.requestRedraw()
        };
        return a
    });
    define("com/visioglobe/web/Path", [], function () {
        var a = function (a) {
            this.show = function () {
                return a.show.apply(a, arguments)
            };
            this.hide = function () {
                return a.hide.apply(a, arguments)
            };
            this.remove = function () {
                return a.remove.apply(a, arguments)
            };
            this.getLength = function () {
                return a.getLength.apply(a, arguments)
            };
            this.getInterpolatedPosition = function () {
                return a.getInterpolatedPosition.apply(a, arguments)
            };
            this.setInterpolatedStartEnd = function () {
                return a.setInterpolatedStartEnd.apply(a, arguments)
            };
            this.getVisible =
                function () {
                    return a.getVisible.apply(a, arguments)
                };
            this.options = function () {
                return a.options.apply(a, arguments)
            };
            Object.defineProperty(this, "visible", {
                get: function () {
                    return a.getVisible()
                }, set: function (b) {
                    a.setVisible(b)
                }
            });
            this.updateEndPoints = function () {
                return a.updateEndPoints.apply(a, arguments)
            }
        }, b = function (b) {
            a.apply(this, [b])
        };
        return function (d, e, f, h, g, k, l) {
            this.mesh = g;
            g.traverse(function (a) {
                a.visible = e.visible
            });
            g = null;
            this.lod = l;
            this.path_geometry = k;
            this.spline = f;
            this.meshParent = this.mesh.parent;
            this.previousRight = new THREE.Vector3;
            this.publicLink = this.publicPath = !1;
            this.getPublicPath = function () {
                return this.publicPath = this.publicPath || new a(this)
            };
            this.getPublicLink = function () {
                return this.publicLink = this.publicLink || new b(this)
            };
            this.setVisible = function (a) {
                this.mesh && e && e.visible !== a && (0 !== e.speed && (a ? d.incrementUpdatableObjects() : d.decrementUpdatableObjects()), e.visible = a, this.mesh.traverse(function (b) {
                    b.visible = a
                }), d.requestRedraw())
            };
            this.getVisible = function () {
                return e && e.visible
            };
            this.show =
                function () {
                    this.setVisible(!0)
                };
            this.hide = function () {
                this.setVisible(!1)
            };
            this.remove = function () {
                if (this.mesh) {
                    var a = this.mesh;
                    "undefined" !== typeof a.parent && (a.parent.remove(a), e.visible && 0 !== e.speed && d.decrementUpdatableObjects(), d.requestRedraw());
                    this.linkOptions && (d.removeLink(this), this.linkOptions.startFloor.removeLink(this), this.linkOptions.endFloor.removeLink(this));
                    this.mesh && (this.mesh.geometry.dispose(), this.mesh = null);
                    d.removePath(this)
                }
            };
            this.getLength = function () {
                return h
            };
            this.getInterpolatedPosition =
                function (a) {
                    return f ? (0 > a ? a = 0 : 1 < a && (a = 1), a = f.getPoint(a), {x: a.x, y: a.y, z: a.z}) : !1
                };
            this.setInterpolatedStartEnd = function (a, b) {
                a = a || 0;
                0 > a ? a = 0 : 1 < a && (a = 1);
                b = "undefined" === typeof b ? 1 : b;
                0 > b ? b = 0 : 1 < b && (b = 1);
                e.interpolationStart = a;
                e.interpolationEnd = b;
                k.interpolationStart = a;
                k.interpolationEnd = b;
                k.recalculate();
                this.mesh = d.recreateAndUpdateMeshFromPathGeometry(k.getGeometry(), this.mesh, e.visible);
                this.isCameraFacing && this.updateCamerafacing(!0)
            };
            this.updateEndPoints = function (a, b) {
                if (this.mesh) {
                    var e = this.mesh.vg &&
                        this.mesh.vg.path || {};
                    if (e.points && 2 != e.points.length) return !1;
                    e.points[0] = a || f.getPoint(0);
                    e.points[1] = b || f.getPoint(1);
                    if (e.points[0].x === e.points[1].x && e.points[0].y === e.points[1].y && e.points[0].z === e.points[1].z) return void 0 !== this.mesh.parent && this.mesh.parent.remove(this.mesh), !1;
                    f = new THREE.CurvePath;
                    f.add(new THREE.LineCurve3(e.points[0], e.points[1]));
                    h = f.getLength();
                    k.updatePath(f);
                    void 0 === this.mesh.parent && (this.meshParent.add(this.mesh), this.mesh.updateMatrixWorld());
                    var g = e.repeat;
                    0 >
                    e.repeat && e.url && (g *= -h / e.thickness, this.mesh.material.map.repeat.x = g);
                    this.mesh = d.recreateAndUpdateMeshFromPathGeometry(k.getGeometry(), this.mesh, e.visible);
                    this.isCameraFacing && this.updateCamerafacing(!0)
                }
            };
            this.setLinkOptions = function (a) {
                this.isCameraFacing = a.cameraFacing || !1;
                this.linkOptions = a;
                this.linkOptions.startFloor.addLink(this);
                this.linkOptions.endFloor.addLink(this)
            };
            this.updateCamerafacing = function (a) {
                var b = {
                    x: d.camera.matrix.elements[0],
                    y: d.camera.matrix.elements[1],
                    z: d.camera.matrix.elements[2]
                };
                if (!this.previousRight.equals(b) || a) {
                    this.previousRight.copy(b);
                    a = this.mesh.vg && this.mesh.vg.path || {};
                    if (a.points && 2 != a.points.length) return !1;
                    var e = a.points[1].z < a.points[0].z;
                    k.recalculate({binormal: b});
                    this.mesh = d.recreateAndUpdateMeshFromPathGeometry(k.getGeometry(), this.mesh, a.visible);
                    this.mesh.material.side = e ? THREE.FrontSide : THREE.BackSide
                }
            };
            this.options = function (a, b) {
                if ("undefined" === typeof a) return e;
                if ("undefined" === typeof b) return "interpolationTextureLikeWindow" === a ? k.interpolationTextureLikeWindow :
                    e[a];
                if ("speed" === a) this.mesh.vg && this.mesh.vg.path && "undefined" !== typeof this.mesh.vg.path.speed && (0 !== this.mesh.vg.path.speed && d.decrementUpdatableObjects(), e.speed = b, this.mesh.vg.path.speed = b, 0 != b && e.visible && d.incrementUpdatableObjects()); else if ("interpolationTextureLikeWindow" === a) k.interpolationTextureLikeWindow != b && (k.interpolationTextureLikeWindow = b, e.interpolationTextureLikeWindow = b, this.setInterpolatedStartEnd(e.interpolationStart, e.interpolationEnd)); else if ("interpolationStart" === a ||
                    "interpolationEnd" === a) "interpolationStart" === a ? e.interpolationStart = b : "interpolationEnd" === a && (e.interpolationEnd = b), this.setInterpolatedStartEnd(e.interpolationStart, e.interpolationEnd)
            }
        }
    });
    define("com/visioglobe/web/helpers/PathGeometry", [], function () {
        var a = function (a, d) {
            this.segments = d.segments || 64;
            this.radius = d.radius || 1;
            this.segmentsRadius = d.segmentsRadius || 8;
            this.closed = d.closed || !1;
            this.interpolationStart = d.interpolationStart || 0;
            this.interpolationEnd = d.interpolationEnd || 1;
            this.interpolationTextureLikeWindow = "undefined" === typeof d.interpolationTextureLikeWindow ? !0 : d.interpolationTextureLikeWindow;
            this.zOffset = d.zOffset || 0;
            d.debug && (this.debug = new THREE.Object3D);
            this.updatePath(a)
        };
        a.prototype.updatePath = function (a) {
            this.path = a;
            this.frames = new THREE.TubeGeometry.FrenetFrames(a, this.segments, this.closed);
            this.recalculate()
        };
        a.prototype.recalculate = function (a) {
            a = a || {};
            this.geometry = new THREE.Geometry;
            this.grid = [];
            var d = this.frames, e = d.tangents, f = d.normals, h = d.binormals, g, k, l, d = 1 / this.segments, m, n,
                q, p, r, v, u;
            r = a.binormal;
            a = 0;
            0 != this.interpolationStart && (a = Math.floor(this.interpolationStart / d));
            var x = this.segments - 1;
            1 != this.interpolationEnd && (q = this.interpolationEnd / d, x = Math.floor(q),
            q === x && x--);
            var w = 1 / (this.segmentsRadius - 1), z = this.path, F = this.zOffset;
            q = a;
            for (p = x + 2; q < p; q++) for (g = q * d, q === a && 0 != this.interpolationStart && (g = this.interpolationStart), q === x + 1 && 1 != this.interpolationEnd && (g = this.interpolationEnd), this.grid[q] = [], n = z.getPointAt(g), k = f[q], l = r || h[q], this.debug && (g = e[q], this.debug.add(new THREE.ArrowHelper(g, n, this.radius, 255)), this.debug.add(new THREE.ArrowHelper(k, n, this.radius, 16711680)), this.debug.add(new THREE.ArrowHelper(l, n, this.radius, 65280))), g = 0, k = this.segmentsRadius; g <
            k; g++) m = g * w - .5, m *= this.radius, this.grid[q][g] = this.geometry.vertices.push(new THREE.Vector3(n.x + m * l.x, n.y + m * l.y, n.z + m * l.z + F)) - 1;
            w = this.interpolationTextureLikeWindow ? 0 : this.interpolationStart;
            z = 1 / (this.segmentsRadius - 1);
            q = a;
            for (p = x + 1; q < p; q++) for (e = this.closed ? (q + 1) % this.segments : q + 1, F = q * d - w, l = F + d, q === a && 0 != this.interpolationStart && (F = this.interpolationStart - w), q === x && 1 != this.interpolationEnd && (l = this.interpolationEnd - w), g = 0; g < this.segmentsRadius - 1; g++) n = (g + 1) % this.segmentsRadius, f = this.grid[q][g],
                h = this.grid[e][g], r = this.grid[e][n], n = this.grid[q][n], m = g * z, u = m + z, k = new THREE.Vector2(F, m), m = new THREE.Vector2(l, m), v = new THREE.Vector2(l, u), u = new THREE.Vector2(F, u), this.geometry.faces.push(new THREE.Face3(f, h, n)), this.geometry.faceVertexUvs[0].push([k, m, u]), this.geometry.faces.push(new THREE.Face3(h, r, n)), this.geometry.faceVertexUvs[0].push([m.clone(), v, u.clone()]);
            this.geometry.computeFaceNormals();
            this.geometry.computeVertexNormals()
        };
        a.prototype.constructor = a;
        a.prototype.getGeometry = function () {
            return this.geometry
        };
        return a
    });
    define("com/visioglobe/web/Place", [], function () {
        var a = {};
        return function (b, d, e, f) {
            "undefined" !== typeof e && ("undefined" === typeof b.places[e] ? b.places[e] = this : console.log("ERROR: Should have one place per ID: " + e));
            this.vg = {id: e, floor: null, originalColor: null, position: null, radius: null};
            e = new THREE.Vector3;
            f = new THREE.Box3;
            for (var h in d) {
                var g = d[h], k;
                for (k in this.vg) if ("id" !== k) if (null === this.vg[k] && "radius" === k) {
                    if (g.geometry.boundingBox) g.geometry.boundingBox.size(e); else {
                        f.makeEmpty();
                        var l = g.geometry.vertices,
                            m = g.geometry.faces;
                        h = g.vg.faces_offset;
                        for (var n = g.vg.faces_offset + g.vg.nb_faces, q = m.length; h < q && h < n; h++) {
                            var p = m[h];
                            f.expandByPoint(l[p.a]);
                            f.expandByPoint(l[p.b]);
                            f.expandByPoint(l[p.c])
                        }
                        f.size(e)
                    }
                    this.vg[k] = 2 * e.length()
                } else null === this.vg[k] ? this.vg[k] = g.vg[k] : this.vg[k] === g.vg[k] || -1 !== ["position", "radius"].indexOf(k) || a[k] || (console.log("ERROR: Several element with same ID but different " + k + " are present"), a[k] = !0)
            }
            this.highlight = function (a) {
                for (var e in d) b.setShapeColor(d[e], a);
                b.requestRedraw();
                return !0
            };
            this.removeHighlight = function () {
                for (var a in d) b.setShapeColor(d[a], d[a].vg.originalColor);
                b.requestRedraw();
                return !0
            }
        }
    });
    define("com/visioglobe/web/poi/PublicPOI", [], function () {
        function a(b) {
            this.proxy = b;
            this.count = a.counter++;
            this.vg = {poi: !0}
        }

        a.counter = 0;
        a.prototype.constructor = a;
        a.prototype.show = function () {
            return this.proxy.setVisible(!0)
        };
        a.prototype.hide = function () {
            return this.proxy.setVisible(!1)
        };
        a.prototype.remove = function () {
            return this.proxy.remove.apply(this.proxy, arguments)
        };
        a.prototype.options = function () {
            return this.proxy.options.apply(this.proxy, arguments)
        };
        Object.defineProperty(a.prototype, "visible", {
            get: function () {
                return this.proxy.getVisible()
            },
            set: function (a) {
                this.proxy.setVisible(a)
            }
        });
        Object.defineProperty(a.prototype, "opacity", {
            get: function () {
                return this.proxy.getOpacity()
            }, set: function (a) {
                this.proxy.setOpacity(a)
            }
        });
        return a
    });
    define("com/visioglobe/web/poi/POIProxy", [], function () {
        function a(d) {
            this.publicPOI = null;
            this.count = a.counter++;
            Object.keys(b).forEach(function (a) {
                a = b[a];
                "undefined" !== typeof d[a] && function (a, b) {
                    a[b] = function () {
                        for (var a = [], h = 0; h < arguments.length; h++) a.push(arguments[h]);
                        return d[b].apply(d, a)
                    }
                }(this, a)
            }, this)
        }

        var b = "getVisible setVisible getOpacity setOpacity remove options".split(" "),
            d = "text url model selector textTextureHeight family color position alignment scale zoomScaleFactor zoomScaleFast iconScale angle heading floor lod visible opacity id visibilityRampStartVisible visibilityRampFullyVisible visibilityRampStartInvisible visibilityRampFullyInvisible clickable fixed width height overlay flip face2d image onObjectMouseOver onObjectMouseOut onObjectMouseUp multiline".split(" ");
        a.isPublicParameter = function (a) {
            return -1 !== d.indexOf(a)
        };
        a.getPublicParameters = function (b) {
            var d = {};
            Object.keys(b).map(function (h) {
                a.isPublicParameter(h) && (d[h] = b[h])
            });
            return d
        };
        a.counter = 1E3;
        return a.prototype.constructor = a
    });
    define("com/visioglobe/web/helpers/Billboard", [], function () {
        THREE.Billboard = function (a, b) {
            this.mapviewer = b;
            this.constraints = "undefined" !== typeof a.constraints ? a.constraints : [THREE.Billboard.CAMERA_FACING, THREE.Billboard.FIXED, THREE.Billboard.CAMERA_FACING];
            "undefined" !== typeof a.face2d && !0 === a.face2d && (this.constraints = [THREE.Billboard.FIXED, THREE.Billboard.FIXED, THREE.Billboard.CAMERA_FACING]);
            this.face2d = this.constraints[0] == THREE.Billboard.FIXED && this.constraints[1] == THREE.Billboard.FIXED && this.constraints[2] ==
                THREE.Billboard.CAMERA_FACING;
            this.lastCameraOrientationZ = !1;
            THREE.Object3D.call(this)
        };
        THREE.Billboard.CAMERA_FACING = 0;
        THREE.Billboard.FIXED_MODULO_PI = 1;
        THREE.Billboard.FIXED = 2;
        THREE.Billboard.prototype = new THREE.Object3D;
        THREE.Billboard.prototype.constructor = THREE.Billboard;
        var a = new THREE.Matrix4, b = new THREE.Matrix4, d = new THREE.Matrix4;
        THREE.Billboard.prototype.updateMatrix = function () {
            if (this.face2d) {
                if (!this._dirty && !1 !== this.lastCameraOrientationZ && this.mapviewer.manipulator.orientation.z == this.lastCameraOrientationZ) return;
                this.lastCameraOrientationZ = this.mapviewer.manipulator.orientation.z;
                if (this.mapviewer.manipulator.cachedMatrixOrientationZ === this.mapviewer.manipulator.orientation.z) {
                    this.matrix.copy(this.mapviewer.manipulator.cachedMatrixForOrientation);
                    this.matrix.setPosition(this.position);
                    this.matrixWorldNeedsUpdate = !0;
                    return
                }
            }
            if (this.mapviewer.camera.vg) {
                var e = this.mapviewer.camera.vg.cameraComponents;
                this.rotation.set(0, 0, 0);
                for (var f = this.rotation.toArray(), h = 0; 3 > h; ++h) {
                    switch (this.constraints[h]) {
                        case THREE.Billboard.CAMERA_FACING:
                            f[h] =
                                e[h]
                    }
                    switch (h) {
                        case 0:
                            b.makeRotationX(3 * Math.PI / 2 - f[0]);
                            break;
                        case 1:
                            d.makeRotationY(f[1]);
                            break;
                        case 2:
                            a.makeRotationZ(-f[2])
                    }
                }
                this.rotation.fromArray(f);
                this.matrix.identity();
                this.matrix.multiply(a);
                this.matrix.multiply(b);
                this.matrix.multiply(d);
                this.face2d && (this.mapviewer.manipulator.cachedMatrixOrientationZ = this.mapviewer.manipulator.orientation.z, this.mapviewer.manipulator.cachedMatrixForOrientation = this.matrix.clone());
                this.matrix.setPosition(this.position);
                this.matrixWorldNeedsUpdate = !0;
                this._dirty = !1
            }
        };
        return THREE.Billboard
    });
    define("com/visioglobe/web/poi/POI", ["com/visioglobe/web/poi/POIProxy", "com/visioglobe/web/helpers/CachedTexture", "com/visioglobe/web/helpers/Billboard"], function (a, b, d) {
        function e(e, g, f, l, m, n, q, p) {
            this.mapviewer = e._mapviewer;
            this.proxy = new a(this);
            this.addPoiVariables = e;
            this.parameters = g;
            if ("undefined" !== typeof f && "undefined" !== typeof l) {
                var r = e.MapviewerPrivate, v = new THREE.Euler;
                this.rotationObject = new THREE.Object3D;
                this.rotationObject.name = "rotationObject";
                this.rotationObject.matrixAutoUpdate =
                    !1;
                g.fixed ? (this.positionObject = new THREE.Object3D, this.positionObject.name = "options fixed", v.set(-Math.PI / 2, g.angle * Math.PI / 180, 0), this.rotationObject.rotation.copy(v), this.rotationObject.updateMatrix()) : (this.positionObject = new d({face2d: g.face2d}, this.mapviewer), this.positionObject.name = "options !fixed", v.set(0, 0, 0), (m || n || q) && f.cameraUpdatableObjects.push(this.positionObject));
                this.positionObject.matrixAutoUpdate = !1;
                g.position.z = g.position.z || 0;
                this.positionObject.position.copy(g.position);
                this.positionObject.position.add({
                    x: 0,
                    y: 0, z: r.zOffsetPOI
                });
                this.positionObject.add(this.rotationObject);
                this.positionObject.vg = {poi: g, meshes: {}, opacity: x};
                this.rotationObject.current_alignment = g.alignment;
                this.rotationObject.current_aspect = 0 !== g.scale.y ? g.scale.x / g.scale.y : 1;
                this.rotationObject.lastCameraOrientationZ = !1;
                this.rotationObject.dirty = !1;
                this.rotationObject._isFlipped = void 0;
                var u = this;
                this.rotationObject.updateMatrix = function () {
                    a:{
                        var a = e._mapviewer.manipulator.radius, b = e._mapviewer.manipulator.orientationNormalized.z,
                            d = u.parameters,
                            g = 0,
                            g = d.zoomScaleFast ? .02 * a * d.zoomScaleFactor : .15 * Math.sqrt(a) * d.zoomScaleFactor,
                            f = g !== d._zoomScale, k = b !== this.lastCameraOrientationZ;
                        if (this.dirty || k || 0 !== d.zoomScaleFactor && f) {
                            0 !== d.zoomScaleFactor && (this.dirty || f) && (d._zoomScale = g, g = {
                                x: d._zoomScale,
                                y: 1,
                                z: d._zoomScale
                            }, -1 !== d.width && -1 !== d.height ? ("undefined" !== typeof d.text && "" !== d.text && d.multiline && (f || u.shouldRecomputeLines(a)) && u.createMultiLineText(), u.getBoxScale() > d._zoomScale ? this.visible = !0 : this.visible = !1) : this.visible = !0, this.lastCameraRadius =
                                a, "undefined" !== typeof u.positionObject.vg.meshes.poi_text && 0 < u.positionObject.vg.meshes.poi_text.length ? this.current_position = u.updateTextMeshes() : "undefined" !== typeof u.positionObject.vg.meshes.poi_url && (this.current_position = jQuery.extend({}, u.positionObject.vg.meshes.poi_url.position)), this.current_position.x *= g.x, this.position.copy(new THREE.Vector3), this.position.x = -this.current_position.x / 2, this.position.x += d.alignment.x * this.current_position.x / 2, this.dirty = !0, this.scale.copy(g));
                            if (d.fixed &&
                                d.flip && (this.dirty || k)) {
                                this.lastCameraOrientationZ = b;
                                a = d._inverseAngleInRadians - this.lastCameraOrientationZ;
                                f = a > Math.PI || 0 > a && a > -Math.PI;
                                if (!this.dirty && f === this._isFlipped) break a;
                                this.dirty = !1;
                                this._isFlipped = f;
                                a = -this.current_position.x;
                                b = this.current_alignment;
                                f ? (f = 0, "undefined" !== typeof d.text && "" !== d.text && (f = d._textAspectRatio), "undefined" !== typeof d.url && "" !== d.url && (f += this.current_aspect), 0 === f && (f = 1), this.position.set(.5 * a * (b.x + 1), 0, a * b.y / f), this.rotation.set(-Math.PI / 2, (d.angle + 180) *
                                    Math.PI / 180, 0)) : (this.position.set(.5 * a * (1 - b.x), 0, 0), this.rotation.set(-Math.PI / 2, d.angle * Math.PI / 180, 0));
                                d = new THREE.Matrix4;
                                d.makeRotationFromEuler(this.rotation);
                                this.position.applyProjection(d)
                            }
                            this.dirty = !1
                        }
                        THREE.Object3D.prototype.updateMatrix.apply(this)
                    }
                };
                if (g.fixed && g.flip || 0 < g.zoomScaleFactor) this.rotationObject.matrixAutoUpdate = !1, (m || n || q) && f.cameraUpdatableObjects.push(this.rotationObject);
                var x = "undefined" !== typeof this.parameters.opacity ? this.parameters.opacity : this.mapviewer.computeOpacity(this.positionObject.position,
                    this.parameters, this.mapviewer.camera.position), r = new THREE.Vector3;
                if (q) this.setModel(g.model); else {
                    if (m) {
                        var w = new b(this.mapviewer, g.url, !0), z = this.mapviewer.plane_geometry,
                            x = new THREE.MeshBasicMaterial({
                                map: w,
                                color: 16777215,
                                side: THREE.DoubleSide,
                                transparent: !0,
                                depthWrite: !1,
                                depthTest: g.overlay ? !1 : this.mapviewer.useDepthWriteForPOIs,
                                opacity: x
                            }), x = new THREE.Mesh(z, x);
                        x.name = "poi_url";
                        x.matrixAutoUpdate = !1;
                        x.renderDepth = e.MapviewerPrivate.renderDepthPOI;
                        g.overlay && (x.renderDepth = e.MapviewerPrivate.renderDepthPOIOverlay);
                        this.positionObject.vg.meshes.poi_url = x;
                        null !== f && g.clickable && (x.vg = {
                            id: g.id,
                            poi: g,
                            originalColor: 16777215
                        }, f.pickables.push(x));
                        z = g.scale;
                        0 < g.zoomScaleFactor && (z = {x: 1, y: 1, z: 1});
                        r.x += .5 * z.x;
                        r.z += .5 * z.y * g.alignment.y;
                        x.position.copy(r);
                        r.x += .5 * z.x;
                        x.rotation.set(-Math.PI / 2, 0, 0);
                        x.scale.set(z.x, -z.y, 1);
                        x.updateMatrix();
                        this.rotationObject.add(x)
                    }
                    n && (g.multiline ? this.createMultiLineText() : (r = this.initText(g.text), this.parameters._textAspectRatio = r.aspectRatio, x = this.createTextMesh(this.parameters.text,
                        r, 0, 0), this.rotationObject.add(x), this.positionObject.vg.meshes.poi_text = [], this.positionObject.vg.meshes.poi_text.push(x)), r = this.updateTextMeshes())
                }
                -1 !== g.width && -1 !== g.height && (x = this.getBoxScale(), this.rotationObject.scale.copy({
                    x: x,
                    y: 1,
                    z: x
                }), r.x *= this.rotationObject.scale.x);
                x = new THREE.Matrix4;
                x.makeRotationFromEuler(v);
                this.rotationObject.current_position = r;
                this.rotationObject.position.x = -r.x / 2;
                this.rotationObject.position.x += g.alignment.x * r.x / 2;
                this.rotationObject.position.applyProjection(x);
                "undefined" !== typeof g.selector && "" !== g.selector && this.setSelector(g.selector);
                this.positionObject.updateMatrix();
                this.rotationObject.updateMatrix();
                l.add(this.positionObject);
                this.positionObject.updateMatrixWorld(!0);
                (m || q || n || p) && f.rampObjects.push(this.positionObject);
                this.updateVisibleObject();
                this.mapviewer.mustUpdateCameraObjects = !0;
                this.mapviewer.requestRedraw()
            }
        }

        e.prototype.constructor = e;
        e.prototype.vg = {poi: !0};
        e.prototype.updateVisibleObject = function () {
            this.visibleObject = "undefined" !== typeof this.rotationObject ?
                this.rotationObject : this.positionObject;
            var a = this.parameters;
            !1 === this.parameters.visible && this.visibleObject && this.visibleObject.traverse(function (b) {
                b.visible = a.visible
            })
        };
        e.prototype.getOpacity = function () {
            return this.parameters && this.parameters.opacity
        };
        e.prototype.setOpacity = function (a) {
            var b = this.parameters, d = this.mapviewer;
            b.opacity = a;
            if ("number" !== typeof a) {
                a = this.mapviewer.computeOpacity(this.positionObject.position, this.parameters, this.mapviewer.camera.position);
                delete b.opacity;
                var e = this.mapviewer.getFloor(this.parameters.floor),
                    b = e.getLOD(this.parameters.lod);
                b || (b = e.floorContentLOD);
                e = b.rampObjects.indexOf(this.positionObject);
                -1 === e && b.rampObjects.push(this.positionObject)
            } else e = this.mapviewer.getFloor(this.parameters.floor), b = e.getLOD(this.parameters.lod), b || (b = e.floorContentLOD), e = b.rampObjects.indexOf(this.positionObject), -1 !== e && b.rampObjects.splice(e, 1);
            this.positionObject.traverse(function (b) {
                if (b.material && (b.material.opacity = a, b = b.material.materials)) for (var d = 0, e = b.length; d < e; ++d) b[d].opacity = a
            });
            d.requestRedraw()
        };
        e.prototype.getVisible = function () {
            return this.parameters && this.parameters.visible
        };
        e.prototype.setVisible = function (a) {
            var b = this.parameters, d = this.visibleObject, e = this.mapviewer;
            null !== b && b.visible !== a && (b.visible = a, d && d.traverse(function (a) {
                a.visible = b.visible
            }), e.mustUpdateCameraObjects = !0, e.requestRedraw())
        };
        e.prototype.realRemove = function (a) {
            var b = this.proxy.publicPOI, d = this.mapviewer, e = this.parameters, f = this.positionObject,
                n = this.rotationObject;
            a && this.addPoiVariables.POIFactory.removeFromPois(d,
                e.id, b);
            if (f || n) {
                "undefined" !== typeof e._measuringCanvas && (e._measuringCanvas = null);
                var q = d.getFloor(e.floor), b = q.getLOD(e.lod);
                null === b && (b = q.floorContentLOD);
                var q = f.vg.meshes, p = b.pickables, r, v;
                for (v in q) if ("poi_text" === v) q[v].forEach(function (a) {
                    r = p.indexOf(a);
                    -1 !== r && p.splice(r, 1);
                    a.geometry && a.geometry.vg && a.geometry.vg.permanent || a.geometry.dispose()
                }); else {
                    var u = q[v];
                    r = p.indexOf(u);
                    -1 !== r && p.splice(r, 1);
                    u.geometry && u.geometry.vg && u.geometry.vg.permanent || u.geometry.dispose()
                }
                r = d.pois_with_selector.indexOf(e);
                -1 !== r && (jQuery(d.pois_with_selector[r].selector).hide(), d.pois_with_selector.splice(r, 1));
                if ("undefined" === typeof e.model || a) {
                    var x = this.addPoiVariables;
                    setTimeout(function (a, b, d) {
                        return function () {
                            x.POIFactory.removeMaterial(a, b, d)
                        }
                    }(d, e, f), 0)
                }
                "undefined" !== typeof f.parent && f.parent.remove(f);
                void 0 !== n && ("undefined" !== typeof n.parent && n.parent.remove(f), r = b.cameraUpdatableObjects.indexOf(n), -1 !== r && b.cameraUpdatableObjects.splice(r, 1));
                r = b.cameraUpdatableObjects.indexOf(f);
                -1 !== r && b.cameraUpdatableObjects.splice(r,
                    1);
                r = b.rampObjects.indexOf(f);
                -1 !== r && b.rampObjects.splice(r, 1);
                this.positionObject = null
            }
        };
        e.prototype.remove = function () {
            null !== this.parameters && (this.realRemove(!0), this.mapviewer.requestRedraw(), this.parameters = this.mapviewer = null)
        };
        e.prototype.options = function (b, d, e) {
            if (null !== this.parameters) {
                if ("undefined" === typeof b) return a.getPublicParameters(this.parameters);
                if ("object" === typeof b) if (this.parameters._empty) {
                    var f = jQuery.extend({}, this.parameters);
                    Object.keys(b).forEach(function (a) {
                        "undefined" ===
                        typeof a ? delete f[a] : f[a] = b[a]
                    });
                    this.addPoiVariables.POIFactory.createPOI(this.addPoiVariables, f, this.proxy.publicPOI);
                    this.realRemove(!1)
                } else Object.keys(b).forEach(function (a) {
                    this.setParameter(a, b[a])
                }, this); else if ("string" === typeof b) {
                    if ("undefined" === typeof d && a.isPublicParameter(b)) return this.getParameter(b);
                    this.parameters._empty ? (f = jQuery.extend({}, this.parameters), f[b] = d, this.realRemove(!1), this.addPoiVariables.POIFactory.createPOI(this.addPoiVariables, f, this.proxy.publicPOI)) : this.setParameter(b,
                        d)
                }
            }
        };
        e.prototype.setParameter = function (a, b) {
            switch (a) {
                case "position":
                    this.setPosition(b);
                    break;
                case "text":
                    this.setText(b);
                    break;
                case "multiline":
                    this.setMultiline(b);
                    break;
                case "visible":
                    this.setVisible(b);
                    break;
                case "opacity":
                    this.setOpacity(b);
                    break;
                case "textTextureHeight":
                    this.setTextTextureHeight(b);
                    break;
                case "color":
                    this.setColor(b);
                    break;
                case "family":
                    this.setFamily(b);
                    break;
                case "url":
                    this.setURL(b);
                    break;
                case "model":
                    this.setModel(b);
                    break;
                case "selector":
                    this.setSelector(b);
                    break;
                case "alignment":
                    this.setAlignment(b);
                    break;
                case "scale":
                    this.setScale(b);
                    break;
                case "zoomScaleFactor":
                    this.setZoomScaleFactor(b);
                    break;
                case "zoomScaleFast":
                    this.setZoomScaleFast(b);
                    break;
                case "iconScale":
                case "icon_scale":
                    console.log('Deprecated option. It will be taken into account if there is no text. Otherwise, "scale" option will be used.');
                    "undefined" !== typeof this.parameters.text && "" !== this.parameters.text || this.setScale(b);
                    break;
                case "floor":
                    this.setFloor(b);
                    break;
                case "id":
                    this.setID(b);
                    break;
                case "visibilityRampStartVisible":
                    this.parameters.visibilityRampStartVisible =
                        b;
                    break;
                case "visibilityRampFullyVisible":
                    this.parameters.visibilityRampFullyVisible = b;
                    break;
                case "visibilityRampStartInvisible":
                    this.parameters.visibilityRampStartInvisible = b;
                    break;
                case "visibilityRampFullyInvisible":
                    this.parameters.visibilityRampFullyInvisible = b;
                    break;
                case "onObjectMouseOver":
                    this.parameters.onObjectMouseOver = b;
                    break;
                case "onObjectMouseOut":
                    this.parameters.onObjectMouseOut = b;
                    break;
                case "onObjectMouseUp":
                    this.parameters.onObjectMouseUp = b;
                    break;
                case "clickable":
                    this.setClickable(b);
                    break;
                case "fixed":
                    this.setFixed(b);
                    break;
                case "angle":
                    this.setAngle(b);
                    break;
                case "heading":
                    this.setHeading(b);
                    break;
                case "width":
                    this.setWidth(b);
                    break;
                case "height":
                    this.setHeight(b);
                    break;
                case "overlay":
                    this.setOverlay(b);
                    break;
                case "flip":
                    this.setFlip(b);
                    break;
                case "face2d":
                    this.setFace2d(b)
            }
        };
        e.prototype.getParameter = function (a) {
            return this.parameters && this.parameters[a]
        };
        e.prototype.setPosition = function (a) {
            var b = a || {x: 0, y: 0, z: 0};
            b.z = a.z || 0;
            this.parameters.position = b;
            "undefined" !== typeof this.positionObject &&
            (this.positionObject.position.copy(b), this.positionObject._dirty = !0, this.positionObject.updateMatrix(), this.positionObject.updateMatrixWorld(), this.mapviewer.requestRedraw())
        };
        e.prototype.initText = function (a) {
            a = this.mapviewer.textGenerator.generateTextNoAtlas(a, this.parameters);
            a.texture.vg.nbRefs++;
            var b = "undefined" !== typeof this.parameters.opacity ? this.parameters.opacity : this.mapviewer.computeOpacity(this.positionObject.position, this.parameters, this.mapviewer.camera.position);
            a.material = new THREE.MeshBasicMaterial({
                map: a.texture,
                color: 16777215,
                side: THREE.DoubleSide,
                transparent: !0,
                depthWrite: !1,
                depthTest: this.parameters.overlay ? !1 : this.mapviewer.useDepthWriteForPOIs,
                opacity: b
            });
            a.texture = null;
            return a
        };
        e.prototype.pushToLists = function () {
            var a = this.mapviewer.getFloor(this.parameters.floor);
            if (a) {
                var b = a.getLOD(this.parameters.lod);
                b || (b = a.floorContentLOD);
                this.parameters.fixed || -1 === b.cameraUpdatableObjects.indexOf(this.positionObject) && b.cameraUpdatableObjects.push(this.positionObject);
                (this.parameters.fixed && this.parameters.flip ||
                    0 < this.parameters.zoomScaleFactor) && -1 === b.cameraUpdatableObjects.indexOf(this.rotationObject) && b.cameraUpdatableObjects.push(this.rotationObject);
                ("undefined" !== typeof this.parameters.text && "" !== this.parameters.text || "undefined" !== typeof this.parameters.url && "" !== this.parameters.url) && -1 === b.rampObjects.indexOf(this.positionObject) && b.rampObjects.push(this.positionObject)
            }
        };
        e.prototype.getBoxScale = function () {
            var a = this.parameters._textAspectRatio, b = 1;
            "undefined" !== typeof this.positionObject.vg.meshes.poi_text &&
            1 < this.positionObject.vg.meshes.poi_text.length && (b = this.positionObject.vg.meshes.poi_text.length, this.positionObject.vg.meshes.poi_text.forEach(function (b) {
                a = Math.max(a, b.userData.aspectRatio)
            }));
            var d = b, e = b = 0;
            "undefined" !== typeof this.parameters.url && "" !== this.parameters.url && (e = b = 1, 0 === this.parameters.zoomScaleFactor && (b = this.parameters.scale.x, e = this.parameters.scale.y));
            "undefined" !== typeof this.parameters.text && "" !== this.parameters.text && (0 === this.parameters.zoomScaleFactor && (a *= this.parameters.scale.x,
                d *= this.parameters.scale.y), b += a, e = Math.max(e, d));
            d = 1;
            0 < b && (d = this.parameters.width / b);
            0 < e && e * d > this.parameters.height && (d = this.parameters.height / e);
            return d
        };
        e.prototype.shouldRecomputeLines = function (a) {
            var b = this.parameters.text.split(" ").length;
            if (2 > b || "undefined" === typeof this.positionObject.vg.meshes.poi_text) return !1;
            var d = this.positionObject.vg.meshes.poi_text.length;
            if (a === this.rotationObject.lastCameraRadius || a > this.rotationObject.lastCameraRadius && d === b || a < this.rotationObject.lastCameraRadius &&
                1 === d) return !1;
            var e = 0;
            this.positionObject.vg.meshes.poi_text.forEach(function (a) {
                a.userData.aspectRatio > e && (e = a.userData.aspectRatio, currentLongestLine = a.userData.text)
            });
            this.parameters.url && (e += this.parameters.scale.x / this.parameters.scale.y);
            b = this.getBoxScale();
            0 !== this.parameters.zoomScaleFactor && (b = this.parameters._zoomScale);
            return e * b < this.parameters.width && a > this.rotationObject.lastCameraRadius ? !1 : !0
        };
        var f = function (a, b) {
            var d = a.split(" ");
            if (2 > b || d.length < b) return [];
            for (var e = [], f = a.length /
                b, n = d[0], q = 1; q < d.length; q++) {
                var p = n.length + d[q].length + 1;
                n.length > f || p > 1.5 * f ? (e.push(n), n = d[q]) : n += " " + d[q]
            }
            e.push(n);
            return e
        };
        e.prototype.createMultiLineText = function () {
            var a = 0;
            this.parameters.url && (a += this.parameters.scale.x / this.parameters.scale.y);
            var b = this.mapviewer.textGenerator.measureText(this.parameters.text, this.parameters),
                d = a + b.width / b.height, e = [this.parameters.text], m = this.parameters.text.split(" ").length,
                n = 1, q = b.width, p = this.parameters.scale.x;
            0 !== this.parameters.zoomScaleFactor &&
            (p = this.parameters._zoomScale);
            for (var r = d; p * r > this.parameters.width && n < m;) {
                var v = f(this.parameters.text, ++n);
                if (0 === v.length) break;
                r = d = q = 0;
                e.splice(0, e.length);
                for (var u = 0; u < v.length; u++) b = this.mapviewer.textGenerator.measureText(v[u], this.parameters), r = Math.max(r, a + b.width / b.height), q = Math.max(q, b.width), d += b.height, e.push(v[u]);
                d = (a + q) / d
            }
            m = !0;
            if ("undefined" !== typeof this.positionObject.vg.meshes.poi_text && 0 < this.positionObject.vg.meshes.poi_text.length) {
                if (this.positionObject.vg.meshes.poi_text.length ===
                    e.length) for (m = !1, a = 0; a < e.length; a++) if (this.positionObject.vg.meshes.poi_text[a].userData.text !== e[a]) {
                    m = !0;
                    break
                }
                m && (this.positionObject.vg.meshes.poi_text.forEach(function (a) {
                    a.material.map.vg.nbRefs--;
                    this.mapviewer.textGenerator.disposeTexture(a.material.map);
                    this.rotationObject.remove(a)
                }, this), this.positionObject.vg.meshes.poi_text.splice(0, this.positionObject.vg.meshes.poi_text.length))
            } else this.positionObject.vg.meshes.poi_text = [];
            if (m) {
                for (a = 0; a < e.length; a++) b = this.initText(e[a]), b.text =
                    e[a], m = this.createTextMesh(b.text, b, 0, .5 * (e.length - 1) - a), this.rotationObject.add(m), this.positionObject.vg.meshes.poi_text.push(m);
                this.parameters._textAspectRatio = d
            }
        };
        e.prototype.createTextMesh = function (a, b, d, e) {
            var f = new THREE.Mesh(b.geometry, b.material);
            f.name = "poi_text";
            f.userData = {
                text: a,
                width: b.width,
                height: b.height,
                aspectRatio: b.aspectRatio,
                horizontalOffset: d,
                verticalOffset: e
            };
            f.matrixAutoUpdate = !1;
            f.renderDepth = this.addPoiVariables.MapviewerPrivate.renderDepthPOI;
            this.parameters.overlay &&
            (f.renderDepth = this.addPoiVariables.MapviewerPrivate.renderDepthPOIOverlay);
            a = this.mapviewer.getFloor(this.parameters.floor);
            b = a.getLOD(this.parameters.lod);
            b || (b = a.floorContentLOD);
            null !== b && this.parameters.clickable && (f.vg = {
                id: this.parameters.id,
                poi: this.parameters,
                originalColor: 16777215
            }, b.pickables.push(f));
            return f
        };
        e.prototype.updateTextMeshes = function () {
            var a = new THREE.Vector3, b = this.parameters._textAspectRatio;
            1 < this.positionObject.vg.meshes.poi_text.length && this.positionObject.vg.meshes.poi_text.forEach(function (a) {
                b =
                    Math.max(b, a.userData.aspectRatio)
            });
            0 === this.parameters.zoomScaleFactor ? (a.x += .5 * this.parameters.scale.x * b, a.z += .5 * this.parameters.scale.y * this.parameters.alignment.y, "undefined" !== typeof this.parameters.url && "" !== this.parameters.url && (a.x += this.parameters.scale.x), this.positionObject.vg.meshes.poi_text.forEach(function (b) {
                var d = jQuery.extend({}, a);
                d.x += this.parameters.scale.x * b.userData.horizontalOffset;
                d.z += this.parameters.scale.y * b.userData.verticalOffset;
                b.position.copy(d);
                b.rotation.set(-Math.PI /
                    2, 0, 0);
                b.scale.copy({x: b.userData.aspectRatio * this.parameters.scale.x, y: -this.parameters.scale.y, z: 1});
                b.updateMatrix()
            }, this), a.x += .5 * this.parameters.scale.x * b) : (a.x += .5 * b, a.z += .5 * this.parameters.alignment.y, "undefined" !== typeof this.parameters.url && "" !== this.parameters.url && (a.x += 1), this.positionObject.vg.meshes.poi_text.forEach(function (b) {
                var d = jQuery.extend({}, a);
                d.x += b.userData.horizontalOffset;
                d.z += b.userData.verticalOffset;
                b.position.copy(d);
                b.rotation.set(-Math.PI / 2, 0, 0);
                b.scale.copy({
                    x: b.userData.aspectRatio,
                    y: -1, z: 1
                });
                b.updateMatrix()
            }, this), a.x += .5 * b);
            return a
        };
        e.prototype.setText = function (a, b) {
            if (("string" !== typeof a || "" === a) && "undefined" !== typeof this.positionObject.vg.meshes.poi_text && 0 < this.positionObject.vg.meshes.poi_text.length) {
                if (delete this.parameters.text, this.positionObject.vg.meshes.poi_text.forEach(function (a) {
                        this.rotationObject.remove(a)
                    }, this), this.positionObject.vg.meshes.poi_text.splice(0, this.positionObject.vg.meshes.poi_text.length), delete this.positionObject.vg.meshes.poi_text,
                    "undefined" !== typeof this.parameters.url && "" !== this.parameters.url) if (this.mapviewer.vgnobatch || this.mapviewer.vgnobatchicon || this.mapviewer.vgnobatchfacing && !this.parameters.fixed) this.rotationObject.dirty = !0, this.setURL(this.parameters.url); else {
                    this.realRemove(!1);
                    this.addPoiVariables.POIFactory.createPOI(this.addPoiVariables, this.parameters, this.proxy.publicPOI);
                    return
                }
            } else {
                if ("undefined" !== typeof this.parameters.model && "" !== this.parameters.model) {
                    console.log("Cannot set text on a POI initialized with a model.");
                    return
                }
                if (this.parameters.multiline) this.parameters.text = a.replace(/\s+/g, " ").trim(), this.createMultiLineText(), "undefined" !== typeof this.positionObject.vg.meshes.poi_text && 0 < this.positionObject.vg.meshes.poi_text.length && this.pushToLists(); else if (this.parameters.text !== a || !this.parameters.multiline && "undefined" !== typeof this.positionObject.vg.meshes.poi_text && 1 < this.positionObject.vg.meshes.poi_text.length) {
                    this.parameters.text = a;
                    var d = this.initText(this.parameters.text);
                    this.parameters._textAspectRatio =
                        d.aspectRatio;
                    "undefined" !== typeof this.positionObject.vg.meshes.poi_text && 0 < this.positionObject.vg.meshes.poi_text.length && (this.positionObject.vg.meshes.poi_text.forEach(function (a) {
                        a.material.map.vg.nbRefs--;
                        this.mapviewer.textGenerator.disposeTexture(a.material.map);
                        this.rotationObject.remove(a)
                    }, this), this.positionObject.vg.meshes.poi_text.splice(0, this.positionObject.vg.meshes.poi_text.length));
                    d = this.createTextMesh(this.parameters.text, d, 0, 0);
                    this.rotationObject.add(d);
                    this.positionObject.vg.meshes.poi_text =
                        [];
                    this.positionObject.vg.meshes.poi_text.push(d);
                    this.pushToLists()
                }
                d = this.updateTextMeshes();
                if (0 === this.parameters.zoomScaleFactor) {
                    if (-1 !== this.parameters.width && -1 !== this.parameters.height) {
                        var e = this.getBoxScale();
                        this.rotationObject.scale.copy({x: e, y: 1, z: e});
                        d.x *= this.rotationObject.scale.x
                    }
                    this.rotationObject.current_position = d;
                    this.rotationObject.position.copy(new THREE.Vector3);
                    this.rotationObject.position.x = -this.rotationObject.current_position.x / 2;
                    this.rotationObject.position.x += this.parameters.alignment.x *
                        this.rotationObject.current_position.x / 2
                }
                this.rotationObject.dirty = !0;
                this.rotationObject.updateMatrix()
            }
            this.positionObject.updateMatrix();
            this.positionObject.updateMatrixWorld(!0);
            this.mapviewer.mustUpdateCameraObjects = !0;
            this.mapviewer.requestRedraw()
        };
        e.prototype.setMultiline = function (a) {
            "boolean" === typeof a && this.parameters.multiline !== a && (this.parameters.multiline = a, "undefined" !== typeof this.parameters.text && "" !== this.parameters.text && this.setText(this.parameters.text))
        };
        e.prototype.setTextTextureHeight =
            function (a) {
                "number" === typeof a && this.parameters.textTextureHeight !== a && (this.parameters.textTextureHeight = a, "undefined" !== typeof this.parameters.text && "" !== this.parameters.text && (this.positionObject.vg.meshes.poi_text.forEach(function (a) {
                    var b = this.initText(a.userData.text);
                    a.material.map.vg.nbRefs--;
                    this.mapviewer.textGenerator.disposeTexture(a.material.map);
                    "undefined" !== typeof a && (a.material = b.material)
                }, this), this.mapviewer.requestRedraw()))
            };
        e.prototype.setColor = function (a) {
            "string" === typeof a &&
            this.parameters.color !== a && null !== a.match("#[0-9A-Fa-f]{6}") && (this.parameters.color = a, "undefined" !== typeof this.parameters.text && "" !== this.parameters.text && (this.positionObject.vg.meshes.poi_text.forEach(function (a) {
                var b = this.initText(a.userData.text);
                a.material.map.vg.nbRefs--;
                this.mapviewer.textGenerator.disposeTexture(a.material.map);
                "undefined" !== typeof a && (a.material = b.material)
            }, this), this.mapviewer.requestRedraw()))
        };
        e.prototype.setFamily = function (a) {
            "string" === typeof a && this.parameters.family !==
            a && (this.parameters.family = a, "undefined" !== typeof this.parameters.text && "" !== this.parameters.text && (this.positionObject.vg.meshes.poi_text.forEach(function (a) {
                var b = this.initText(a.userData.text);
                a.material.map.vg.nbRefs--;
                this.mapviewer.textGenerator.disposeTexture(a.material.map);
                "undefined" !== typeof a && (a.material = b.material)
            }, this), this.mapviewer.requestRedraw()))
        };
        e.prototype.setURL = function (a) {
            if ("undefined" !== typeof a && "" !== a || "undefined" === typeof this.positionObject.vg.meshes.poi_url) {
                if ("undefined" !==
                    typeof this.parameters.model && "" !== this.parameters.model) {
                    console.log("Cannot set image on a POI initialized with a model.");
                    return
                }
                var d = new THREE.Vector3, e = this.rotationObject.getObjectByName("poi_url"),
                    f = "undefined" !== typeof e;
                if (!f || this.parameters.url !== a) {
                    if ((e = this.mapviewer.textures[a]) && e.loaded) this.parameters.url = a, e = new b(this.mapviewer, this.parameters.url, !0); else {
                        new b(this.mapviewer, a, !0, function (a, b) {
                            return function (d) {
                                b.options("url", a)
                            }
                        }(a, this));
                        return
                    }
                    var m = "undefined" !== typeof this.parameters.opacity ?
                        this.parameters.opacity : this.mapviewer.computeOpacity(this.positionObject.position, this.parameters, this.mapviewer.camera.position);
                    a = this.mapviewer.plane_geometry;
                    m = new THREE.MeshBasicMaterial({
                        map: e,
                        color: 16777215,
                        side: THREE.DoubleSide,
                        transparent: !0,
                        depthWrite: !1,
                        depthTest: this.parameters.overlay ? !1 : this.mapviewer.useDepthWriteForPOIs,
                        opacity: m
                    });
                    e = this.positionObject.vg.meshes.poi_url;
                    "undefined" === typeof e ? (e = new THREE.Mesh(a, m), e.name = "poi_url", e.matrixAutoUpdate = !1, e.renderDepth = this.addPoiVariables.MapviewerPrivate.renderDepthPOI,
                    this.parameters.overlay && (e.renderDepth = this.addPoiVariables.MapviewerPrivate.renderDepthPOIOverlay), this.parameters.clickable && (e.vg = {
                        id: this.parameters.id,
                        poi: this.parameters,
                        originalColor: 16777215
                    }, a = this.mapviewer.getFloor(this.parameters.floor), m = a.getLOD(this.parameters.lod), m || (m = a.floorContentLOD), m.pickables.push(e)), this.positionObject.vg.meshes.poi_url = e, this.rotationObject.add(e)) : e.material = m;
                    f || this.pushToLists()
                }
                f = this.parameters.scale;
                0 < this.parameters.zoomScaleFactor && (f = {
                    x: 1, y: 1,
                    z: 1
                });
                d.x += .5 * f.x;
                d.z += .5 * f.y * this.parameters.alignment.y;
                e.position.copy(d);
                d.x += .5 * f.x;
                e.scale.set(f.x, -f.y, 1);
                e.rotation.set(-Math.PI / 2, 0, 0);
                e.updateMatrix();
                "undefined" !== typeof this.positionObject.vg.meshes.poi_text && 0 < this.positionObject.vg.meshes.poi_text.length && (d = this.updateTextMeshes());
                0 === this.parameters.zoomScaleFactor && (-1 !== this.parameters.width && -1 !== this.parameters.height && (f = this.getBoxScale(), this.rotationObject.scale.copy({
                    x: f,
                    y: 1,
                    z: f
                }), d.x *= this.rotationObject.scale.x), this.rotationObject.current_position =
                    d, this.rotationObject.position.x = -d.x / 2, this.rotationObject.position.x += this.parameters.alignment.x * d.x / 2);
                this.rotationObject.dirty = !0;
                this.rotationObject.updateMatrix()
            } else if (this.rotationObject.remove(this.positionObject.vg.meshes.poi_url), delete this.parameters.url, delete this.positionObject.vg.meshes.poi_url, "undefined" !== typeof this.parameters.text && "" !== this.parameters.text) if (this.mapviewer.vgnobatch || this.parameters._vgnobatch) this.rotationObject.dirty = !0, this.setText(this.parameters.text);
            else {
                this.realRemove(!1);
                this.addPoiVariables.POIFactory.createPOI(this.addPoiVariables, this.parameters, this.proxy.publicPOI);
                return
            }
            this.positionObject.updateMatrix();
            this.positionObject.updateMatrixWorld(!0);
            this.mapviewer.mustUpdateCameraObjects = !0;
            this.mapviewer.requestRedraw()
        };
        e.prototype.setSelector = function (a) {
            if ("string" !== typeof a || "" === a) a = jQuery(this.parameters.selector), a.detach(); else {
                this.parameters.selector = a;
                a = jQuery(this.parameters.selector);
                var b = {
                        position: "absolute", left: "0px",
                        top: "0px"
                    },
                    d = "undefined" !== typeof this.parameters.opacity ? this.parameters.opacity : this.mapviewer.computeOpacity(this.positionObject.position, this.parameters, this.mapviewer.camera.position);
                0 === d ? a.hide() : (b.opacity = d, a.show());
                a.detach().appendTo(this.addPoiVariables.container);
                a.css(b);
                this.mapviewer.pois_with_selector.push(this.parameters)
            }
        };
        e.prototype.setModel = function (a) {
            if ("string" !== typeof a || "" === a) this.rotationObject.remove(this.rotationObject.getObjectByName("poi_model")), delete this.parameters.model;
            else {
                "undefined" !== typeof this.parameters.url && "" !== this.parameters.url && this.setURL("");
                "undefined" !== typeof this.parameters.text && "" !== this.parameters.text && this.setText("");
                var b = "undefined" !== typeof this.rotationObject.getObjectByName("poi_model");
                if (!b || this.parameters.model !== a) {
                    this.rotationObject.remove();
                    this.parameters.model = a;
                    var d = this.mapviewer;
                    if ("undefined" === typeof this.mapviewer.models[this.parameters.model]) {
                        var e = {
                            url: this.parameters.model, loaded: !1, geometry: null, materials: null,
                            bbox: null, pending: []
                        };
                        this.mapviewer.models[this.parameters.model] = e;
                        this.mapviewer.loaderStatistics.models++;
                        jQuery.ajax(this.parameters.model, {crossDomain: !0, dataType: "json"}).done(function (b) {
                            d.loaderStatistics.models--;
                            if ("undefined" === typeof b.metadata || "undefined" !== typeof b.metadata.formatVersion && 3.1 === b.metadata.formatVersion) {
                                var g = new THREE.JSONLoader;
                                g.imageLoader.manager.onLoad = d.requestRedraw.bind(d);
                                g.crossOrigin = "";
                                var f = g.extractUrlBase(a), g = g.parse(b, f);
                                e.loaded = !0;
                                e.geometry = g.geometry;
                                e.materials = g.materials;
                                e.version = b.metadata.formatVersion;
                                Object.keys(e.materials).forEach(function (a) {
                                    e.materials[a].map.needsUpdate = !0
                                });
                                Object.keys(e.pending).forEach(function (a) {
                                    e.pending[a](e)
                                })
                            } else g = new THREE.SceneLoader, g.crossOrigin = "", g.parse(b, function (a) {
                                    e.loaded = !0;
                                    e.result = a;
                                    e.version = b.metadata.version ? b.metadata.version : b.metadata.formatVersion;
                                    a = e.result.scene;
                                    a.updateMatrix();
                                    a.matrixAutoUpdate = !1;
                                    a.traverse(function (a) {
                                        a.updateMatrix();
                                        a.matrixAutoUpdate = !1
                                    });
                                    Object.keys(e.pending).forEach(function (a) {
                                        e.pending[a](e)
                                    })
                                },
                                a)
                        }).fail(function () {
                            d.loaderStatistics.models--
                        })
                    }
                    var f = this.mapviewer.getFloor(this.parameters.floor), n = f.getLOD(this.parameters.lod);
                    null === n && (n = f.floorContentLOD);
                    f = "undefined" !== typeof this.parameters.opacity ? this.parameters.opacity : this.mapviewer.computeOpacity(this.positionObject.position, this.parameters, this.mapviewer.camera.position);
                    e = this.mapviewer.models[this.parameters.model];
                    if (e.loaded) this.addPoiVariables.POIFactory.onModelLoaded(this.mapviewer, e, this.parameters, f, this.rotationObject,
                        n); else {
                        var q = this;
                        e.pending.push(function (a, b, e, g, f) {
                            return function () {
                                q.addPoiVariables.POIFactory.onModelLoaded(d, a, b, e, g, f)
                            }
                        }(e, this.parameters, f, this.rotationObject, n))
                    }
                    b || this.pushToLists()
                }
                b = new THREE.Vector3;
                -1 !== this.parameters.width && -1 !== this.parameters.height && (n = this.getBoxScale(), this.rotationObject.scale.copy({
                    x: n,
                    y: 1,
                    z: n
                }));
                this.rotationObject.current_position = b;
                this.rotationObject.position.x = -b.x / 2;
                this.rotationObject.position.x += this.parameters.alignment.x * b.x / 2;
                this.rotationObject.dirty =
                    !0;
                this.rotationObject.updateMatrix()
            }
            this.positionObject.updateMatrix();
            this.positionObject.updateMatrixWorld(!0);
            this.mapviewer.mustUpdateCameraObjects = !0;
            this.mapviewer.requestRedraw()
        };
        e.prototype.setAlignment = function (a) {
            "object" === typeof a && a.hasOwnProperty("x") && a.hasOwnProperty("y") && (this.parameters.alignment = a, this.rotationObject.current_alignment = a, "undefined" !== typeof this.parameters.model && "" !== this.parameters.model ? this.setModel(this.parameters.model) : ("undefined" !== typeof this.parameters.url &&
            "" !== this.parameters.url && this.setURL(this.parameters.url), "undefined" !== typeof this.parameters.text && "" !== this.parameters.text && this.setText(this.parameters.text)))
        };
        e.prototype.setScale = function (a) {
            var b = a;
            "number" === typeof a && (b = {x: a, y: a, z: a});
            "object" === typeof b && this.parameters.scale !== b && (this.parameters.scale = b, "undefined" !== typeof this.parameters.url && "" !== this.parameters.url && this.setURL(this.parameters.url), "undefined" !== typeof this.parameters.text && "" !== this.parameters.text && this.setText(this.parameters.text))
        };
        e.prototype.setZoomScaleFactor = function (a) {
            if (!("number" !== typeof a || this.parameters.zoomScaleFactor === a || 0 > a)) {
                this.parameters.zoomScaleFactor = a;
                var b = this.mapviewer.getFloor(this.parameters.floor);
                a = b.getLOD(this.parameters.lod);
                a || (a = b.floorContentLOD);
                0 < this.parameters.zoomScaleFactor ? -1 === a.cameraUpdatableObjects.indexOf(this.rotationObject) && a.cameraUpdatableObjects.push(this.rotationObject) : (this.parameters._zoomScale = 0, this.parameters.fixed && !this.parameters.flip && (b = a.cameraUpdatableObjects.indexOf(this.rotationObject),
                -1 !== b && a.cameraUpdatableObjects.splice(b, 1)));
                "undefined" !== typeof this.parameters.url && "" !== this.parameters.url && this.setURL(this.parameters.url);
                "undefined" !== typeof this.parameters.text && "" !== this.parameters.text && this.setText(this.parameters.text);
                this.rotationObject.updateMatrix();
                this.mapviewer.mustUpdateCameraObjects = !0;
                this.mapviewer.requestRedraw()
            }
        };
        e.prototype.setZoomScaleFast = function (a) {
            "boolean" === typeof a && this.parameters.zoomScaleFast !== a && (this.parameters.zoomScaleFast = a, this.rotationObject.updateMatrix(),
                this.mapviewer.mustUpdateCameraObjects = !0, this.mapviewer.requestRedraw())
        };
        e.prototype.setFloor = function (a) {
            if ("string" === typeof a && "" !== a && this.parameters.floor !== a) {
                this.positionObject.parent.remove(this.positionObject);
                this.parameters.floor = a;
                var b = this.mapviewer.scene;
                a = this.mapviewer.getFloor(this.parameters.floor);
                null === a && (a = this.mapviewer.getFloor(this.mapviewer.currentFloorName));
                if (null !== a) {
                    a = "undefined" !== typeof this.parameters.lod ? a.getLOD(this.parameters.lod) : a.floorContentLOD;
                    if (!this.parameters.overlay &&
                        null === a) return;
                    b = a.contentNode
                }
                b.add(this.positionObject)
            }
        };
        e.prototype.setID = function (a) {
            if ("string" === typeof a && this.parameters.id !== a) if (this.setClickable(!1), this.addPoiVariables.POIFactory.removeFromPois(this.mapviewer, this.parameters.id, this.proxy.publicPOI), "" === a) {
                delete this.parameters.id;
                for (var b in this.positionObject.vg.meshes) "poi_text" === b ? this.positionObject.vg.meshes[b].forEach(function (a) {
                    a.vg.id = ""
                }) : this.positionObject.vg.meshes[b].vg.id = ""
            } else {
                this.addPoiVariables.POIFactory.addToPois(this.mapviewer,
                    a, this.proxy.publicPOI);
                this.parameters.id = a;
                for (b in this.positionObject.vg.meshes) "poi_text" === b ? this.positionObject.vg.meshes[b].forEach(function (b) {
                    b.vg.id = a
                }) : this.positionObject.vg.meshes[b].vg.id = a;
                this.setClickable(!0)
            }
        };
        e.prototype.setClickable = function (a) {
            if ("boolean" === typeof a && this.parameters.clickable !== a) {
                this.parameters.clickable = a;
                var b = this.mapviewer.getFloor(this.parameters.floor).getLOD(this.parameters.lod);
                if (null !== b) if (this.parameters.clickable) for (var d in this.positionObject.vg.meshes) "poi_text" ===
                d ? this.positionObject.vg.meshes[d].forEach(function (a) {
                    b.pickables.push(a)
                }) : (a = this.positionObject.vg.meshes[d], b.pickables.push(a)); else for (d in this.positionObject.vg.meshes) "poi_text" === d ? this.positionObject.vg.meshes[d].forEach(function (a) {
                    a = b.pickables.indexOf(a);
                    -1 !== a && b.pickables.splice(a, 1)
                }) : (a = this.positionObject.vg.meshes[d], a = b.pickables.indexOf(a), -1 !== a && b.pickables.splice(a, 1))
            }
        };
        e.prototype.setWidth = function (a) {
            "number" === typeof a && this.parameters.width !== a && (this.parameters.width =
                a, "undefined" !== typeof this.parameters.url && "" !== this.parameters.url && this.setURL(this.parameters.url), "undefined" !== typeof this.parameters.text && "" !== this.parameters.text && this.setText(this.parameters.text))
        };
        e.prototype.setHeight = function (a) {
            "number" === typeof a && this.parameters.height !== a && (this.parameters.height = a, "undefined" !== typeof this.parameters.url && "" !== this.parameters.url && this.setURL(this.parameters.url), "undefined" !== typeof this.parameters.text && "" !== this.parameters.text && this.setText(this.parameters.text))
        };
        e.prototype.setOverlay = function (a) {
            "boolean" === typeof a && this.parameters.overlay !== a && (this.parameters.overlay = a, "undefined" !== typeof this.positionObject.vg.meshes.poi_text && 0 < this.positionObject.vg.meshes.poi_text.length && this.positionObject.vg.meshes.poi_text.forEach(function (a) {
                    a.material.depthTest = this.parameters.overlay ? !1 : this.mapviewer.useDepthWriteForPOIs;
                    a.renderDepth = this.parameters.overlay ? this.addPoiVariables.MapviewerPrivate.renderDepthPOIOverlay : this.addPoiVariables.MapviewerPrivate.renderDepthPOI
                },
                this), a = this.positionObject.vg.meshes.poi_url, "undefined" !== typeof a && (a.material.depthTest = this.parameters.overlay ? !1 : this.mapviewer.useDepthWriteForPOIs, a.renderDepth = this.parameters.overlay ? this.addPoiVariables.MapviewerPrivate.renderDepthPOIOverlay : this.addPoiVariables.MapviewerPrivate.renderDepthPOI))
        };
        e.prototype.setFixed = function (a) {
            if ("boolean" === typeof a && this.parameters.fixed !== a) {
                this.parameters.fixed = a;
                var b = this.mapviewer.getFloor(this.parameters.floor);
                a = b.getLOD(this.parameters.lod);
                a || (a = b.floorContentLOD);
                var e, f = new THREE.Euler;
                this.parameters.fixed ? (b = new THREE.Object3D, b.name = "options fixed", f.set(-Math.PI / 2, this.parameters.angle * Math.PI / 180, 0)) : (b = new d({face2d: this.parameters.face2d}, this.mapviewer), b.name = "options !fixed", f.set(0, 0, 0), ("undefined" !== typeof this.parameters.url && "" !== this.parameters.url || "undefined" !== typeof this.parameters.model && "" !== this.parameters.model || "undefined" !== typeof this.parameters.text && "" !== this.parameters.text) && a.cameraUpdatableObjects.push(b));
                b.vg = jQuery.extend({}, this.positionObject.vg);
                b.matrixAutoUpdate = !1;
                b.position.copy(this.positionObject.position);
                b.add(this.rotationObject);
                this.parameters.fixed && this.parameters.flip && (this.parameters.flip = !1, this.setFlip(!0));
                e = new THREE.Matrix4;
                e.makeRotationFromEuler(f);
                this.rotationObject.position.copy(new THREE.Vector3);
                this.rotationObject.position.x = -this.rotationObject.current_position.x / 2;
                this.rotationObject.position.x += this.parameters.alignment.x * this.rotationObject.current_position.x /
                    2;
                this.rotationObject.position.applyProjection(e);
                ("undefined" !== typeof this.parameters.url && "" !== this.parameters.url || "undefined" !== typeof this.parameters.model && "" !== this.parameters.model || "undefined" !== typeof this.parameters.text && "" !== this.parameters.text || "undefined" !== typeof this.parameters.selector && "" !== this.parameters.selector) && a.rampObjects.push(b);
                e = a.cameraUpdatableObjects.indexOf(this.positionObject);
                -1 !== e && a.cameraUpdatableObjects.splice(e, 1);
                e = a.rampObjects.indexOf(this.positionObject);
                -1 !== e && a.rampObjects.splice(e, 1);
                a = this.positionObject.parent;
                a.remove(this.positionObject);
                a.add(b);
                this.positionObject = b;
                this.rotationObject.rotation.copy(f);
                this.rotationObject.updateMatrix();
                this.positionObject.updateMatrix();
                this.positionObject.updateMatrixWorld(!0);
                this.mapviewer.mustUpdateCameraObjects = !0;
                this.mapviewer.requestRedraw()
            }
        };
        e.prototype.setFlip = function (a) {
            if ("boolean" === typeof a && this.parameters.flip !== a) {
                this.parameters.flip = a;
                var b = this.mapviewer.getFloor(this.parameters.floor);
                a = b.getLOD(this.parameters.lod);
                a || (a = b.floorContentLOD);
                this.parameters.fixed && (this.parameters.flip ? (this.rotationObject.current_alignment = this.parameters.alignment, this.rotationObject.current_aspect = 0 !== this.parameters.scale.y ? this.parameters.scale.x / this.parameters.scale.y : 1, this.rotationObject.matrixAutoUpdate = !1, ("undefined" !== typeof this.parameters.url && "" !== this.parameters.url || "undefined" !== typeof this.parameters.model && "" !== this.parameters.model || "undefined" !== typeof this.parameters.text &&
                    "" !== this.parameters.text) && a.cameraUpdatableObjects.push(this.rotationObject), this.mapviewer.mustUpdateCameraObjects = !0) : 0 !== this.parameters.zoomScaleFactor && (b = a.cameraUpdatableObjects.indexOf(this.rotationObject), -1 !== b && a.cameraUpdatableObjects.splice(b, 1)), this.rotationObject.updateMatrix(), this.mapviewer.requestRedraw())
            }
        };
        e.prototype.setFace2d = function (a) {
            "boolean" === typeof a && this.parameters.face2d !== a && (this.parameters.face2d = a, "boolean" === typeof this.parameters.fixed && this.parameters.fixed ||
            (this.positionObject.constraints = this.parameters.face2d ? [THREE.Billboard.FIXED, THREE.Billboard.FIXED, THREE.Billboard.CAMERA_FACING] : [THREE.Billboard.CAMERA_FACING, THREE.Billboard.FIXED, THREE.Billboard.CAMERA_FACING], this.positionObject.lastCameraOrientationZ = !1, this.positionObject.face2d = this.parameters.face2d, this.positionObject.updateMatrix(), this.positionObject.updateMatrixWorld(!0), this.mapviewer.mustUpdateCameraObjects = !0, this.mapviewer.requestRedraw()))
        };
        e.prototype.setAngle = function (a) {
            if ("number" ===
                typeof a && this.parameters.angle !== a && (this.parameters.angle = a, this.parameters._inverseAngleInRadians = 2 * Math.PI - a * Math.PI / 180, this.parameters.fixed)) {
                a = new THREE.Euler;
                a.set(-Math.PI / 2, this.parameters.angle * Math.PI / 180, 0);
                this.rotationObject.rotation.copy(a);
                var b = new THREE.Matrix4;
                b.makeRotationFromEuler(a);
                this.rotationObject.position.copy(new THREE.Vector3);
                this.rotationObject.position.x = -this.rotationObject.current_position.x / 2;
                this.rotationObject.position.x += this.parameters.alignment.x * this.rotationObject.current_position.x /
                    2;
                this.rotationObject.position.applyProjection(b);
                this.positionObject.updateMatrix();
                this.rotationObject.dirty = !0;
                this.rotationObject.updateMatrix();
                this.positionObject.updateMatrixWorld(!0);
                this.mapviewer.requestRedraw()
            }
        };
        e.prototype.setHeading = function (a) {
            "number" === typeof a && this.parameters.heading !== a && this.parameters.angle !== a - this.mapviewer.cameraNorthRotation && (this.parameters.heading = a, this.setAngle(this.parameters.heading - this.mapviewer.cameraNorthRotation))
        };
        e.prototype.getUUID = function () {
            return this.positionObject ?
                this.positionObject.uuid : "does not exist"
        };
        return e
    });
    define("com/visioglobe/web/poi/POIBatchElement", ["com/visioglobe/web/poi/POIProxy"], function (a) {
        function b(b, e, f, h) {
            this.batch = b;
            this.index = e;
            this.parameters = f;
            this.proxy = new a(this);
            b = 4 * this.index;
            this.vertexOffsets = [b, b + 1, b + 2, b + 3];
            b = this.batch.geometry.getAttribute("normal");
            b.needsUpdate = !0;
            b.setXYZ(this.vertexOffsets[3], 0, 0, 1);
            b = this.batch.geometry.getAttribute("uv");
            b.needsUpdate = !0;
            e = h[0];
            f = h[5];
            var g = h[2];
            h = h[1];
            b.setXY(this.vertexOffsets[0], e, f);
            b.setXY(this.vertexOffsets[1], g, f);
            b.setXY(this.vertexOffsets[2],
                g, h);
            b.setXY(this.vertexOffsets[3], e, h);
            this.updateHalfWidthAndHeight();
            this.updateTypesAttribute();
            this.updateCenterAttribute();
            this.updateGeometryAttributes();
            this.updateVisibilityRampAttribute()
        }

        b.prototype.constructor = b;
        b.prototype.getVisible = function () {
            return this.getParameter("visible")
        };
        b.prototype.setVisible = function (a, b) {
            if (this.parameters && this.parameters.visible != a || b) {
                this.parameters.visible = a;
                var f = this.batch.geometry.getAttribute("index"), h = 6 * this.index, g = this.batch.indices,
                    k = 4 * this.index;
                a ? (g[h] = k, g[h + 1] = k + 1, g[h + 2] = k + 3, g[h + 3] = k + 1, g[h + 4] = k + 2, g[h + 5] = k + 3) : (g[h] = 0, g[h + 1] = 0, g[h + 2] = 0, g[h + 3] = 0, g[h + 4] = 0, g[h + 5] = 0);
                f.needsUpdate = !0;
                this.batch.mesh.updateMatrix();
                this.batch.mapviewer.requestRedraw()
            }
        };
        b.prototype.getOpacity = function () {
            return 1
        };
        b.prototype.setOpacity = function (a) {
        };
        b.prototype.options = function (b, e, f) {
            if (!this.parameters) return !1;
            if (null !== this.parameters) {
                if ("undefined" === typeof b) return a.getPublicParameters(this.parameters);
                if ("object" === typeof b) {
                    var h = jQuery.extend({}, this.parameters);
                    Object.keys(b).forEach(function (a) {
                        "undefined" === typeof a ? delete h[a] : h[a] = b[a]
                    });
                    this.batch.addPoiVariables.POIFactory.createPOI(this.batch.addPoiVariables, h, this.proxy.publicPOI);
                    this.realRemove(!1)
                } else if ("string" === typeof b) {
                    if ("undefined" === typeof e && a.isPublicParameter(b)) return this.getParameter(b);
                    this.setParameter(b, e)
                }
            }
        };
        b.prototype.getParameter = function (a) {
            return this.parameters && this.parameters[a]
        };
        b.prototype.setParameter = function (a, b) {
            switch (a) {
                case "visibilityRampStartVisible":
                    this.parameters.visibilityRampStartVisible =
                        b;
                    this.updateVisibilityRampAttribute();
                    return;
                case "visibilityRampFullyVisible":
                    this.parameters.visibilityRampFullyVisible = b;
                    this.updateVisibilityRampAttribute();
                    return;
                case "visibilityRampStartInvisible":
                    this.parameters.visibilityRampStartInvisible = b;
                    this.updateVisibilityRampAttribute();
                    return;
                case "visibilityRampFullyInvisible":
                    this.parameters.visibilityRampFullyInvisible = b;
                    this.updateVisibilityRampAttribute();
                    return;
                case "onObjectMouseOver":
                    this.parameters.onObjectMouseOver = b;
                    return;
                case "onObjectMouseOut":
                    this.parameters.onObjectMouseOut =
                        b;
                    return;
                case "onObjectMouseUp":
                    this.parameters.onObjectMouseUp = b;
                    return;
                case "visible":
                    this.setVisible(b);
                    return;
                case "opacity":
                    return;
                case "position":
                    this.setPosition(b);
                    return;
                case "scale":
                    this.setScale(b);
                    return;
                case "zoomScaleFactor":
                    if (0 < b && 0 < this.parameters.zoomScaleFactor || !this.parameters.fixed) {
                        this.setZoomScaleFactor(b);
                        return
                    }
                    this.parameters.zoomScaleFactor = b;
                    break;
                case "zoomScaleFast":
                    this.setZoomScaleFast(b);
                    return;
                case "iconScale":
                case "icon_scale":
                    console.log('Deprecated option. It will be taken into account if there is no text. Otherwise, "scale" option will be used.');
                    "undefined" !== typeof this.parameters.text && "" !== this.parameters.text || this.setScale(b);
                    return;
                case "angle":
                    this.setAngle(b);
                    return;
                case "heading":
                    this.setHeading(b);
                    return;
                case "width":
                    this.setWidth(b);
                    return;
                case "height":
                    this.setHeight(b);
                    return;
                case "fixed":
                    if (this.parameters.fixed === b) return;
                    if (0 < this.parameters.zoomScaleFactor) {
                        this.setFixed(b);
                        return
                    }
                    this.parameters.fixed = b;
                    break;
                case "flip":
                    this.setFlip(b);
                    return;
                case "face2d":
                    this.setFace2d(b);
                    return;
                case "id":
                    this.setID(b);
                    return;
                case "clickable":
                    this.setClickable(b);
                    return;
                default:
                    this.parameters[a] = b
            }
            this.batch.addPoiVariables.POIFactory.createPOI(this.batch.addPoiVariables, this.parameters, this.proxy.publicPOI);
            this.batch.mesh.updateMatrix();
            this.batch.mapviewer.requestRedraw();
            this.realRemove(!1)
        };
        b.prototype.setPosition = function (a) {
            this.parameters.position = a || {x: 0, y: 0, z: 0};
            this.parameters.position.z = a.z || 0;
            this.parameters._center = this.parameters.position;
            this.parameters._centerZ = this.parameters.position.z + this.parameters._zOffset;
            this.updateCenterAttribute();
            this.updateGeometryAttributes();
            this.parameters._dirty = !0;
            this.batch.mesh.updateMatrix();
            this.batch.mapviewer.requestRedraw()
        };
        b.prototype.setScale = function (a) {
            var b = a;
            "number" === typeof a && (b = {x: a, y: a, z: a});
            "object" === typeof b && this.parameters.scale !== b && (this.parameters.scale = b, this.updateHalfWidthAndHeight(), this.updateCenterAttribute(), this.updateGeometryAttributes(), this.parameters._dirty = !0, this.batch.mesh.updateMatrix(), this.batch.mapviewer.requestRedraw())
        };
        b.prototype.setZoomScaleFactor = function (a) {
            "number" ===
            typeof a && this.parameters.zoomScaleFactor !== a && (this.parameters.zoomScaleFactor = a, this.updateHalfWidthAndHeight(), this.parameters._dirty = !0, this.batch.mesh.updateMatrix(), this.batch.mapviewer.requestRedraw())
        };
        b.prototype.setZoomScaleFast = function (a) {
            "boolean" === typeof a && this.parameters.zoomScaleFast !== a && (this.parameters.zoomScaleFast = a, this.updateHalfWidthAndHeight(), this.parameters._dirty = !0, this.batch.mesh.updateMatrix(), this.batch.mapviewer.requestRedraw())
        };
        b.prototype.setWidth = function (a) {
            "number" ===
            typeof a && this.parameters.width !== a && (this.parameters.width = a, this.updateHalfWidthAndHeight(), this.updateCenterAttribute(), this.updateGeometryAttributes(), this.parameters._dirty = !0, this.batch.mesh.updateMatrix(), this.batch.mapviewer.requestRedraw())
        };
        b.prototype.setHeight = function (a) {
            "number" === typeof a && this.parameters.height !== a && (this.parameters.height = a, this.updateHalfWidthAndHeight(), this.updateCenterAttribute(), this.updateGeometryAttributes(), this.parameters._dirty = !0, this.batch.mesh.updateMatrix(),
                this.batch.mapviewer.requestRedraw())
        };
        b.prototype.setAngle = function (a) {
            "number" === typeof a && this.parameters.angle !== a && (this.parameters.angle = a, this.updateCenterAttribute(), this.updateGeometryAttributes(), this.parameters._dirty = !0, this.batch.mesh.updateMatrix(), this.batch.mapviewer.requestRedraw())
        };
        b.prototype.setHeading = function (a) {
            "number" === typeof a && this.parameters.heading !== a && this.parameters.angle !== a - this.batch.mapviewer.cameraNorthRotation && (this.parameters.heading = a, this.setAngle(this.parameters.heading -
                this.batch.mapviewer.cameraNorthRotation))
        };
        b.prototype.setFixed = function (a) {
            "boolean" === typeof a && this.parameters.fixed !== a && (this.parameters.fixed = a, this.updateTypesAttribute(), this.parameters._dirty = !0, this.batch.mesh.updateMatrix(), this.batch.mapviewer.requestRedraw())
        };
        b.prototype.setFlip = function (a) {
            "boolean" === typeof a && this.parameters.flip !== a && (this.parameters.flip = a, this.updateTypesAttribute(), this.parameters._dirty = !0, this.batch.mesh.updateMatrix(), this.batch.mapviewer.requestRedraw())
        };
        b.prototype.setFace2d = function (a) {
            "boolean" === typeof a && this.parameters.face2d !== a && (this.parameters.face2d = a, this.updateTypesAttribute(), this.parameters._dirty = !0, this.batch.mesh.updateMatrix(), this.batch.mapviewer.requestRedraw())
        };
        b.prototype.setID = function (a) {
            "string" === typeof a && this.parameters.id !== a && (this.batch.addPoiVariables.POIFactory.removeFromPois(this.batch.mapviewer, this.parameters.id, this.proxy.publicPOI), "" !== a && this.batch.addPoiVariables.POIFactory.addToPois(this.batch.mapviewer,
                a, this.proxy.publicPOI), this.parameters.id = a)
        };
        b.prototype.setClickable = function (a) {
            "boolean" === typeof a && this.parameters.clickable !== a && (this.parameters.clickable = a)
        };
        b.prototype.updateVisibility = function () {
            this.parameters._halfWidth * this.parameters._zoomScale < .5 * this.parameters.width && this.parameters._halfHeight * this.parameters._zoomScale < .5 * this.parameters.height ? this.setVisible(!0) : this.setVisible(!1)
        };
        b.prototype.updateHalfWidthAndHeight = function () {
            var a, b;
            if (0 < this.parameters.zoomScaleFactor) a =
                .5 * this.parameters._textAspectRatio, b = .5; else if (a = .5 * this.parameters._textAspectRatio * this.parameters.scale.x, b = .5 * this.parameters.scale.y, -1 !== this.parameters.width && -1 !== this.parameters.height) {
                var f = this.parameters.width / (2 * a);
                2 * b * f > this.parameters.height && (f = this.parameters.height / (2 * b));
                a *= f;
                b *= f
            }
            this.parameters._halfWidth = a;
            this.parameters._halfHeight = b
        };
        b.prototype.updateGeometryAttributesWithScale = function (a) {
            var b = this.parameters._halfWidth * a, f = this.parameters._halfHeight * a, h = this.parameters.position,
                g = this.parameters._centerZ, k = -this.parameters.angle * Math.PI / 180;
            a = Math.cos(k);
            var k = Math.sin(k), l = k * b, b = a * b, m = k * f, f = a * f,
                n = this.batch.geometry.getAttribute("position");
            n.needsUpdate = !0;
            n.setXYZ(this.vertexOffsets[0], h.x - b + m, h.y - l - f, g);
            n.setXYZ(this.vertexOffsets[1], h.x + b + m, h.y + l - f, g);
            n.setXYZ(this.vertexOffsets[2], h.x + b - m, h.y + l + f, g);
            n.setXYZ(this.vertexOffsets[3], h.x - b - m, h.y - l + f, g);
            h = this.batch.geometry.getAttribute("centerOffset");
            h.needsUpdate = !0;
            h.setXY(this.vertexOffsets[0], -b + m, -l - f);
            h.setXY(this.vertexOffsets[1],
                +b + m, +l - f);
            h.setXY(this.vertexOffsets[2], +b - m, +l + f);
            h.setXY(this.vertexOffsets[3], -b - m, -l + f);
            h = this.batch.geometry.getAttribute("angleVector");
            h.needsUpdate = !0;
            h.setXY(this.vertexOffsets[0], -k, a);
            h.setXY(this.vertexOffsets[1], -k, a);
            h.setXY(this.vertexOffsets[2], -k, a);
            h.setXY(this.vertexOffsets[3], -k, a)
        };
        b.prototype.updateGeometryAttributes = function () {
            this.updateGeometryAttributesWithScale(1)
        };
        b.prototype.updateCenterAttribute = function () {
            var a = this.parameters.position, b = this.parameters._centerZ, f =
                this.batch.geometry.getAttribute("center");
            f.needsUpdate = !0;
            f.setXYZ(this.vertexOffsets[0], a.x, a.y, b);
            f.setXYZ(this.vertexOffsets[1], a.x, a.y, b);
            f.setXYZ(this.vertexOffsets[2], a.x, a.y, b);
            f.setXYZ(this.vertexOffsets[3], a.x, a.y, b)
        };
        b.prototype.updateGeometryAttributeFace2d = function (a, b, f) {
            var h = this.parameters._center, g = this.parameters._centerZ, k = this.parameters._halfWidth * f,
                l = this.parameters._halfHeight * f;
            f = b * k;
            k *= a;
            b *= l;
            a *= l;
            l = this.batch.geometry.getAttribute("position");
            l.needsUpdate = !0;
            l.setXYZ(this.vertexOffsets[0],
                h.x - k + b, h.y - f - a, g);
            l.setXYZ(this.vertexOffsets[1], h.x + k + b, h.y + f - a, g);
            l.setXYZ(this.vertexOffsets[2], h.x + k - b, h.y + f + a, g);
            l.setXYZ(this.vertexOffsets[3], h.x - k - b, h.y - f + a, g)
        };
        b.prototype.updateGeometryAttributeFacing = function (a, b) {
            var f = this.parameters._center, h = this.parameters._centerZ, g = this.parameters._halfWidth * b,
                k = this.parameters._halfHeight * b, g = [{x: -g, y: -k}, {x: g, y: -k}, {x: g, y: k}, {x: -g, y: k}],
                k = this.batch.geometry.getAttribute("position");
            k.needsUpdate = !0;
            for (var l = 0; 4 > l; l++) k.setXYZ(this.vertexOffsets[l],
                a[0] * g[l].x + a[3] * g[l].y + f.x, a[1] * g[l].x + a[4] * g[l].y + f.y, a[2] * g[l].x + a[5] * g[l].y + h)
        };
        b.prototype.updateTypesAttribute = function () {
            var a;
            this.parameters.fixed ? a = this.parameters.flip ? 0 : 1 : this.parameters.face2d ? (this.batch.mapviewer.mustUpdateCameraObjects = !0, a = 2) : (this.batch.mapviewer.mustUpdateCameraObjects = !0, a = 3);
            var b = this.batch.geometry.getAttribute("type");
            b.needsUpdate = !0;
            b.setX(this.vertexOffsets[0], a);
            b.setX(this.vertexOffsets[1], a);
            b.setX(this.vertexOffsets[2], a);
            b.setX(this.vertexOffsets[3],
                a)
        };
        b.prototype.updateVisibilityRampAttribute = function () {
            var a = this.batch.geometry.getAttribute("visibilityRamp");
            a.needsUpdate = !0;
            a.setXYZW(this.vertexOffsets[0], this.parameters.visibilityRampStartVisible, this.parameters.visibilityRampFullyVisible, this.parameters.visibilityRampStartInvisible, this.parameters.visibilityRampFullyInvisible);
            a.setXYZW(this.vertexOffsets[1], this.parameters.visibilityRampStartVisible, this.parameters.visibilityRampFullyVisible, this.parameters.visibilityRampStartInvisible,
                this.parameters.visibilityRampFullyInvisible);
            a.setXYZW(this.vertexOffsets[2], this.parameters.visibilityRampStartVisible, this.parameters.visibilityRampFullyVisible, this.parameters.visibilityRampStartInvisible, this.parameters.visibilityRampFullyInvisible);
            a.setXYZW(this.vertexOffsets[3], this.parameters.visibilityRampStartVisible, this.parameters.visibilityRampFullyVisible, this.parameters.visibilityRampStartInvisible, this.parameters.visibilityRampFullyInvisible)
        };
        b.prototype.realRemove = function (a) {
            var b =
                this.parameters;
            if (!b) return !1;
            "undefined" !== typeof b._measuringCanvas && (b._measuringCanvas = null);
            this.setVisible(!1, !0);
            this.parameters = null;
            var f = this.proxy;
            a && this.batch.addPoiVariables.POIFactory.removeFromPois(this.batch.mapviewer, b.id, f.publicPOI);
            this.proxy = null;
            this.batch.inuse--;
            0 == this.batch.inuse && this.batch.dispose()
        };
        b.prototype.remove = function () {
            this.realRemove(!0)
        };
        return b
    });
    define("com/visioglobe/web/poi/POIBatchMultiLineText", ["com/visioglobe/web/poi/POIProxy", "com/visioglobe/web/poi/POIBatchElement"], function (a, b) {
        function d(b, d, h, g, k) {
            this.batch = b;
            this.index = d;
            this.parameters = h;
            this.fragments = g;
            this.space = k;
            this.lines = [];
            this.proxy = new a(this);
            for (b = 0; b < this.fragments.length; b++) {
                d = this.fragments[b];
                h = 4 * d.index;
                d.vertexOffsets = [h, h + 1, h + 2, h + 3];
                h = this.batch.geometry.getAttribute("normal");
                h.needsUpdate = !0;
                h.setXYZ(d.vertexOffsets[3], 0, 0, 1);
                h = this.batch.geometry.getAttribute("uv");
                h.needsUpdate = !0;
                g = d.uvArray[0];
                k = d.uvArray[5];
                var l = d.uvArray[2], m = d.uvArray[1];
                h.setXY(d.vertexOffsets[0], g, k);
                h.setXY(d.vertexOffsets[1], l, k);
                h.setXY(d.vertexOffsets[2], l, m);
                h.setXY(d.vertexOffsets[3], g, m)
            }
            this.updateHalfWidthAndHeight();
            this.updateTypesAttribute();
            this.updateCenterAttribute();
            this.updateGeometryAttributes();
            this.updateVisibilityRampAttribute()
        }

        d.prototype = Object.create(b.prototype);
        d.prototype.constructor = d;
        d.prototype.setVisible = function (a, b) {
            if (this.parameters && this.parameters.visible !=
                a || b) {
                this.parameters.visible = a;
                var d = this.batch.geometry.getAttribute("index"), g = this.batch.indices;
                if (a) for (var k = 0; k < this.fragments.length; k++) {
                    var l = this.fragments[k], m = 6 * l.index, l = 4 * l.index;
                    g[m] = l;
                    g[m + 1] = l + 1;
                    g[m + 2] = l + 3;
                    g[m + 3] = l + 1;
                    g[m + 4] = l + 2;
                    g[m + 5] = l + 3
                } else for (k = 0; k < this.fragments.length; k++) l = this.fragments[k], m = 6 * l.index, g[m] = 0, g[m + 1] = 0, g[m + 2] = 0, g[m + 3] = 0, g[m + 4] = 0, g[m + 5] = 0;
                d.needsUpdate = !0
            }
        };
        d.prototype.shouldRecomputeLines = function () {
            if (0 === this.lines.length) return !0;
            var a = this.lines.length,
                b = this.fragments.length;
            return 0 < this.parameters.zoomScaleFactor && (this.parameters._zoomScale === this.parameters._previousZoomScale || this.parameters._zoomScale > this.parameters._previousZoomScale && a === b || this.parameters._zoomScale < this.parameters._previousZoomScale && 1 === a) ? !1 : !0
        };
        d.prototype.computeLines = function (a) {
            var b = this.parameters._textAspectRatio / a, d = this.fragments[0].aspectRatio, g = 0;
            this.lines.splice(0, this.lines.length);
            this.fragments[0].lineNb = 0;
            this.lines[0] = {
                fragments: [0], width: this.fragments[0].width,
                height: this.fragments[0].height, aspectRatio: this.fragments[0].aspectRatio
            };
            for (var k = 1; k < this.fragments.length; k++) {
                var l = this.fragments[k], m = d + this.space.aspectRatio + l.aspectRatio;
                g < a && (d > b || m > 1.5 * b) ? (g++, l.lineNb = g, this.lines[g] = {
                    fragments: [k],
                    width: l.width,
                    height: l.height,
                    aspectRatio: l.aspectRatio
                }, d = l.aspectRatio) : (d = m, l.lineNb = g, this.lines[g].fragments.push(k), this.lines[g].width += this.space.width + l.width, this.lines[g].height = Math.max(this.lines[g].height, l.height))
            }
        };
        d.prototype.updateLines =
            function (a) {
                var b = this.parameters._textAspectRatio, d = 1;
                for (this.computeLines(d); a * b > this.parameters.width && d < this.fragments.length;) {
                    d++;
                    this.computeLines(d);
                    for (var g = b = 0; g < this.lines.length; g++) b = Math.max(b, this.lines[g].width / this.lines[g].height)
                }
            };
        d.prototype.updateHalfWidthAndHeight = function () {
            if (this.shouldRecomputeLines()) {
                var a = this.parameters.scale.x;
                0 < this.parameters.zoomScaleFactor && (a = this.parameters._zoomScale);
                this.updateLines(a)
            }
            if (0 < this.parameters.zoomScaleFactor) {
                this.parameters._previousZoomScale =
                    this.parameters._zoomScale;
                for (var b = this.parameters._halfWidth = 0; b < this.lines.length; b++) {
                    var d = this.lines[b];
                    d.aspectRatio = d.width / d.height;
                    for (var g = .5 * -d.aspectRatio, k = .5 * (this.lines.length - 1) - b, l = 0; l < d.fragments.length; l++) a = this.fragments[d.fragments[l]], g += .5 * a.aspectRatio, a.horizontalOffset = g, g += .5 * a.aspectRatio, l < d.fragments.length - 1 && (g += this.space.aspectRatio), a.verticalOffset = k, a.halfWidth = .5 * a.aspectRatio, a.halfHeight = .5;
                    this.parameters._halfWidth = Math.max(this.parameters._halfWidth,
                        .5 * d.aspectRatio)
                }
                this.parameters._halfHeight = .5 * this.lines.length
            } else {
                for (b = 0; b < this.lines.length; b++) for (d = this.lines[b], d.aspectRatio = d.width / d.height, g = .5 * -d.aspectRatio * this.parameters.scale.x, k = .5 * (this.lines.length - 1) - b, l = 0; l < d.fragments.length; l++) a = this.fragments[d.fragments[l]], g += .5 * a.aspectRatio * this.parameters.scale.x, a.horizontalOffset = g, g += .5 * a.aspectRatio * this.parameters.scale.x, l < d.fragments.length - 1 && (g += this.space.aspectRatio * this.parameters.scale.x), a.verticalOffset = k * this.parameters.scale.y,
                    a.halfWidth = .5 * a.aspectRatio * this.parameters.scale.x, a.halfHeight = .5 * this.parameters.scale.y;
                if (-1 !== this.parameters.width && -1 !== this.parameters.height) {
                    for (b = a = 0; b < this.lines.length; b++) a = Math.max(a, this.lines[b].aspectRatio);
                    a *= this.parameters.scale.x;
                    d = this.lines.length * this.parameters.scale.y;
                    b = this.parameters.width / a;
                    d * b > this.parameters.height && (b = this.parameters.height / d);
                    if (1 !== b) for (d = 0; d < this.fragments.length; d++) a = this.fragments[d], a.horizontalOffset *= b, a.verticalOffset *= b, a.halfWidth *=
                        b, a.halfHeight *= b
                }
            }
        };
        d.prototype.updateVisibility = function () {
            this.updateHalfWidthAndHeight();
            this.parameters._halfWidth * this.parameters._zoomScale < .5 * this.parameters.width && this.parameters._halfHeight * this.parameters._zoomScale < .5 * this.parameters.height ? this.setVisible(!0) : this.setVisible(!1)
        };
        d.prototype.updateGeometryAttributesWithScale = function (a) {
            var b = this.batch.geometry.getAttribute("position"), d = this.batch.geometry.getAttribute("centerOffset"),
                g = this.batch.geometry.getAttribute("angleVector");
            b.needsUpdate = !0;
            d.needsUpdate = !0;
            g.needsUpdate = !0;
            for (var k = this.parameters._centerZ, l = -this.parameters.angle * Math.PI / 180, m = Math.cos(l), l = Math.sin(l), n = 0; n < this.fragments.length; n++) for (var q = this.fragments[n], p = q.halfWidth, r = q.halfHeight, p = [{
                x: -p + q.horizontalOffset,
                y: -r + q.verticalOffset
            }, {x: p + q.horizontalOffset, y: -r + q.verticalOffset}, {
                x: p + q.horizontalOffset,
                y: r + q.verticalOffset
            }, {
                x: -p + q.horizontalOffset,
                y: r + q.verticalOffset
            }], r = this.parameters.position, v = 0; 4 > v; v++) {
                var u = p[v], x = (m * u.x - l * u.y) * a,
                    u = (l * u.x + m * u.y) * a;
                b.setXYZ(q.vertexOffsets[v], r.x + x, r.y + u, k);
                d.setXY(q.vertexOffsets[v], x, u);
                g.setXY(q.vertexOffsets[v], -l, m)
            }
        };
        d.prototype.updateCenterAttribute = function () {
            var a = this.parameters.position, b = this.parameters._centerZ,
                d = this.batch.geometry.getAttribute("center");
            d.needsUpdate = !0;
            for (var g = 0; g < this.fragments.length; g++) {
                var k = this.fragments[g];
                d.setXYZ(k.vertexOffsets[0], a.x, a.y, b);
                d.setXYZ(k.vertexOffsets[1], a.x, a.y, b);
                d.setXYZ(k.vertexOffsets[2], a.x, a.y, b);
                d.setXYZ(k.vertexOffsets[3],
                    a.x, a.y, b)
            }
        };
        d.prototype.updateGeometryAttributeFace2d = function (a, b, d) {
            var g = this.parameters._centerZ, k = this.batch.geometry.getAttribute("position");
            k.needsUpdate = !0;
            for (var l = 0; l < this.fragments.length; l++) for (var m = this.fragments[l], n = m.halfWidth, q = m.halfHeight, n = [{
                x: -n + m.horizontalOffset,
                y: -q + m.verticalOffset
            }, {x: n + m.horizontalOffset, y: -q + m.verticalOffset}, {
                x: n + m.horizontalOffset,
                y: q + m.verticalOffset
            }, {
                x: -n + m.horizontalOffset,
                y: q + m.verticalOffset
            }], q = this.parameters.position, p = 0; 4 > p; p++) {
                var r =
                    n[p];
                k.setXYZ(m.vertexOffsets[p], q.x + (a * r.x - b * r.y) * d, q.y + (b * r.x + a * r.y) * d, g)
            }
        };
        d.prototype.updateGeometryAttributeFacing = function (a, b) {
            var d = this.parameters._centerZ, g = this.batch.geometry.getAttribute("position");
            g.needsUpdate = !0;
            for (var k = 0; k < this.fragments.length; k++) for (var l = this.fragments[k], m = l.halfWidth, n = l.halfHeight, m = [{
                    x: -m + l.horizontalOffset,
                    y: -n + l.verticalOffset
                }, {x: m + l.horizontalOffset, y: -n + l.verticalOffset}, {
                    x: m + l.horizontalOffset,
                    y: n + l.verticalOffset
                }, {x: -m + l.horizontalOffset, y: n + l.verticalOffset}],
                                                                     n = this.parameters.position, q = 0; 4 > q; q++) {
                var p = m[q], r = p.x * b, p = p.y * b;
                g.setXYZ(l.vertexOffsets[q], a[0] * r + a[3] * p + n.x, a[1] * r + a[4] * p + n.y, a[2] * r + a[5] * p + d)
            }
        };
        d.prototype.updateTypesAttribute = function () {
            var a;
            this.parameters.fixed ? a = this.parameters.flip ? 0 : 1 : this.parameters.face2d ? (this.batch.mapviewer.mustUpdateCameraObjects = !0, a = 2) : (this.batch.mapviewer.mustUpdateCameraObjects = !0, a = 3);
            var b = this.batch.geometry.getAttribute("type");
            b.needsUpdate = !0;
            for (var d = 0; d < this.fragments.length; d++) {
                var g = this.fragments[d];
                b.setX(g.vertexOffsets[0], a);
                b.setX(g.vertexOffsets[1], a);
                b.setX(g.vertexOffsets[2], a);
                b.setX(g.vertexOffsets[3], a)
            }
        };
        d.prototype.updateVisibilityRampAttribute = function () {
            var a = this.batch.geometry.getAttribute("visibilityRamp");
            a.needsUpdate = !0;
            for (var b = 0; b < this.fragments.length; b++) {
                var d = this.fragments[b];
                a.setXYZW(d.vertexOffsets[0], this.parameters.visibilityRampStartVisible, this.parameters.visibilityRampFullyVisible, this.parameters.visibilityRampStartInvisible, this.parameters.visibilityRampFullyInvisible);
                a.setXYZW(d.vertexOffsets[1], this.parameters.visibilityRampStartVisible, this.parameters.visibilityRampFullyVisible, this.parameters.visibilityRampStartInvisible, this.parameters.visibilityRampFullyInvisible);
                a.setXYZW(d.vertexOffsets[2], this.parameters.visibilityRampStartVisible, this.parameters.visibilityRampFullyVisible, this.parameters.visibilityRampStartInvisible, this.parameters.visibilityRampFullyInvisible);
                a.setXYZW(d.vertexOffsets[3], this.parameters.visibilityRampStartVisible, this.parameters.visibilityRampFullyVisible,
                    this.parameters.visibilityRampStartInvisible, this.parameters.visibilityRampFullyInvisible)
            }
        };
        return d
    });
    define("com/visioglobe/web/helpers/TextGenerator", ["require"], function (a) {
        TextGenerator = function () {
            this.id = TextGenerator.count++;
            this.plane_geometry = new THREE.PlaneBufferGeometry(1, 1);
            this.plane_geometry.vg = {permanent: !0};
            this.iconsAtlas = {}
        };
        TextGenerator.count = 0;
        TextGenerator.prototype.activeAtlas = null;
        TextGenerator.prototype.activeTexture = null;
        TextGenerator.prototype.textureAtlasParameters = {width: 1024, height: 1024};
        TextGenerator.prototype.disposeTexture = function (a) {
            if (0 === a.vg.nbRefs && (a.dispose(),
                this.activeTexture === a && (this.activeAtlas = this.activeTexture = null), a.vg && a.vg.options && (a.vg.options.canvas = void 0, a.vg.options = null), a.onUpdate = void 0, a.image = null, a.vg.inIconsAtlas)) {
                var d, e;
                for (e in this.iconsAtlas) this.iconsAtlas[e].texture === a && (d = this.iconsAtlas[e], d.texture = !1, d.debugImage = !1, d.loaded = !1, this.iconsAtlas[e] = !1)
            }
        };
        TextGenerator.prototype.generateTextNoAtlas = function (a, d) {
            d.canvas = document.createElement("canvas");
            var e = d.canvas, f = e.getContext("2d"), h = Math.floor(.8 * (d.textTextureHeight -
                4)), g = h + "px " + d.family;
            f.font = g;
            var k = Math.ceil(f.measureText(a).width), l = Math.ceil(1.25 * h), m = h + 2;
            e.width = k + 4;
            e.height = l + 4;
            h = k / l;
            f.font = g;
            f.fillStyle = "#" + ("000000" + d.color.toString(16)).slice(-6);
            f.fillText(a, 2, m);
            g = new THREE.Texture(e);
            g.vg = {nbRefs: 0};
            e = f = null;
            g.minFilter = THREE.LinearFilter;
            g.magFilter = THREE.LinearFilter;
            g.needsUpdate = !0;
            g.vg.options = d;
            g.onUpdate = function () {
                this.vg.options.canvas = void 0;
                this.vg.options = null;
                this.onUpdate = void 0;
                this.image = null
            };
            return {
                aspectRatio: h, width: k, height: l,
                geometry: this.plane_geometry, texture: g
            }
        };
        TextGenerator.prototype.measureText = function (a, d) {
            "undefined" === typeof d._measuringCanvas && (d._measuringCanvas = document.createElement("canvas"));
            var e = d._measuringCanvas.getContext("2d"), f = Math.floor(.8 * (d.textTextureHeight - 4));
            e.font = f + "px " + d.family;
            e = Math.ceil(e.measureText(a).width);
            f = Math.ceil(1.25 * f);
            return {width: e, height: f}
        };
        TextGenerator.prototype.generateTextOnAtlas = function (a, d, e) {
            var f = this.activeAtlas, h = this.activeTexture;
            null === f && (this.activeAtlas =
                f = new a(this.textureAtlasParameters), this.activeTexture = h = new THREE.Texture(f.canvas), h.name = "generateTextOnAtlas", h.vg = {nbRefs: 0});
            var g = f.canvasContext, k = Math.floor(.8 * (e.textTextureHeight - 4)), l = k + "px " + e.family;
            g.font = l;
            var m = Math.ceil(g.measureText(d).width), n = Math.ceil(1.25 * k), q = 0, p = 0, r = 1, v = 1, q = k + 2,
                r = {width: m + 4, height: n + 4};
            if (f.isLargerThanAtlas(r)) return !1;
            p = f.getTexturePlacement(r);
            if (!p && (0 < h.vg.nbRefs ? (this.activeAtlas = f = new a(this.textureAtlasParameters), this.activeTexture = h = new THREE.Texture(f.canvas),
                    h.name = "generateTextOnAtlas2", h.vg = {nbRefs: 0}, g = f.canvasContext) : (g.clearRect(0, 0, f.width, f.height), f.resetNodes()), p = f.getTexturePlacement(r), !1 === p)) return !1;
            aspectRatio = m / n;
            g.font = l;
            g.fillStyle = "#" + ("000000" + e.color.toString(16)).slice(-6);
            g.fillText(d, p.x + 2, p.y + q);
            a = h;
            a.minFilter = THREE.LinearMipMapLinearFilter;
            a.magFilter = THREE.LinearFilter;
            a.needsUpdate = !0;
            d = this.plane_geometry;
            q = (p.x + 2 - 1) / f.width;
            v = 1 - (p.y + 2) / f.height;
            r = (p.x + p.width - 2) / f.width;
            p = 1 - (p.y + p.height - 2) / f.height;
            d = this.plane_geometry.clone();
            f = d.attributes.uv.array;
            f[0] = q;
            f[1] = v;
            f[2] = r;
            f[3] = v;
            f[4] = q;
            f[5] = p;
            f[6] = r;
            f[7] = p;
            d.attributes.uv.needsUpdate = !0;
            return {aspectRatio: aspectRatio, width: m, height: n, geometry: d, texture: a}
        };
        TextGenerator.prototype.generateIconOnAtlasFromImage = function (a, d, e) {
            iconSlot = this.iconsAtlas[d];
            if ("undefined" === typeof iconSlot || !1 === iconSlot) iconSlot = {
                debugUrl: d,
                debugImage: e,
                geometry: !1,
                aspectRatio: !1,
                texture: !1
            }, this.iconsAtlas[d] = iconSlot, a = this.findAtlasForImage(a, e), a.texture.vg.inIconsAtlas = !0, iconSlot.aspectRatio =
                a.aspectRatio, iconSlot.geometry = a.geometry, iconSlot.texture = a.texture, iconSlot.loaded = !0;
            return iconSlot
        };
        TextGenerator.prototype.findAtlasForImage = function (a, d) {
            var e = this.activeAtlas, f = this.activeTexture, h = d.width / d.height;
            null === e && (this.activeAtlas = e = new a(this.textureAtlasParameters), this.activeTexture = f = new THREE.Texture(e.canvas), f.name = "findAtlasForImage", f.vg = {nbRefs: 0});
            var g = 0, k = 0, l = 1, m = 1;
            if (e.isLargerThanAtlas(d, 2)) return f = new THREE.Texture(d), f.name = "single after isLargerThanAtlas",
                f.needsUpdate = !0, f.vg = {nbRefs: 0}, e = this.plane_geometry, {
                texture: f,
                aspectRatio: h,
                geometry: e
            };
            g = e.canvasContext;
            k = e.insert(d, 2);
            if (!k && (0 < f.vg.nbRefs ? (this.activeAtlas = e = new a(this.textureAtlasParameters), this.activeTexture = f = new THREE.Texture(e.canvas), f.name = "findAtlasForImage2", f.vg = {nbRefs: 0}) : (g.clearRect(0, 0, e.width, e.height), e.resetNodes()), k = e.insert(d), !1 === k)) return !1;
            c = null;
            f.minFilter = THREE.LinearMipMapLinearFilter;
            f.magFilter = THREE.LinearFilter;
            f.needsUpdate = !0;
            var g = (k.x + 2) / e.width, m =
                1 - (k.y + 2) / e.height, l = (k.x + k.width - 2) / e.width,
                k = 1 - (k.y + k.height - 1 - 2) / e.height, e = this.plane_geometry.clone(), n = e.attributes.uv.array;
            n[0] = g;
            n[1] = m;
            n[2] = l;
            n[3] = m;
            n[4] = g;
            n[5] = k;
            n[6] = l;
            n[7] = k;
            e.attributes.uv.needsUpdate = !0;
            return {aspectRatio: h, geometry: e, texture: f}
        };
        return TextGenerator
    });
    define("text", {
        load: function (a) {
            throw Error("Dynamic load not allowed: " + a);
        }
    });
    define("text!com/visioglobe/web/shaders/poi.frag", [], function () {
        return "varying vec2 vUv;uniform sampler2D map;varying float visibilityOpacity;void main(){gl_FragColor=vec4(vec3(1.0),1.0)*texture2D(map,vUv);gl_FragColor.a*=visibilityOpacity;}"
    });
    define("text!com/visioglobe/web/shaders/poi.vert", [], function () {
        return "uniform vec2 camAngleVector;varying vec2 vUv;varying float visibilityOpacity;attribute vec4 visibilityRamp;attribute vec3 center;attribute vec2 angleVector;attribute vec2 centerOffset;attribute float type;float a(vec3 b){return sqrt((b.x*b.x)+(b.y*b.y)+(b.z*b.z));}float c(vec2 d,vec2 e){return ((d.x*e.x)+(d.y*e.y));}float f(float g){float h;float i=visibilityRamp.x;float j=visibilityRamp.y;float k=visibilityRamp.z;float l=visibilityRamp.w;if(g>j){if(g<k){h=1.0;}else if(g>l){h=0.0;}else{h=1.0-((g-k)/(l-k));}}else if(g<i){h=0.0;}else{h=(g-i)/(j-i);}return h;}void main(){float m=c(angleVector,camAngleVector);vec3 n;if(type==0.0&&m>=0.0){n=center-vec3(centerOffset,0);}else{n=position;}vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(n,1.0);vec4 o=modelMatrix*vec4(center,1.0);vec3 p=cameraPosition-o.xyz;float q=a(p);visibilityOpacity=f(q);}"
    });
    define("com/visioglobe/web/poi/POIBatch", ["com/visioglobe/web/poi/POIBatchElement", "com/visioglobe/web/poi/POIBatchMultiLineText", "com/visioglobe/web/helpers/TextGenerator", "text!com/visioglobe/web/shaders/poi.frag", "text!com/visioglobe/web/shaders/poi.vert"], function (a, b, d, e, f) {
        function h(a, b, d, h, n, q) {
            this.mapviewer = h;
            this.texture = a;
            a.vg.nbRefs++;
            this.dynamic = q;
            this.poiBatches = b;
            this.geometry = new THREE.BufferGeometry;
            this.geometry.matrixAutoUpdate = !1;
            this.material = new THREE.ShaderMaterial({
                uniforms: {
                    map: {
                        type: "t",
                        value: a
                    }, camAngleVector: {type: "v2", value: h.manipulator.cameraAngleVector}
                },
                attributes: {
                    type: {type: "f", value: []},
                    center: {type: "v3", value: []},
                    centerOffset: {type: "v2", value: []},
                    visibilityRamp: {type: "v4", value: []},
                    angleVector: {type: "v2", value: []}
                },
                vertexShader: f,
                fragmentShader: e,
                transparent: !0,
                side: THREE.DoubleSide,
                depthWrite: !1,
                depthTest: n ? !1 : h.useDepthWriteForPOIs
            });
            this.mesh = new THREE.Mesh(this.geometry, this.material);
            this.mesh.matrixAutoUpdate = !1;
            q && (this.orientationSerials = new Uint16Array(200), this.mesh.updateMatrix =
                function () {
                    var a = this.vgbatch, b = a.types, d = a.indices, e = a.mapviewer,
                        g = e.manipulator.cameraAngleVector.x, f = -e.manipulator.cameraAngleVector.y,
                        h = e.manipulator.orientationSerial, k = a.orientationSerials, l = e.manipulator.radius,
                        m = (e.camera.vg.cameraMatrix3 || new THREE.Matrix3).elements;
                    Object.keys(a.pois).forEach(function (e) {
                        var n = a.pois[e], q = n.parameters;
                        if (q) {
                            var u = 0,
                                u = q.zoomScaleFast ? .02 * l * q.zoomScaleFactor : .15 * Math.sqrt(l) * q.zoomScaleFactor;
                            0 < u && u !== q._zoomScale && -1 !== q.width && -1 !== q.height && (q._zoomScale =
                                u, n.updateVisibility());
                            d[6 * e] !== d[6 * e + 1] && (h != k[e] || q._dirty || 0 < u) && (k[e] = h, q._dirty = !1, e = b[4 * e], q = 0 < u ? u : 1, 2 > e && 0 < u ? n.updateGeometryAttributesWithScale(q) : 2 === e ? n.updateGeometryAttributeFace2d(f, g, q) : 3 === e && n.updateGeometryAttributeFacing(m, q))
                        }
                    });
                    THREE.Object3D.prototype.updateMatrix.apply(this)
                }, this.mesh.vgbatch = this);
            this.mesh.renderDepth = d;
            this.capacity = 200;
            this.nextFreeQuadNumber = this.inuse = 0;
            this.vertices = new Float32Array(2400);
            this.types = new Float32Array(800);
            this.center = new Float32Array(2400);
            this.centerOffset = new Float32Array(1600);
            this.visibilityRamp = new Float32Array(3200);
            this.normals = new Float32Array(2400);
            this.uvs = new Float32Array(1600);
            this.angleVector = new Float32Array(1600);
            this.geometry.addAttribute("position", new THREE.BufferAttribute(this.vertices, 3));
            this.geometry.addAttribute("type", new THREE.BufferAttribute(this.types, 1));
            this.geometry.addAttribute("center", new THREE.BufferAttribute(this.center, 3));
            this.geometry.addAttribute("centerOffset", new THREE.BufferAttribute(this.centerOffset,
                2));
            this.geometry.addAttribute("normal", new THREE.BufferAttribute(this.normals, 3));
            this.geometry.addAttribute("uv", new THREE.BufferAttribute(this.uvs, 2));
            this.geometry.addAttribute("visibilityRamp", new THREE.BufferAttribute(this.visibilityRamp, 4));
            this.geometry.addAttribute("angleVector", new THREE.BufferAttribute(this.angleVector, 2));
            this.pois = []
        }

        h.prototype.constructor = h;
        h.prototype.dispose = function () {
            this.texture.vg.nbRefs--;
            this.poiBatches.removeBatch(this);
            this.pois = this.angleVector = this.uvs =
                this.normals = this.visibilityRamp = this.centerOffset = this.center = this.types = this.vertices = this.poiBatches = null;
            this.mesh = this.mesh.vgbatch = null;
            this.material.dispose();
            this.geometry.dispose()
        };
        h.prototype.isFull = function (a) {
            return this.nextFreeQuadNumber + a - 1 >= this.capacity
        };
        h.prototype.allocateNextFreeQuad = function (a) {
            var b = this.nextFreeQuadNumber++;
            this.inuse++;
            var d = 0, d = 6 * this.nextFreeQuadNumber, e = this.indices,
                f = new (65535 < d ? Uint32Array : Uint16Array)(d), h = d = 0;
            if (e) {
                for (; d < 6 * b; ++d) f[d] = e[d];
                h = 4 * b
            }
            a ?
                (f[d] = h, f[d + 1] = h + 1, f[d + 2] = h + 3, f[d + 3] = h + 1, f[d + 4] = h + 2, f[d + 5] = h + 3) : (f[d] = 0, f[d + 1] = 0, f[d + 2] = 0, f[d + 3] = 0, f[d + 4] = 0, f[d + 5] = 0);
            this.indices = f;
            this.geometry.addAttribute("index", new THREE.BufferAttribute(this.indices, 1));
            return b
        };
        h.prototype.getPickableFromIntersection = function (a) {
            if (!this.pois) return !1;
            if (a && a.face) {
                var b = a.face.a / 4 | 0;
                if (b < this.nextFreeQuadNumber) {
                    for (; "undefined" === typeof this.pois[b];) b--;
                    var d = this.pois[b].parameters;
                    if (!d) return !1;
                    a = a.distance;
                    return a < d.visibilityRampStartVisible || a >
                    d.visibilityRampFullyInvisible ? !1 : {
                        publicObject: this.pois[b].proxy.publicPOI,
                        options: {id: d.id, poi: d}
                    }
                }
            }
            return !1
        };
        h.prototype.recalculatePositionCameraFacing = function (a, b, d) {
            a = a.matrix;
            var e = new THREE.Matrix3;
            a = a.elements;
            var f = e.elements;
            f[0] = a[0];
            f[1] = a[1];
            f[2] = a[2];
            f[3] = a[4];
            f[4] = a[5];
            f[5] = a[6];
            f[6] = a[8];
            f[7] = a[9];
            f[8] = a[10];
            var h = b._halfWidth, p = b._halfHeight;
            a = b._center;
            b = b._centerZ;
            var f = new THREE.Vector3(-h, -p, 0), r = new THREE.Vector3(h, -p, 0), v = new THREE.Vector3(h, p, 0),
                h = new THREE.Vector3(-h, p,
                    0);
            f.applyMatrix3(e);
            r.applyMatrix3(e);
            v.applyMatrix3(e);
            h.applyMatrix3(e);
            var e = d + 1, p = d + 2, u = d + 3, x = this.geometry.getAttribute("position");
            x.setXYZ(d, f.x + a.x, f.y + a.y, f.z + b);
            x.setXYZ(e, r.x + a.x, r.y + a.y, r.z + b);
            x.setXYZ(p, v.x + a.x, v.y + a.y, v.z + b);
            x.setXYZ(u, h.x + a.x, h.y + a.y, h.z + b);
            x.needsUpdate = !0
        };
        h.prototype.recalculatePositionFace2D = function (a, b, d, e) {
            var f = d._halfWidth, h = d._halfHeight, p = d._center;
            d = d._centerZ;
            var r = e + 1, v = e + 2, u = e + 3, x = a * f, f = b * f;
            a *= h;
            b *= h;
            h = this.geometry.getAttribute("position");
            h.setXYZ(e,
                p.x - f + a, p.y - x - b, d);
            h.setXYZ(r, p.x + f + a, p.y + x - b, d);
            h.setXYZ(v, p.x + f - a, p.y + x + b, d);
            h.setXYZ(u, p.x - f - a, p.y - x + b, d);
            h.needsUpdate = !0
        };
        h.prototype.createElement = function (b, d, e, f) {
            f._textAspectRatio = b;
            f._zOffset = e;
            f._center = f.position;
            f._centerZ = (f.position.z || 0) + e;
            b = this.allocateNextFreeQuad(f.visible);
            d = new a(this, b, f, d);
            this.pois[b] = d;
            this.geometry.needsUpdate = !0;
            this.geometry.computeBoundingSphere();
            this.mesh.updateMatrix();
            this.mesh.updateMatrixWorld(!0);
            return d
        };
        h.prototype.createMultiLineText = function (a,
                                                    d, e, f, h) {
            h._textAspectRatio = a;
            h._zOffset = f;
            h._center = h.position;
            h._centerZ = (h.position.z || 0) + f;
            for (a = 0; a < d.length; a++) d[a].index = this.allocateNextFreeQuad(h.visible);
            e = new b(this, d[0].index, h, d, e);
            this.pois[d[0].index] = e;
            this.geometry.needsUpdate = !0;
            this.geometry.computeBoundingSphere();
            this.mesh.updateMatrix();
            this.mesh.updateMatrixWorld(!0);
            return e
        };
        return h
    });
    define("com/visioglobe/web/helpers/TextureAtlas", [], function () {
        var a = function (a) {
            this.x = a.x;
            this.y = a.y;
            this.width = a.width;
            this.height = a.height;
            this.right = this.left = this.image = null
        };
        a.prototype.isLeaf = function () {
            return null === this.left && null === this.right
        };
        a.prototype.insert = function (b) {
            if (this.isLeaf()) {
                if (null !== this.image || b.width > this.width || b.height > this.height) return null;
                if (b.width === this.width && b.height === this.height) return this.image = b, this;
                this.width - b.width > this.height - b.height ? (this.left =
                    new a({
                        x: this.x,
                        y: this.y,
                        width: b.width,
                        height: this.height
                    }), this.right = new a({
                    x: this.x + b.width,
                    y: this.y,
                    width: this.width - b.width,
                    height: this.height
                })) : (this.left = new a({
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: b.height
                }), this.right = new a({
                    x: this.x,
                    y: this.y + b.height,
                    width: this.width,
                    height: this.height - b.height
                }));
                return this.left.insert(b)
            }
            var e = this.left.insert(b);
            return null !== e ? e : this.right.insert(b)
        };
        var b = function (a) {
            this.width = "undefined" !== typeof a.width ? a.width : 2048;
            this.height = "undefined" !==
            typeof a.height ? a.height : 2048;
            this.canvas = a = document.createElement("canvas");
            a.width = this.width;
            a.height = this.height;
            this.canvasContext = a.getContext("2d");
            this.count = 0;
            this.resetNodes()
        };
        b.prototype.resetNodes = function () {
            this.root = new a({x: 0, y: 0, width: this.width, height: this.height});
            this.nodesBySrc = {}
        };
        b.prototype.insert = function (a, b) {
            b = b || 0;
            var f = this.root.insert({width: a.width + 2 * b, height: a.height + 2 * b});
            if (null === f) return !1;
            this.count++;
            this.canvasContext.drawImage(a, f.x + b, f.y + b);
            return f
        };
        b.prototype.getOrInsert =
            function (a) {
                var b = a.src;
                if ("undefined" !== typeof this.nodesBySrc[b]) return this.nodesBySrc[b];
                a = this.insert(a);
                return this.nodesBySrc[b] = a
            };
        b.prototype.isLargerThanAtlas = function (a, b) {
            b = b || 0;
            return a.width + b > this.width || a.height + b > this.height
        };
        b.prototype.getTexturePlacement = function (a) {
            a = this.root.insert(a);
            if (null === a) return !1;
            this.count++;
            a.uvx = a.x / this.canvas.width;
            a.uvy = a.y / this.canvas.height;
            a.image = b.anonymousCounter;
            return this.nodesBySrc[b.anonymousCounter++] = a
        };
        b.prototype.remove = function (a) {
            a =
                a.src;
            var b = this.nodesBySrc[a];
            "undefined" !== typeof b && (this.count--, b.image = null, delete this.nodesBySrc[a])
        };
        b.anonymousCounter = 0;
        return b
    });
    define("com/visioglobe/web/poi/POIBatches", ["com/visioglobe/web/poi/POIBatch", "com/visioglobe/web/helpers/TextureAtlas", "com/visioglobe/web/helpers/TextGenerator"], function (a, b, d) {
        function e(a, b, e, k) {
            this.lod = a;
            this.renderDepthPOI = e;
            this.overlay = b.overlay;
            this.dynamic = !b.fixed || 0 < b.zoomScaleFactor;
            this.textGenerator = k || new d;
            this.batches = []
        }

        e.prototype.constructor = e;
        e.prototype.removeBatch = function (a) {
            index = this.batches.indexOf(a);
            -1 !== index && (this.batches.splice(index, 1), this.textGenerator.disposeTexture(a.texture),
                index = this.lod.pickables.indexOf(a.mesh), -1 !== index && this.lod.pickables.splice(index, 1), a.mesh.parent && a.mesh.parent.remove(a.mesh), a.dynamic && (index = this.lod.cameraUpdatableObjects.indexOf(a.mesh), -1 !== index && this.lod.cameraUpdatableObjects.splice(index, 1)))
        };
        e.prototype.addBatch = function (a) {
            this.batches.push(a);
            var b = a.mesh;
            this.lod.contentNode.add(b);
            b.vg = {id: !0, batch: a};
            this.lod.pickables.push(b);
            a.dynamic && this.lod.cameraUpdatableObjects.push(a.mesh)
        };
        e.prototype.getBatch = function (b, d, e, k, l) {
            if (k) for (var m =
                0, n = this.batches.length; m < n; ++m) if (k = this.batches[m], k.texture === b && !k.isFull(l)) return this.batches[m];
            k = 0 == this.batches.length ? {} : this.batches[this.batches.length - 1];
            if (k.texture !== b || k.isFull(l)) k = new a(b, this, this.renderDepthPOI, d, this.overlay, this.dynamic), k.addPoiVariables = e, this.addBatch(k);
            return k
        };
        e.prototype.createPOI = function (a, d) {
            var e = a.MapviewerPrivate, k = a._mapviewer, l = d.text;
            if ("undefined" !== typeof l && "" !== l) {
                var m = l.replace(/\s+/g, " ").trim().split(" ");
                if (d.multiline && 1 < m.length) {
                    l =
                        this.textGenerator.generateTextOnAtlas(b, " ", d);
                    if (!1 === l) return !1;
                    for (var n = [], q = 0, p = 0, r = !1, v = 0; v < m.length; v++) {
                        var u = m[v], x = this.textGenerator.generateTextOnAtlas(b, u, d);
                        r || (r = x.texture);
                        if (!1 === x || r !== x.texture) return !1;
                        p += x.width;
                        q = Math.max(q, x.height);
                        n.push({
                            text: u,
                            uvArray: x.geometry.attributes.uv.array,
                            width: x.width,
                            height: x.height,
                            aspectRatio: x.aspectRatio,
                            space: !1
                        });
                        v < m.length - 1 && (p += l.width)
                    }
                    m = p / q;
                    r = this.getBatch(r, k, a, !1, n.length);
                    e = r.createMultiLineText(m, n, l, e.zOffsetPOI, d)
                } else {
                    x = this.textGenerator.generateTextOnAtlas(b,
                        l, d);
                    if (!1 === x) return !1;
                    r = this.getBatch(x.texture, k, a, !1, 1);
                    e = r.createElement(x.aspectRatio, x.geometry.attributes.uv.array, e.zOffsetPOI, d)
                }
            } else {
                x = this.textGenerator.generateIconOnAtlasFromImage(b, d.url, k.textures[d.url].texture.image);
                if (!1 === x) return !1;
                x.aspectRatio = 1;
                r = this.getBatch(x.texture, k, a, !0, 1);
                e = r.createElement(x.aspectRatio, x.geometry.attributes.uv.array, e.zOffsetPOI, d)
            }
            k.requestRedraw();
            return e
        };
        return e
    });
    define("com/visioglobe/web/poi/POIFactory", ["com/visioglobe/web/poi/PublicPOI", "com/visioglobe/web/poi/POI", "com/visioglobe/web/poi/POIBatches", "com/visioglobe/web/helpers/CachedTexture"], function (a, b, d, e) {
        var f = {
            DEFAULT_POI_OPTIONS: {
                family: "Arial",
                textTextureHeight: 64,
                color: 16777215,
                visibilityRampStartVisible: 2,
                visibilityRampFullyVisible: 5,
                visibilityRampStartInvisible: 3E3,
                visibilityRampFullyInvisible: 5E3
            }, removeFromPois: function (a, b, d) {
                if ("undefined" !== typeof b && null !== b) {
                    var e = a.pois[b];
                    "undefined" !==
                    typeof e && (d = e.indexOf(d), -1 !== d && (e.splice(d, 1), 0 == e.length && delete a.pois[b]))
                }
            }, addToPois: function (a, b, d) {
                "undefined" !== typeof b && null !== b && ("undefined" === typeof a.pois[b] && (a.pois[b] = []), a.pois[b].push(d))
            }, updateOrCreatePublicPOI: function (b, d, e) {
                if (e) e.proxy = d; else {
                    e = new a(d);
                    var l = d.options("id");
                    f.addToPois(b._mapviewer, l, e)
                }
                return d.publicPOI = e
            }, createPOIBatchElement: function (a, b, e, f, m) {
                var n = a.MapviewerPrivate, q = a._mapviewer, p;
                m ? p = b.overlay ? e.poiBatchesOverlay || (e.poiBatchesOverlay = new d(e,
                    b, n.renderDepthPOIOverlay)) : !b.fixed || 0 < b.zoomScaleFactor ? e.poiBatchesFacing || (e.poiBatchesFacing = new d(e, b, n.renderDepthPOIFacing)) : e.poiBatches || (e.poiBatches = new d(e, b, n.renderDepthPOI)) : f && (q.iconGenerator || (q.iconGenerator = new TextGenerator), p = b.overlay ? e.poiBatchesIconsOverlay || (e.poiBatchesIconsOverlay = new d(e, b, n.renderDepthPOIOverlay, q.iconGenerator)) : !b.fixed || 0 < b.zoomScaleFactor ? e.poiBatchesIconsFacing || (e.poiBatchesIconsFacing = new d(e, b, n.renderDepthPOIFacing, q.iconGenerator)) : e.poiBatchesIcons ||
                    (e.poiBatchesIcons = new d(e, b, n.renderDepthPOI, q.iconGenerator)));
                return p.createPOI(a, b)
            }, createPOI: function (a, d, k) {
                a.POIFactory = f;
                var l = a._mapviewer, m, n = f.DEFAULT_POI_OPTIONS, n = {
                    text: "undefined" !== typeof d.text && "" !== d.text ? String(d.text) : "",
                    url: d.url,
                    model: d.model,
                    selector: d.selector,
                    textTextureHeight: d.textTextureHeight || n.textTextureHeight,
                    family: d.family || n.family,
                    color: "undefined" !== typeof d.color ? d.color : n.color,
                    position: d.position || {x: 0, y: 0, z: 0},
                    alignment: d.alignment || {x: 0, y: 0},
                    _textAspectRatio: 1,
                    multiline: d.multiline || !1,
                    _textNbLines: 1,
                    scale: d.scale || d.iconScale || d.icon_scale || {x: 1, y: 1, z: 1},
                    zoomScaleFactor: d.zoomScaleFactor || 0,
                    zoomScaleFast: d.zoomScaleFast || !1,
                    _zoomScale: 0,
                    _previousZoomScale: 0,
                    angle: d.angle,
                    heading: d.heading,
                    _inverseAngleInRadians: 0,
                    floor: "undefined" !== typeof d.floor ? d.floor : l.currentFloorName,
                    lod: d.lod,
                    visible: "undefined" !== typeof d.visible ? d.visible : !0,
                    id: "undefined" !== typeof d.id ? d.id : "_anonymous" + ++l._anonymous_poi_counter,
                    visibilityRampStartVisible: d.visibilityRampStartVisible ||
                    n.visibilityRampStartVisible,
                    visibilityRampFullyVisible: d.visibilityRampFullyVisible || n.visibilityRampFullyVisible,
                    visibilityRampStartInvisible: d.visibilityRampStartInvisible || n.visibilityRampStartInvisible,
                    visibilityRampFullyInvisible: d.visibilityRampFullyInvisible || n.visibilityRampFullyInvisible,
                    clickable: "undefined" !== typeof d.clickable ? d.clickable : !0,
                    fixed: "undefined" !== typeof d.fixed ? d.fixed : !1,
                    width: "undefined" !== typeof d.width && 0 !== d.width ? d.width : -1,
                    height: "undefined" !== typeof d.height && 0 !==
                    d.height ? d.height : -1,
                    overlay: "undefined" !== typeof d.overlay ? d.overlay : !1,
                    flip: "undefined" !== typeof d.flip ? d.flip : !1,
                    face2d: "undefined" !== typeof d.face2d ? d.face2d : !1,
                    image: "undefined" !== typeof d.image ? d.image : !1,
                    onObjectMouseOver: d.onObjectMouseOver,
                    onObjectMouseOut: d.onObjectMouseOut,
                    onObjectMouseUp: d.onObjectMouseUp,
                    _vgnobatch: "undefined" !== typeof d.vgnobatch ? d.vgnobatch : !1,
                    _vgnobatchfacing: "undefined" !== typeof d.vgnobatchfacing ? d.vgnobatchfacing : !1,
                    _vgnobatchicon: "undefined" !== typeof d.vgnobatchicon ?
                        d.vgnobatchicon : !1,
                    _empty: !1
                };
                "number" === typeof n.heading && (n.angle = d.heading - l.cameraNorthRotation);
                for (n.angle = "undefined" !== typeof n.angle ? n.angle : 0; 0 > n.angle;) n.angle += 360;
                for (; 360 < n.angle;) n.angle -= 360;
                n._inverseAngleInRadians = 2 * Math.PI - n.angle * Math.PI / 180;
                "number" === typeof n.scale && (n.scale = {x: n.scale, y: n.scale, z: n.scale});
                d = "undefined" !== typeof n.url && "" !== n.url;
                var q = "undefined" !== typeof n.text && "" !== n.text,
                    p = "undefined" !== typeof n.model && "" !== n.model,
                    r = "undefined" !== typeof n.selector && "" !==
                        n.url, v = !1;
                d && (v = (v = l.textures[n.url]) && v.loaded);
                n._empty = !(d && v || q || p || r);
                var u = l.scene, x = l.getFloor(n.floor);
                null === x && (x = l.getFloor(l.currentFloorName));
                if (null !== x) {
                    m = "undefined" !== typeof n.lod ? x.getLOD(n.lod) : x.floorContentLOD;
                    if (!n.overlay && !m) return null;
                    u = m.contentNode
                }
                if (!(d && v || q || p || r)) return m = new b(a, n, m, u, d, q, p, r), k && l.requestRedraw(), m = f.updateOrCreatePublicPOI(a, m.proxy, k), d && !v && (a = n.url, m.options("url", ""), new e(l, a, !0, function (a, b) {
                    return function (d) {
                        b.options("url", a)
                    }
                }(a, m))),
                    m;
                var x = !1, w = l.vgnobatch || n._vgnobatch, z = l.vgnobatchfacing || n._vgnobatchfacing,
                    l = l.vgnobatchicon || n._vgnobatchicon;
                p || r || w || z && !n.fixed || !(!l && !q && d && v || q && !d) || 0 !== n.alignment.x || 0 !== n.alignment.y || (x = this.createPOIBatchElement(a, n, m, d, q));
                if (x) return this.updateOrCreatePublicPOI(a, x.proxy, k);
                l = new b(a, n, m, u, d, q, p, r);
                return this.updateOrCreatePublicPOI(a, l.proxy, k)
            }, onModelLoaded: function (a, b, d, e, f, n) {
                var q;
                if (3.1 === b.version) {
                    var p = [];
                    Object.keys(b.materials).forEach(function (a) {
                        a = new THREE.MeshBasicMaterial({
                            map: b.materials[a].map,
                            color: 16777215, side: THREE.DoubleSide, transparent: !0, alphaTest: .1, opacity: e
                        });
                        p.push(a)
                    });
                    q = new THREE.MeshFaceMaterial(p);
                    q = new THREE.Mesh(b.geometry, q);
                    q.matrixAutoUpdate = !1;
                    q.vg = {id: d.id, poi: d, originalColor: 16777215};
                    n.pickables.push(q);
                    var r;
                    null === b.bbox ? (r = new THREE.Box3, r.setFromObject(q), b.bbox = r) : r = b.bbox;
                    r = r.size();
                    r = Math.max(r.x, r.y, r.z) / d.scale.x;
                    q.position.x = 0;
                    q.position.y = 0;
                    q.position.z = 0;
                    q.scale.x = 1 / r;
                    q.scale.y = -1 / r;
                    q.scale.z = -1 / r;
                    q.updateMatrix();
                    q.traverse(function (a) {
                        a instanceof THREE.Mesh &&
                        (a.castShadow = !0, a.receiveShadow = !0)
                    })
                } else if (4.4 <= b.version) q = b.result.scene.clone(void 0, !1), q.updateMatrixWorld(!0), q.matrixAutoUpdate = !1, q.traverse(function (a) {
                    a.matrixAutoUpdate = !1;
                    if (a instanceof THREE.Mesh) {
                        (a.material instanceof THREE.MeshBasicMaterial || a.material instanceof THREE.MeshLambertMaterial || a.material instanceof THREE.MeshPhongMaterial) && a.material.color.setHex(16777215);
                        a.material.side = THREE.DoubleSide;
                        a.material.transparent = !0;
                        a.material.alphaTest = .1;
                        a.material.opacity = e;
                        if (a.material.map) {
                            var b =
                                a.material.map;
                            b.wrapS = THREE.RepeatWrapping;
                            b.wrapT = THREE.RepeatWrapping
                        }
                        a.material.map && (a.material.map.needsUpdate = !0);
                        a.vg = {id: d.id, poi: d, originalColor: 16777215};
                        n.pickables.push(a);
                        a.castShadow = !0;
                        a.receiveShadow = !0
                    }
                }), null === b.bbox ? (r = new THREE.Box3, r.setFromObject(q), b.bbox = r) : r = b.bbox, r = 2 * Math.max(Math.abs(r.min.x), Math.abs(r.max.x), Math.abs(r.min.y), Math.abs(r.max.y)) / Math.max(d.scale.x, d.scale.y), q.position.x = 0, q.position.y = 0, q.position.z = 0, q.scale.x = 1 / r, q.scale.y = 1 / r, q.scale.z = 1 / r, q.rotation.x =
                    Math.PI / 2, q.updateMatrix(); else if (3.2 === b.version) {
                    for (r in b.result.materials) (b.result.materials[r] instanceof THREE.MeshBasicMaterial || b.result.materials[r] instanceof THREE.MeshLambertMaterial || b.result.materials[r] instanceof THREE.MeshPhongMaterial) && b.result.materials[r].color.setHex(16777215), b.result.materials[r].side = THREE.DoubleSide, b.result.materials[r].transparent = !0, b.result.materials[r].alphaTest = .1, b.result.materials[r].opacity = e, b.result.materials[r].map && (q = b.result.materials[r].map,
                        q.wrapS = THREE.RepeatWrapping, q.wrapT = THREE.RepeatWrapping);
                    q = b.result.scene.clone(void 0, !1);
                    q.traverse(function (a) {
                        a instanceof THREE.Mesh && (a.vg = {
                            id: d.id,
                            poi: d,
                            originalColor: 16777215
                        }, n.pickables.push(a), a.castShadow = !0, a.receiveShadow = !0)
                    });
                    null === b.bbox ? (r = new THREE.Box3, r.setFromObject(q), b.bbox = r) : r = b.bbox;
                    r = 2 * Math.max(Math.abs(r.min.x), Math.abs(r.max.x), Math.abs(r.min.y), Math.abs(r.max.y)) / Math.max(d.scale.x, d.scale.y);
                    q.position.x = 0;
                    q.position.y = 0;
                    q.position.z = 0;
                    q.scale.x = 1 / r;
                    q.scale.y = 1 /
                        r;
                    q.scale.z = 1 / r;
                    q.rotation.x = .5 * Math.PI;
                    q.updateMatrix()
                }
                q.name = "poi_model";
                f.add(q);
                f.updateMatrixWorld(!0);
                d._opacity = null;
                a.mustUpdateCameraObjects = !0;
                a.requestRedraw()
            }, removeMaterial: function (a, b, d) {
                null !== b && d.traverse(function (b) {
                    b && "undefined" !== typeof b.material && null !== b.material.map && "undefined" !== typeof b.material.map && ("undefined" !== typeof b.material.map.vg ? (b.material.map.vg.nbRefs--, 0 >= b.material.map.vg.nbRefs && (b.material.map.dispose(), b.material.map.sourceFile && "undefined" !== typeof a.textures[b.material.map.sourceFile] &&
                    delete a.textures[b.material.map.sourceFile], b.material.map.image instanceof HTMLCanvasElement || (b.material.map.image = null))) : (b.material.map.dispose(), b.material.map.sourceFile && "undefined" !== typeof a.textures[b.material.map.sourceFile] && delete a.textures[b.material.map.sourceFile], b.material.map.image instanceof HTMLCanvasElement || (b.material.map.image = null)))
                })
            }
        };
        return f
    });
    define("com/visioglobe/web/helpers/SvgUtils", ["require", "com/visioglobe/web/helpers/MathUtils"], function (a) {
        function b(a) {
            var b = a.indexOf("("), d = a.indexOf(")");
            if (-1 === b || -1 === d) return [];
            a = a.substring(b + 1, d);
            a = a.replace(/[ ,]/g, " ");
            a = a.split(" ");
            for (b = 0; b < a.length; ++b) "" === a[b] && (a.splice(b, 1), --b);
            return a = a.map(function (a) {
                return parseFloat(a)
            })
        }

        var d = a("com/visioglobe/web/helpers/MathUtils"), e = function () {
        };
        e.trim = function (a) {
            return a.replace(/^\s+|\s+$/g, "")
        };
        e.compressSpaces = function (a) {
            return a.replace(/[\s\r\t\n]+/gm,
                " ")
        };
        e.Point = function (a, b) {
            this.x = a;
            this.y = b;
            this.clone = function () {
                return new e.Point(this.x, this.y)
            };
            this.angleTo = function (a) {
                return Math.atan2(a.y - this.y, a.x - this.x)
            };
            this.equals = function (a, b) {
                b = b || .01;
                return Math.abs(this.x - a.x) < b && Math.abs(this.y - a.y) < b ? !0 : !1
            }
        };
        e.equalsPoints = function (a, b, d) {
            d = d || .01;
            return Math.abs(b.x - a.x) < d && Math.abs(b.y - a.y) < d ? !0 : !1
        };
        e.Parser = {};
        e.Parser.color = function (a) {
            if ("undefined" === typeof a) return 0;
            var b, d = parseInt;
            a = a.replace(/\s\s*/g, "");
            if (b = /^#([\da-fA-F]{2})([\da-fA-F]{2})([\da-fA-F]{2})/.exec(a)) b =
                [d(b[1], 16), d(b[2], 16), d(b[3], 16)]; else if (b = /^#([\da-fA-F])([\da-fA-F])([\da-fA-F])/.exec(a)) b = [17 * d(b[1], 16), 17 * d(b[2], 16), 17 * d(b[3], 16)]; else return 0;
            return 65536 * b[0] + 256 * b[1] + b[2]
        };
        var f = function (a) {
            this.tokens = a.split(" ")
        };
        f.prototype.reset = function () {
            this.i = -1;
            this.previousCommand = this.command = "";
            this.start = new e.Point(0, 0);
            this.control = new e.Point(0, 0);
            this.current = new e.Point(0, 0);
            this.points = [];
            this.angles = []
        };
        f.prototype.isEnd = function () {
            return this.i >= this.tokens.length - 1
        };
        f.prototype.isCommandOrEnd =
            function () {
                return this.isEnd() ? !0 : null !== this.tokens[this.i + 1].match(/^[A-Za-z]$/)
            };
        f.prototype.isRelativeCommand = function () {
            return this.command === this.command.toLowerCase()
        };
        f.prototype.getToken = function () {
            this.i += 1;
            return this.tokens[this.i]
        };
        f.prototype.getScalar = function () {
            return parseFloat(this.getToken())
        };
        f.prototype.nextCommand = function () {
            this.previousCommand = this.command;
            this.command = this.getToken()
        };
        f.prototype.getPoint = function () {
            var a = new e.Point(this.getScalar(), this.getScalar());
            return this.makeAbsolute(a)
        };
        f.prototype.getAsControlPoint = function () {
            var a = this.getPoint();
            return this.control = a
        };
        f.prototype.getAsCurrentPoint = function () {
            var a = this.getPoint();
            return this.current = a
        };
        f.prototype.getReflectedControlPoint = function () {
            return "c" !== this.previousCommand.toLowerCase() && "s" !== this.previousCommand.toLowerCase() ? this.current : new e.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y)
        };
        f.prototype.makeAbsolute = function (a) {
            this.isRelativeCommand() && (a.x = this.current.x + a.x, a.y = this.current.y +
                a.y);
            return a
        };
        f.prototype.addMarker = function (a, b, d) {
            null !== d && 0 < this.angles.length && null === this.angles[this.angles.length - 1] && (this.angles[this.angles.length - 1] = this.points[this.points.length - 1].angleTo(d));
            this.addMarkerAngle(a, null === b ? null : b.angleTo(a))
        };
        f.prototype.addMarkerAngle = function (a, b) {
            this.points.push(a);
            this.angles.push(b)
        };
        f.prototype.getMarkerPoints = function () {
            return this.points
        };
        f.prototype.getMarkerAngles = function () {
            for (var a = 0; a < this.angles.length; a++) if (null === this.angles[a]) for (var b =
                a + 1; b < this.angles.length; b++) if (null !== this.angles[b]) {
                this.angles[a] = this.angles[b];
                break
            }
            return this.angles
        };
        e.Parser.path = function (a) {
            a = a.replace(/,/gm, " ").replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm, "$1 $2").replace(/([MmZzLlHhVvCcSsQqTtAa])([^\s])/gm, "$1 $2").replace(/([^\s])([MmZzLlHhVvCcSsQqTtAa])/gm, "$1 $2").replace(/([0-9])([+\-])/gm, "$1 $2").replace(/(\.[0-9]*)(\.)/gm, "$1 $2").replace(/([Aa](\s+[0-9]+){3})\s+([01])\s*([01])/gm, "$1 $3 $4 ");
            a = e.compressSpaces(a);
            a = e.trim(a);
            this.PathParser = f;
            return new this.PathParser(a)
        };
        e.convertRectToPath = function (a) {
            a = jQuery(a);
            var b = a.attr("x") || 0, d = a.attr("y") || 0, e = a.attr("width"), f = a.attr("height"),
                b = "" + ("m" + b + "," + d + "") + ("l0," + f + ""), b = b + ("l" + e + ",0"),
                b = b + ("l0," + -f + ""), b = b + ("l" + -e + ",0"), b = b + "z";
            a.attr("d", b)
        };
        e.convertCircleToPath = function (a, b) {
            for (var d = jQuery(a), e = parseFloat(d.attr("cx")), f = parseFloat(d.attr("cy")), h = parseFloat(d.attr("r")), p = "", r, v, u, x, w = b || 24, z = 0; z < w; ++z) if (r = e + h * Math.cos(2 * z * Math.PI / (w - 1)), v = f + h * Math.sin(2 *
                    z * Math.PI / (w - 1)), 0 === z) p += "m" + r + "," + v + "", u = r, x = v; else {
                var F = r - u, B = v - x;
                u = r;
                x = v;
                p += "l" + F + "," + B + ""
            }
            d.attr("d", p + "z")
        };
        e.convertEllipseToPath = function (a, b) {
            for (var d = jQuery(a), e = parseFloat(d.attr("cx")), f = parseFloat(d.attr("cy")), h = parseFloat(d.attr("rx")), p = parseFloat(d.attr("ry")), r = "", v, u, x, w, z = b || 24, F = 0; F < z; ++F) if (v = e + h * Math.cos(2 * F * Math.PI / (z - 1)), u = f + p * Math.sin(2 * F * Math.PI / (z - 1)), 0 === F) r += "m" + v + "," + u + "", x = v, w = u; else {
                var B = v - x, H = u - w;
                x = v;
                w = u;
                r += "l" + B + "," + H + ""
            }
            d.attr("d", r + "z")
        };
        e.convertPolygonToPath =
            function (a) {
                a = jQuery(a);
                for (var b = "", d = a.attr("points").split(/[, ]/).filter(function (a) {
                    return "" !== a
                }).map(function (a) {
                    return "" === a ? null : parseFloat(a)
                }), e, f, h = 0, p = d.length / 2; h < p; ++h) {
                    var r = d[2 * h + 0], v = d[2 * h + 1];
                    if (0 === h) b += "m" + r + "," + v + "", e = r, f = v; else {
                        var u = r - e, x = v - f;
                        e = r;
                        f = v;
                        b += "l" + u + "," + x + ""
                    }
                }
                a.attr("d", b + "z")
            };
        e.deg2rad = function (a) {
            return a * d.DEG2RAD
        };
        e.Transform = function (a) {
            this.matrix = a || [1, 0, 0, 1, 0, 0]
        };
        e.Transform.prototype.multiply = function (a, b) {
            var d = a.matrix[0], e = a.matrix[1], f = a.matrix[2], h =
                    a.matrix[3], p = a.matrix[4], r = a.matrix[5], v = b.matrix[0], u = b.matrix[1], x = b.matrix[2],
                w = b.matrix[3], z = b.matrix[4], F = b.matrix[5];
            this.matrix[0] = d * v + e * x;
            this.matrix[1] = d * u + e * w;
            this.matrix[2] = f * v + h * x;
            this.matrix[3] = f * u + h * w;
            this.matrix[4] = p * v + r * x + 1 * z;
            this.matrix[5] = p * u + r * w + 1 * F
        };
        e.Transform.prototype.multiplyVector = function (a) {
            var b = a.x, d = a.y;
            a.x = this.matrix[0] * b + this.matrix[2] * d + this.matrix[4];
            a.y = this.matrix[1] * b + this.matrix[3] * d + this.matrix[5]
        };
        e.Transform.prototype.decompose = function () {
            var a = {}, b = d.sign(this.matrix[0]);
            0 === b && (b = 1);
            var e = d.sign(this.matrix[3]);
            0 === e && (e = 1);
            a.sx = b * Math.sqrt(this.matrix[0] * this.matrix[0] + this.matrix[2] * this.matrix[2]);
            a.sy = e * Math.sqrt(this.matrix[1] * this.matrix[1] + this.matrix[3] * this.matrix[3]);
            a.angle = 180 * Math.atan2(-this.matrix[2], this.matrix[0]) / Math.PI;
            a.tx = this.matrix[4] / a.sx;
            a.ty = this.matrix[5] / a.sy;
            return a
        };
        var h = /((translate|rotate|matrix|scale|skewX|skewY)(\([0-9eE\-\. ,]*\)))/g;
        e.Transform.parse = function (a) {
            var d = new e.Transform([1, 0, 0, 1, 0, 0]);
            if ("undefined" === typeof a ||
                null === a) return d;
            a = a.match(h);
            for (var f in a) {
                var m = a[f], n = m.substring(0, m.indexOf("(")), m = b(m);
                switch (n) {
                    case "matrix":
                        if (6 !== m.length) return null;
                        d.multiply(new e.Transform(m), d);
                        break;
                    case "translate":
                        if (1 > m.length) return null;
                        1 === m.length && m.push(0);
                        n = [1, 0, 0, 1, m[0], m[1]];
                        d.multiply(new e.Transform(n), d);
                        break;
                    case "scale":
                        if (1 > m.length) return null;
                        1 === m.length && m.push(m[0]);
                        n = [m[0], 0, 0, m[1], 0, 0];
                        d.multiply(new e.Transform(n), d);
                        break;
                    case "rotate":
                        if (1 > m.length) return null;
                        var n = Math.cos(e.deg2rad(m[0])),
                            q = Math.sin(e.deg2rad(m[0])), n = [n, q, -q, n, 0, 0];
                        1 !== m.length && (q = new e.Transform([1, 0, 0, 1, -m[1], -m[2]]), m = new e.Transform([1, 0, 0, 1, m[1], m[2]]), q.multiply(q, new e.Transform(n)), q.multiply(q, m), n = q.matrix);
                        d.multiply(new e.Transform(n), d);
                        break;
                    case "skewX":
                        if (1 > m.length) return null;
                        m = Math.tan(e.deg2rad(m[0]));
                        n = [1, 0, m, 1, 0, 0];
                        d.multiply(new e.Transform(n), d);
                        break;
                    case "skewY":
                        if (1 > m.length) return null;
                        m = Math.tan(e.deg2rad(m[0]));
                        n = [1, m, 0, 1, 0, 0];
                        d.multiply(new e.Transform(n), d)
                }
            }
            return d
        };
        return e
    });
    define("com/visioglobe/web/TrackballManipulator", ["require", "com/visioglobe/web/helpers/MathUtils"], function (a) {
        var b = a("com/visioglobe/web/helpers/MathUtils");
        return function (a, e) {
            this.radius = 1E3;
            this.orientation = new THREE.Vector3(-.9800000000000013, 0, -1.5707963267948966);
            this.orientationSerial = 1;
            this.orientationLast = new THREE.Vector3;
            this.orientationNormalized = this.orientation.clone();
            this.target = new THREE.Vector3(0, 0, 0);
            this.translateSpeed = 1;
            this.rotationSpeed = .005 * b.RAD2DEG;
            this.rotationXMin =
                -90 * b.DEG2RAD;
            this.rotationXMax = -45 * b.DEG2RAD;
            this.zoomSpeed = .003;
            this.minRadius = 10;
            this.maxRadius = 5E3;
            this.panManipulatorEnabled = this.zoomManipulatorEnabled = this.rotationManipulatorEnabled = this.pitchManipulatorEnabled = !0;
            this.cameraAngleVector = {x: 0, y: 1};
            this.minTarget = {x: -1E9, y: -1E9};
            this.maxTarget = {x: 1E9, y: 1E9};
            this.update = function () {
                var b = !1;
                if (this.orientation.x !== this.orientationLast.x || this.orientation.y !== this.orientationLast.y || this.orientation.z !== this.orientationLast.z) this.orientationLast =
                    this.orientation.clone(), this.orientationSerial++, b = !0;
                this.orientationNormalized.x = this.orientation.x;
                for (this.orientationNormalized.z = this.orientation.z; this.orientationNormalized.z > 2 * Math.PI;) this.orientationNormalized.z -= 2 * Math.PI;
                for (; 0 > this.orientationNormalized.z;) this.orientationNormalized.z += 2 * Math.PI;
                this.previousMaxRadius != this.maxRadius && "number" === typeof a.sideInMeters && (e.far = Math.max(this.maxRadius + a.sideInMeters * Math.sqrt(2)), e.updateProjectionMatrix(), this.previousMaxRadius = this.maxRadius);
                this.radius = THREE.Math.clamp(this.radius, this.minRadius, this.maxRadius);
                this.translateSpeed = this.radius / 616;
                this.target.x = THREE.Math.clamp(this.target.x, this.minTarget.x, this.maxTarget.x);
                this.target.y = THREE.Math.clamp(this.target.y, this.minTarget.y, this.maxTarget.y);
                var h = this.orientation.z - .5 * Math.PI, g = this.orientation.x;
                e.position.x = this.target.x + Math.sin(h) * Math.cos(g) * -this.radius;
                e.position.y = this.target.y - Math.cos(h) * Math.cos(g) * -this.radius;
                e.position.z = this.target.z + Math.sin(g) * -this.radius;
                g <= .5 * -Math.PI + .001 ? (e.up.x = Math.sin(h), e.up.y = -Math.cos(h), e.up.z = 0) : (e.up.x = 0, e.up.y = 0, e.up.z = 1);
                this.cameraAngleVector.x = -Math.sin(h);
                this.cameraAngleVector.y = Math.cos(h);
                e.lookAt(this.target);
                a.mustUpdateCameraObjects = !0;
                e instanceof THREE.OrthographicCamera && a.orthographicNormalizedZoom && this.wholeRadius && (e.zoom = a.orthographicNormalizedZoom * this.wholeRadius / this.radius, e.updateProjectionMatrix());
                e.updateMatrix();
                e.updateMatrixWorld();
                e.matrixWorldInverse.getInverse(e.matrixWorld);
                e.vg || (e.vg =
                    {camera_rotation: new THREE.Euler, cameraComponents: !1, cameraMatrix3: new THREE.Matrix3});
                h = new THREE.Quaternion;
                h.setFromRotationMatrix(e.matrixWorldInverse);
                e.vg.camera_rotation.setFromQuaternion(h, "XYZ");
                e.vg.cameraComponents = e.vg.camera_rotation.toArray();
                b && (b = e.matrix.elements, h = e.vg.cameraMatrix3.elements, h[0] = b[0], h[1] = b[1], h[2] = b[2], h[3] = b[4], h[4] = b[5], h[5] = b[6], h[6] = b[8], h[7] = b[9], h[8] = b[10]);
                a.requestRedraw()
            }
        }
    });
    define("heap", [], function () {
        var a, b, d, e, f, h, g, k, l, m, n, q, p, r;
        b = Math.floor;
        l = Math.min;
        var v = function (a, b) {
            if (null == a) return -1;
            for (var d = 0, e = a.length; d < e; d++) if (a[d] === b) return d;
            return -1
        };
        a = function (a, b) {
            return a < b ? -1 : a > b ? 1 : 0
        };
        k = function (d, e, f, h, g) {
            var k;
            null == f && (f = 0);
            null == g && (g = a);
            if (0 > f) throw Error("lo must be non-negative");
            null == h && (h = d.length);
            for (; f < h;) k = b((f + h) / 2), 0 > g(e, d[k]) ? h = k : f = k + 1;
            return [].splice.apply(d, [f, f - f].concat(e)), e
        };
        f = function (b, d, e) {
            null == e && (e = a);
            b.push(d);
            return p(b, 0, b.length -
                1, e)
        };
        e = function (b, d) {
            var e, f;
            null == d && (d = a);
            e = b.pop();
            b.length ? (f = b[0], b[0] = e, r(b, 0, d)) : f = e;
            return f
        };
        g = function (b, d, e) {
            var f;
            null == e && (e = a);
            f = b[0];
            b[0] = d;
            r(b, 0, e);
            return f
        };
        h = function (b, d, e) {
            var f;
            null == e && (e = a);
            b.length && 0 > e(b[0], d) && (f = [b[0], d], d = f[0], b[0] = f[1], r(b, 0, e));
            return d
        };
        d = function (d, e) {
            var f, h, g, k, l, m;
            null == e && (e = a);
            k = function () {
                m = [];
                for (var a = 0, e = b(d.length / 2); 0 <= e ? a < e : a > e; 0 <= e ? a++ : a--) m.push(a);
                return m
            }.apply(this).reverse();
            l = [];
            h = 0;
            for (g = k.length; h < g; h++) f = k[h], l.push(r(d, f, e));
            return l
        };
        q = function (b, d, e) {
            null == e && (e = a);
            d = v(b, d);
            if (-1 !== d) return p(b, 0, d, e), r(b, d, e)
        };
        m = function (b, e, f) {
            var g, k, l;
            null == f && (f = a);
            g = b.slice(0, e);
            if (!g.length) return g;
            d(g, f);
            l = b.slice(e);
            e = 0;
            for (k = l.length; e < k; e++) b = l[e], h(g, b, f);
            return g.sort(f).reverse()
        };
        n = function (b, f, h) {
            var g, m, n, p;
            null == h && (h = a);
            if (10 * f <= b.length) {
                m = b.slice(0, f).sort(h);
                if (!m.length) return m;
                g = m[m.length - 1];
                p = b.slice(f);
                f = 0;
                for (n = p.length; f < n; f++) b = p[f], 0 > h(b, g) && (k(m, b, 0, null, h), m.pop(), g = m[m.length - 1]);
                return m
            }
            d(b, h);
            m = [];
            g = 0;
            for (f = l(f, b.length); 0 <= f ? g < f : g > f; 0 <= f ? ++g : --g) m.push(e(b, h));
            return m
        };
        p = function (b, d, e, f) {
            var h, g, k;
            null == f && (f = a);
            for (h = b[e]; e > d;) if (k = e - 1 >> 1, g = b[k], 0 > f(h, g)) b[e] = g, e = k; else break;
            return b[e] = h
        };
        r = function (b, d, e) {
            var f, h, g, k, l;
            null == e && (e = a);
            h = b.length;
            l = d;
            g = b[d];
            for (f = 2 * d + 1; f < h;) k = f + 1, k < h && !(0 > e(b[f], b[k])) && (f = k), b[d] = b[f], d = f, f = 2 * d + 1;
            b[d] = g;
            return p(b, l, d, e)
        };
        return function () {
            function b(d) {
                this.cmp = null != d ? d : a;
                this.nodes = []
            }

            b.push = f;
            b.pop = e;
            b.replace = g;
            b.pushpop = h;
            b.heapify = d;
            b.updateItem =
                q;
            b.nlargest = m;
            b.nsmallest = n;
            b.prototype.push = function (a) {
                return f(this.nodes, a, this.cmp)
            };
            b.prototype.pop = function () {
                return e(this.nodes, this.cmp)
            };
            b.prototype.peek = function () {
                return this.nodes[0]
            };
            b.prototype.contains = function (a) {
                return -1 !== v(this.nodes, a)
            };
            b.prototype.replace = function (a) {
                return g(this.nodes, a, this.cmp)
            };
            b.prototype.pushpop = function (a) {
                return h(this.nodes, a, this.cmp)
            };
            b.prototype.heapify = function () {
                return d(this.nodes, this.cmp)
            };
            b.prototype.updateItem = function (a) {
                return q(this.nodes,
                    a, this.cmp)
            };
            b.prototype.clear = function () {
                return this.nodes = []
            };
            b.prototype.empty = function () {
                return 0 === this.nodes.length
            };
            b.prototype.size = function () {
                return this.nodes.length
            };
            b.prototype.clone = function () {
                var a;
                a = new b;
                a.nodes = this.nodes.slice(0);
                return a
            };
            b.prototype.toArray = function () {
                return this.nodes.slice(0)
            };
            b.prototype.insert = b.prototype.push;
            b.prototype.top = b.prototype.peek;
            b.prototype.front = b.prototype.peek;
            b.prototype.has = b.prototype.contains;
            b.prototype.copy = b.prototype.clone;
            return b
        }()
    });
    define("underscoretiny", [], function () {
        var a = {
            isObject: function (a) {
                var d = typeof a;
                return "function" === d || "object" === d && !!a
            }, indexOf: function (a, d) {
                if (null == a) return -1;
                for (var e = 0, f = a.length; e < f; e++) if (a[e] === d) return e;
                return -1
            }, has: function (a, d) {
                return null != a && Object.prototype.hasOwnProperty.call(a, d)
            }, keys: function (b) {
                if (!a.isObject(b)) return [];
                if (Object.keys) return Object.keys(b);
                var d = [], e;
                for (e in b) a.has(b, e) && d.push(e);
                return d
            }, each: function (b, d) {
                if (null == b) return b;
                var e, f = b.length;
                if (f ===
                    +f) for (e = 0; e < f; e++) d(b[e], e, b); else {
                    var h = a.keys(b);
                    e = 0;
                    for (f = h.length; e < f; e++) d(b[h[e]], h[e], b)
                }
                return b
            }, filter: function (b, d) {
                var e = [];
                if (null == b) return e;
                a.each(b, function (a, b, g) {
                    d(a, b, g) && e.push(a)
                });
                return e
            }, isMatch: function (b, d) {
                var e = a.keys(d), f = e.length;
                if (null == b) return !f;
                for (var h = Object(b), g = 0; g < f; g++) {
                    var k = e[g];
                    if (d[k] !== h[k] || !(k in h)) return !1
                }
                return !0
            }
        };
        return a
    });
    define("vector", [], function () {
        var a = function (a, d, e) {
            this.x = a || 0;
            this.y = d || 0;
            this.z = e || 0
        };
        a.prototype = {
            negative: function () {
                return new a(-this.x, -this.y, -this.z)
            }, add: function (b) {
                return b instanceof a ? new a(this.x + b.x, this.y + b.y, this.z + b.z) : new a(this.x + b, this.y + b, this.z + b)
            }, subtract: function (b) {
                return b instanceof a ? new a(this.x - b.x, this.y - b.y, this.z - b.z) : new a(this.x - b, this.y - b, this.z - b)
            }, multiply: function (b) {
                return b instanceof a ? new a(this.x * b.x, this.y * b.y, this.z * b.z) : new a(this.x * b, this.y * b, this.z *
                    b)
            }, divide: function (b) {
                return b instanceof a ? new a(this.x / b.x, this.y / b.y, this.z / b.z) : new a(this.x / b, this.y / b, this.z / b)
            }, equals: function (a) {
                return this.x == a.x && this.y == a.y && this.z == a.z
            }, dot: function (a) {
                return this.x * a.x + this.y * a.y + this.z * a.z
            }, cross: function (b) {
                return new a(this.y * b.z - this.z * b.y, this.z * b.x - this.x * b.z, this.x * b.y - this.y * b.x)
            }, length: function () {
                return Math.sqrt(this.dot(this))
            }, lengthSq: function () {
                return this.dot(this)
            }, unit: function () {
                return this.divide(this.length())
            }, normalize: function () {
                return this.divide(this.length())
            },
            min: function () {
                return Math.min(Math.min(this.x, this.y), this.z)
            }, max: function () {
                return Math.max(Math.max(this.x, this.y), this.z)
            }, toAngles: function () {
                return {theta: Math.atan2(this.z, this.x), phi: Math.asin(this.y / this.length())}
            }, angleTo: function (a) {
                return Math.acos(this.dot(a) / (this.length() * a.length()))
            }, toArray: function (a) {
                return [this.x, this.y, this.z].slice(0, a || 3)
            }, clone: function () {
                return new a(this.x, this.y, this.z)
            }, init: function (a, d, e) {
                this.x = a;
                this.y = d;
                this.z = e;
                return this
            }
        };
        a.negative = function (a,
                               d) {
            d.x = -a.x;
            d.y = -a.y;
            d.z = -a.z;
            return d
        };
        a.add = function (b, d, e) {
            d instanceof a ? (e.x = b.x + d.x, e.y = b.y + d.y, e.z = b.z + d.z) : (e.x = b.x + d, e.y = b.y + d, e.z = b.z + d);
            return e
        };
        a.subtract = function (b, d, e) {
            d instanceof a ? (e.x = b.x - d.x, e.y = b.y - d.y, e.z = b.z - d.z) : (e.x = b.x - d, e.y = b.y - d, e.z = b.z - d);
            return e
        };
        a.multiply = function (b, d, e) {
            d instanceof a ? (e.x = b.x * d.x, e.y = b.y * d.y, e.z = b.z * d.z) : (e.x = b.x * d, e.y = b.y * d, e.z = b.z * d);
            return e
        };
        a.divide = function (b, d, e) {
            d instanceof a ? (e.x = b.x / d.x, e.y = b.y / d.y, e.z = b.z / d.z) : (e.x = b.x / d, e.y = b.y / d, e.z =
                b.z / d);
            return e
        };
        a.cross = function (a, d, e) {
            e.x = a.y * d.z - a.z * d.y;
            e.y = a.z * d.x - a.x * d.z;
            e.z = a.x * d.y - a.y * d.x;
            return e
        };
        a.unit = function (a, d) {
            var e = a.length();
            d.x = a.x / e;
            d.y = a.y / e;
            d.z = a.z / e;
            return d
        };
        a.fromAngles = function (b, d) {
            return new a(Math.cos(b) * Math.cos(d), Math.sin(d), Math.sin(b) * Math.cos(d))
        };
        a.randomDirection = function () {
            return a.fromAngles(Math.random() * Math.PI * 2, Math.asin(2 * Math.random() - 1))
        };
        a.min = function (b, d) {
            return new a(Math.min(b.x, d.x), Math.min(b.y, d.y), Math.min(b.z, d.z))
        };
        a.max = function (b,
                          d) {
            return new a(Math.max(b.x, d.x), Math.max(b.y, d.y), Math.max(b.z, d.z))
        };
        a.lerp = function (a, d, e) {
            return d.subtract(a).multiply(e).add(a)
        };
        a.fromArray = function (b) {
            return new a(b[0], b[1], b[2])
        };
        a.angleBetween = function (a, d) {
            return a.angleTo(d)
        };
        return a
    });
    define("com/visioglobe/common/routing/AStarRoutingSolver", ["heap", "underscoretiny", "vector"], function (a, b, d) {
        var e = function (a, b, d, e, f) {
            this.solver = a;
            this.origin = b;
            this.inputDestinations = d;
            this.numInputDestinations = d.length;
            this.runParameters = e;
            this.finishOnLast = f;
            this.found = !1;
            this.bestDistance = Number.POSITIVE_INFINITY;
            this.numDestinations = d.length + 1;
            this.destinations = [];
            this.bestSolution = [];
            this.nodeIDs = [];
            this.nodes = [];
            this.distances = [];
            a = 0;
            for (e = this.numDestinations; a < e; a++) this.destinations[a] =
                a;
            a = 0;
            for (e = this.numInputDestinations; a < e; a++) this.nodeIDs[a] = d[a].id, this.nodes[a] = d[a];
            this.nodeIDs[this.numInputDestinations] = b.id;
            this.nodes[this.numInputDestinations] = b;
            this.originNodeIndex = this.numInputDestinations;
            a = 0;
            for (e = this.numDestinations * this.numDestinations; a < e; a++) this.distances[a] = !1;
            this.finishOnLast ? (this.lastNodeIndex = this.numInputDestinations - 1, this.numSearchDestinations = this.numInputDestinations - 1) : this.numSearchDestinations = this.numInputDestinations
        };
        e.prototype.distance = function (a,
                                         b) {
            if (this.nodeIDs[a] == this.nodeIDs[b]) return !1;
            var d = a * this.numDestinations + b, e = this.distances[d];
            if (!1 === e) {
                var f = {legs: [], length: 0, duration: 0, status: 200},
                    n = this.solver.run(this.nodes[a], this.nodes[b], this.runParameters);
                if (!1 !== this.solver._appendRunResult(f, n, d)) return e = {found: !0}, e.distance = this.runParameters.fastest ? f.length : f.duration, this.distances[d] = e, e.distance;
                e.found = !1;
                this.distances[d] = e
            } else if (e.found) return e.distance;
            return !1
        };
        e.prototype.find = function (a, b, d, e) {
            var f, n, q, p;
            if (0 ==
                d) return !1;
            if (1 == d) {
                f = this.distance(a, this.destinations[b]);
                if (!1 !== f) {
                    if (this.finishOnLast) if (a = this.distance(this.destinations[b], this.lastNodeIndex), !1 !== a) f += a; else return !1;
                    f += e;
                    if (!1 === this.found || f < this.bestDistance) return this.found = !0, this.bestDistance = f, this.bestSolution = this.destinations.slice(0), !0
                }
                return !1
            }
            f = this.distance(a, this.destinations[b]);
            !1 !== f && (f = e + f, f < this.bestDistance && this.find(this.destinations[b], b + 1, d - 1, f));
            n = this.destinations[b];
            for (p = 1; p < d; p++) q = this.destinations[b +
            p], this.destinations[b + p] = n, this.destinations[b] = q, f = this.distance(a, q), !1 !== f && (f = e + f, f < this.bestDistance && this.find(q, b + 1, d - 1, f)), this.destinations[b + p] = q, this.destinations[b] = n;
            return !0
        };
        e.prototype.compute = function () {
            var a = [], b, d, e;
            this.find(this.originNodeIndex, 0, this.numSearchDestinations, 0);
            if (this.found) {
                b = 0;
                for (d = this.numInputDestinations; b < d; b++) e = this.bestSolution[b], a[b] = this.inputDestinations[e];
                return this.solver.runInOrder(this.origin, a, this.runParameters, this.bestSolution)
            }
            return {
                legs: [],
                length: 0, duration: 0, status: 404, message: "No solution found"
            }
        };
        var f = function (a, b) {
            this.geoinformation = b;
            "undefined" !== typeof a.routing && this.load(a.routing)
        };
        f.prototype._initializeLayerNameToIDMap = function () {
            var a = this;
            b.each(this.floors, function (b, d) {
                a.layerNameToIDMap[b.name] = d;
                a.layerIDToNameMap[d] = b.name
            })
        };
        f.prototype.getLayerID = function (a) {
            a = this.layerNameToIDMap[a];
            return "undefined" !== typeof a ? a : !1
        };
        f.prototype.getLayerIDsForHeight = function (a) {
            var d = [];
            b.each(this.floors, function (b, e) {
                a >= b.zmin &&
                a <= b.zmax && d.push(e)
            });
            return 0 < d.length ? d : !1
        };
        f.prototype._getSqDistanceOfPointNoZ = function (a, b, e) {
            var f = {onEdge: !1, distSq: 0};
            a = new d(a.x, a.y, 0);
            b = new d(b.x, b.y, 0);
            var m = new d(e.x, e.y, 0);
            e = m.subtract(b);
            var n = a.subtract(b), q = e.lengthSq();
            if (1E-6 > q) return f.distSq = n.lengthSq(), f;
            q = Math.sqrt(q);
            e = e.divide(q);
            var p = e.dot(n);
            if (0 > p) return f.distSq = n.lengthSq(), f;
            if (p < q) return a = n.subtract(e.multiply(p)), f.onEdge = !0, f.projectionFromStart = p / q, f.projectionPosition = b.add(e.multiply(p)), f.distSq = a.lengthSq(),
                f;
            a = a.subtract(m);
            f.distSq = a.lengthSq();
            return f
        };
        f.prototype._getClosestNodeWithoutZ = function (a, d, e, f) {
            f = f || {};
            searchType = f.option || "onEdge";
            var m = !1, n, q, p = this, r = {}, v = !1, u;
            if (jQuery.isArray(f.excludedModalities)) for (n = 0, q = f.excludedModalities.length; n < q; n++) u = this.modalityToID[this.modalities, f.excludedModalities[n]], -1 !== u && (v = r[u] = !0); else "string" === typeof f.excludedModalities && (u = this.modalityToID[f.excludedModalities], -1 !== u && (v = r[u] = !0));
            var x = d * d;
            b.each(e, function (d) {
                "onEdge" === searchType ?
                    (b.each(p.nodesByFloor[d], function (b) {
                        if (!1 === b.isVirtual) for (var e = 0, f = b.modalityEdges.length; e < f; e++) {
                            var g = b.modalityEdges[e];
                            if (!v || !r[g.modality]) {
                                var g = g.edge, k = p.nodes[g.endNode];
                                !1 === b.isVirtual && d === p.nodes[g.endNode].floor && (k = p._getSqDistanceOfPointNoZ(a, b, k), k.onEdge && k.distSq < x && (x = k.distSq, m = {
                                    type: "edge",
                                    node: null,
                                    edge: g,
                                    floor: d,
                                    edgeExtra: k,
                                    hasEdgeExcludedModalities: v,
                                    edgeExcludedModalities: r
                                }))
                            }
                        }
                        e = (b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y);
                        e < x && !1 === b.isVirtual && (x = e, m = {
                            type: "node", node: b,
                            edge: null, floor: d
                        })
                    }), "edge" === m.type && (1E-5 > m.edgeExtra.projectionFromStart ? (m.type = "node", m.node = p.nodes[m.edge.startNode], m.edge = null, m.edgeExtra = null) : .99999 < m.edgeExtra.projectionFromStart && (m.type = "node", m.node = p.nodes[m.edge.endNode], m.edge = null, m.edgeExtra = null))) : b.each(p.nodesByFloor[d], function (b) {
                        var e = (b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y);
                        e < x && !1 === b.isVirtual && (x = e, m = {type: "node", node: b, floor: d})
                    })
            });
            return m
        };
        f.prototype.getAccessNearWithoutZ = function (a, d, e) {
            var f = [], m = d * d;
            b.each(this.accessByFloor[e],
                function (b, d) {
                    var e = (b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y);
                    e < m && f.push({node: b, distSq: e, accessName: b.accessName, nodeID: b.id})
                });
            return f
        };
        f.prototype.getAttributes = function () {
            return this.attributes
        };
        f.prototype.getModalities = function () {
            return this.modalities
        };
        f.prototype.getRoutingNode = function (a, b) {
            var d;
            if ("undefined" !== typeof a._hint) return a;
            if ("string" === typeof a) return "undefined" !== typeof this.accesses[a] ? (d = this.accesses[a].node, d = {
                    id: a,
                    _hint: {type: "node", node: d},
                    floor: this.layerIDToNameMap[d.floor]
                }) :
                !1;
            d = this.getNodeHintForPosition(a, b);
            return !1 === d ? !1 : d = {
                position: a,
                routePosition: this._getPointFromHint(d),
                floor: this.layerIDToNameMap[d.floor],
                _hint: d
            }
        };
        f.prototype.processSnapToEdgeRoutingNodes = function (a) {
            var d = {
                originalNumberOfNodes: this.nodes.length,
                originalNumberOfEdges: this.edges.length,
                nodeModalityEdgeRollbackMap: {}
            }, e = null, f = null, m = null, n = null, q = null;
            a.src = this.getRoutingNode(a.src);
            a.src._hint && "edge" == a.src._hint.type && (e = a.src._hint, m = this._constructNodeEdgesFromHint(e, !0, d), a.src = {
                _hint: {
                    type: "node",
                    node: m
                }
            });
            if (jQuery.isArray(a.dst) && 0 < a.dst.length) {
                a.dst = a.dst.slice(0);
                for (var p = 0; p < a.dst.length - 1; p++) q = this.getRoutingNode(a.dst[p]), q._hint && "edge" === q._hint.type && (q = this.nodes[.5 > q._hint.edgeExtra.projectionFromStart ? q._hint.edge.startNode : q._hint.edge.endNode], a.dst[p] = {
                    _hint: {
                        type: "node",
                        node: q
                    }
                });
                p = this.getRoutingNode(a.dst[a.dst.length - 1]);
                p._hint && "edge" == p._hint.type && (f = p._hint, n = this._constructNodeEdgesFromHint(f, !1, d), a.dst[a.dst.length - 1] = {
                    _hint: {
                        type: "node",
                        node: n
                    }
                })
            } else a.dst =
                this.getRoutingNode(a.dst), a.dst._hint && "edge" === a.dst._hint.type && (f = a.dst._hint, n = this._constructNodeEdgesFromHint(f, !1, d), a.dst = {
                _hint: {
                    type: "node",
                    node: n
                }
            });
            if (null !== e && null !== f && null !== m && null !== n) {
                a = !1;
                var r = 0;
                if (e.edge.startNode === f.edge.startNode && e.edge.endNode === f.edge.endNode || e.edge.startNode === f.edge.endNode && e.edge.endNode === f.edge.startNode) "undefined" === typeof e.oppositeEdge ? e.edgeExtra.projectionFromStart < f.edgeExtra.projectionFromStart && (a = !0, r = f.edgeExtra.projectionFromStart - e.edgeExtra.projectionFromStart) :
                    (a = !0, r = e.edge === f.edge ? f.edgeExtra.projectionFromStart - e.edgeExtra.projectionFromStart : 1 - f.edgeExtra.projectionFromStart - e.edgeExtra.projectionFromStart, 0 > r && (r = -r));
                if (a) {
                    var v = {startNode: m.id, endNode: n.id, length: e.edge.length * r, attributes: e.edge.attributes};
                    this.edges[this.edges.length] = v;
                    b.each(this.nodes[e.edge.startNode].modalityEdges, function (a) {
                        a.edge !== e.edge || e.hasEdgeExcludedModalities && !0 === e.edgeExcludedModalities[a.modality] || m.modalityEdges.push({
                            edge: v, modality: a.modality, time: a.time *
                            r
                        })
                    })
                }
            }
            return d
        };
        f.prototype.rollbackEdgeRoutingNodes = function (a) {
            this.nodes.length = a.originalNumberOfNodes;
            this.edges.length = a.originalNumberOfEdges;
            var d = this;
            b.each(a.nodeModalityEdgeRollbackMap, function (a, b) {
                d.nodes[b].modalityEdges.length = a
            })
        };
        f.prototype._getPointFromHint = function (a) {
            if ("edge" === a.type) a = {
                x: a.edgeExtra.projectionPosition.x,
                y: a.edgeExtra.projectionPosition.y,
                z: this.nodes[a.edge.startNode].z * this.geoinformation.meters_per_pixel
            }; else if ("node" === a.type) a = a.node, altitude = a.z, a =
                {x: a.x, y: a.y, z: a.z * this.geoinformation.meters_per_pixel}; else return !1;
            return this.geoinformation.convertSVGToPoint(a)
        };
        f.prototype._constructNodeEdgesFromHint = function (a, d, e) {
            var f = this, m = a.edge, n = this.nodes[m.startNode], q = this.nodes[m.endNode], p = {
                attributes: d ? n.attributes : q.attributes,
                floor: n.floor,
                id: this.nodes.length,
                modalityEdges: [],
                w: void 0,
                x: a.edgeExtra.projectionPosition.x,
                y: a.edgeExtra.projectionPosition.y,
                z: n.z,
                isVirtual: !1,
                isAccess: !1
            };
            this.nodes[this.nodes.length] = p;
            var r = {
                startNode: d ?
                    p.id : m.startNode,
                endNode: d ? m.endNode : p.id,
                length: m.length * (d ? 1 - a.edgeExtra.projectionFromStart : a.edgeExtra.projectionFromStart),
                attributes: m.attributes
            };
            this.edges[this.edges.length] = r;
            b.each(n.modalityEdges, function (b) {
                b.edge !== m || a.hasEdgeExcludedModalities && !0 === a.edgeExcludedModalities[b.modality] || (b = {
                    edge: r,
                    modality: b.modality,
                    time: b.time * (d ? 1 - a.edgeExtra.projectionFromStart : a.edgeExtra.projectionFromStart)
                }, d ? p.modalityEdges.push(b) : ("undefined" === typeof e.nodeModalityEdgeRollbackMap[m.startNode] &&
                (e.nodeModalityEdgeRollbackMap[m.startNode] = f.nodes[m.startNode].modalityEdges.length), f.nodes[m.startNode].modalityEdges.push(b)))
            });
            for (var v = 0, u = q.modalityEdges, v = 0; v < u.length; v++) if (u[v].edge.endNode === n.id) {
                var x = u[v].edge;
                a.oppositeEdge = x;
                var w = {
                    startNode: d ? p.id : x.startNode,
                    endNode: d ? x.endNode : p.id,
                    length: m.length * (d ? a.edgeExtra.projectionFromStart : 1 - a.edgeExtra.projectionFromStart),
                    attributes: x.attributes
                };
                this.edges[this.edges.length] = w;
                b.each(q.modalityEdges, function (b) {
                    b.edge !== x || a.hasEdgeExcludedModalities &&
                    !0 === a.edgeExcludedModalities[b.modality] || (b = {
                        edge: w,
                        modality: b.modality,
                        time: b.time * (d ? a.edgeExtra.projectionFromStart : 1 - a.edgeExtra.projectionFromStart)
                    }, d ? p.modalityEdges.push(b) : ("undefined" === typeof e.nodeModalityEdgeRollbackMap[x.startNode] && (e.nodeModalityEdgeRollbackMap[x.startNode] = f.nodes[x.startNode].modalityEdges.length), f.nodes[x.startNode].modalityEdges.push(b)))
                });
                break
            }
            return p
        };
        f.prototype.load = function (a) {
            var d = this;
            this.maxSpeed = a.maxSpeed || 1;
            this.floors = a.floors;
            this.layerNameToIDMap =
                {};
            this.layerIDToNameMap = {};
            this._initializeLayerNameToIDMap();
            this.attributes = a.attributes;
            this.modalities = a.modalities;
            this.modalityToID = {};
            b.each(this.modalities, function (a, b) {
                d.modalityToID[a] = b
            });
            this.nodesByFloor = [];
            b.each(this.floors, function (a, b) {
                d.nodesByFloor[b] = []
            });
            this.accessByFloor = [];
            b.each(this.floors, function (a, b) {
                d.accessByFloor[b] = []
            });
            this.virtualAttributeID = b.indexOf(a.attributes, "virtual");
            this.accessAttributeID = b.indexOf(a.attributes, "access");
            this.intersectionAttributeID = b.indexOf(a.attributes,
                "intersection");
            this.nodes = [];
            b.each(a.nodes, function (a, b) {
                var e = {
                    x: a.x,
                    y: a.y,
                    z: a.z,
                    w: a.w,
                    floor: a.f,
                    id: b,
                    modalityEdges: [],
                    attributes: !1,
                    isAccess: !1,
                    isVirtual: !1
                };
                d.nodes[b] = e;
                d.nodesByFloor[a.f].push(e)
            });
            this.edges = [];
            b.each(a.edges, function (a) {
                d.edges.push({startNode: a.s, endNode: a.e, length: a.l, attributes: !1})
            });
            b.each(a.routingNodeAttributes, function (a) {
                var b = d.nodes[a.n];
                a = a.a;
                a === d.virtualAttributeID ? b.isVirtual = !0 : a === d.accessAttributeID ? (b.isAccess = !0, d.accessByFloor[b.floor].push(b)) : a === d.intersectionAttributeID ?
                    b.isIntersection = !0 : !1 === b.attributes ? b.attributes = [a] : b.attributes.push(a)
            });
            b.each(a.routingEdgeAttributes, function (a) {
                var b = d.edges[a.e];
                a = a.a;
                !1 === b.attributes ? b.attributes = [a] : b.attributes.push(a)
            });
            b.each(a.routingEdgeModalities, function (a) {
                var b = d.edges[a.e];
                d.nodes[b.startNode].modalityEdges.push({time: a.t, edge: b, modality: a.m})
            });
            this.accesses = {};
            b.each(a.poiRoutingNodes, function (a) {
                "undefined" === typeof d.accesses[a.a] && (d.accesses[a.a] = {entries: []});
                d.accesses[a.a].entries.push({node: d.nodes[a.n]});
                d.nodes[a.n].accessName = a.a
            });
            b.each(this.accesses, function (a) {
                var d = !1;
                b.each(a.entries, function (a) {
                    a.node.isVirtual && (d = a.node)
                });
                if (!1 !== d) {
                    var e = [];
                    b.each(a.entries, function (a) {
                        b.each(a.node.modalityEdges, function (a) {
                            if (a.edge.startNode === d.id || a.edge.endNode === d.id) a.originalTime = a.time, a.edge.originalLength = a.edge.length, e.push(a)
                        })
                    });
                    a.node = d;
                    a.modalityEdges = e
                }
            })
        };
        f.prototype.hasIntersections = function () {
            return -1 !== this.intersectionAttributeID
        };
        f.prototype._heuristic = function (a, b, d) {
            var e = parseFloat(a.x),
                f = parseFloat(a.y);
            a = parseFloat(a.z);
            var n = parseFloat(b.x), q = parseFloat(b.y), p = parseFloat(b.z),
                e = Math.sqrt((n - e) * (n - e) + (q - f) * (q - f) + (p - a) * (p - a));
            "undefined" !== typeof b.w && (e -= b.w);
            "undefined" !== typeof d.w && (e -= d.w);
            return e = Math.max(e, 0)
        };
        f.prototype.run = function (d, e, f) {
            var l, m, n, q;
            f = f || {};
            var p = f.fastest, r = f.weight, v = f.hasExcludedAttributes, u = f.hasExcludedModalities,
                x = f.excludedAttributes, w = f.excludedModalities, z = f.hasRemapResultinModality;
            f = f.remapResultingModalityByID;
            var F = new a(function (a, b) {
                return a.f -
                    b.f
            }), B = !1, B = e.isVirtual;
            b.each(this.nodes, function (a) {
                a.parentModalityEdge = null;
                a.f = 0;
                a.g = 0;
                a.h = 0;
                a.closed = !1;
                a.opened = !1
            });
            F.push(d);
            for (d.opened = !0; !F.empty();) {
                var H = F.pop();
                H.closed = !0;
                if (H === e) {
                    for (e = []; null !== H.parentModalityEdge;) !1 === H.isVirtual && !1 === this.nodes[H.parentModalityEdge.edge.startNode].isVirtual && (d = H.parentModalityEdge.modality, z && (d = f[d], "undefined" === typeof d && (d = H.parentModalityEdge.modality)), e.push({
                        startNode: H.parentModalityEdge.edge.startNode,
                        endNode: H.id,
                        modality: this.modalities[d],
                        time: H.parentModalityEdge.time,
                        lengthSvg: H.parentModalityEdge.edge.length,
                        attributes: H.parentModalityEdge.edge.attributes
                    })), H = this.nodes[H.parentModalityEdge.edge.startNode];
                    return e = e.reverse()
                }
                var E = H.modalityEdges;
                l = 0;
                for (m = E.length; l < m; ++l) {
                    var I = E[l], A = this.nodes[I.edge.endNode];
                    if (!(A.closed || !(!0 !== A.isVirtual || B && A.id === e.id) || u && w[I.modality])) {
                        var N = I.edge.attributes, G = !1;
                        if (v && !1 !== N) for (q = 0, n = N.length; q < n; q++) if (x[N[q]]) {
                            G = !0;
                            break
                        }
                        !G && (n = p ? I.time : I.edge.length, n = H.g + n, !A.opened || n < A.g) &&
                        (A.g = n, A.h = A.h || r * this._heuristic(A, e, d), A.f = A.g + A.h, A.parentModalityEdge = I, A.opened ? F.updateItem(A) : (F.push(A), A.opened = !0))
                    }
                }
            }
            return []
        };
        f.prototype.queryNearPlaces = function (a, e) {
            var f = [];
            e = e || {heading: 0, threshold: 10};
            var l = "number" === typeof e.threshold ? e.threshold : 10, m = e.heading || 0, n = a.lon,
                q = a.alt || a.z || 0, p;
            "undefined" !== typeof a.lat && "undefined" !== typeof n ? p = this.geoinformation.convertLatLonToPoint(a) : "undefined" !== typeof a.x && "undefined" !== typeof a.y && (p = {
                x: a.x,
                y: a.y
            });
            if ("undefined" !== typeof p) {
                n =
                    !1;
                "undefined" !== typeof a.floor ? (q = this.getLayerID(a.floor), !1 !== q && (n = [q])) : n = this.getLayerIDsForHeight(q);
                if (!1 !== n) {
                    var r = this.geoinformation.convertPointToSVG(p), v = this.geoinformation.meters_per_pixel,
                        u = this.geoinformation.rotation_angle_in_degrees, x = l / v, w = this;
                    b.each(n, function (a) {
                        a = w.getAccessNearWithoutZ(r, x, a);
                        for (var b = 0, e = a.length; b < e; b++) {
                            var g = a[b], h = (new d(g.node.x - r.x, g.node.y - r.y)).normalize();
                            h.y = -h.y;
                            h = 0 < h.x ? Math.acos(h.y) : -Math.acos(h.y);
                            h *= 180 / Math.PI;
                            h -= m;
                            for (h -= u; 180 < h;) h -= 360;
                            for (; -180 > h;) h += 360;
                            f.push({id: g.accessName, distance: Math.sqrt(g.distSq) * v, angle: h})
                        }
                    })
                }
                f.sort(function (a, b) {
                    return a.distance - b.distance
                })
            }
            return f
        };
        f.prototype.getNodeHintForPosition = function (a, b) {
            var d = b || {option: "onEdge", distanceThreshold: 200},
                e = "number" === typeof d.distanceThreshold ? d.distanceThreshold : 200, f = a.lon,
                n = a.alt || a.z || 0, q;
            "undefined" !== typeof a.lat && "undefined" !== typeof f ? q = this.geoinformation.convertLatLonToPoint(a) : "undefined" !== typeof a.x && "undefined" !== typeof a.y && (q = {
                x: a.x,
                y: a.y
            });
            var p = !1;
            if ("undefined" !== typeof q) {
                var r = f = !1;
                "undefined" !== typeof a.floor ? (r = this.getLayerID(a.floor), !1 !== r && (f = [r])) : f = this.getLayerIDsForHeight(n);
                !1 !== f && (n = this.geoinformation.convertPointToSVG(q), p = this._getClosestNodeWithoutZ(n, e / this.geoinformation.meters_per_pixel, f, d))
            }
            return p
        };
        f.prototype._getLayerName = function (a) {
            var b = !1;
            "undefined" !== typeof this.floors && a.floor < this.floors.length && (b = this.floors[a.floor].name);
            return b
        };
        f.prototype.addPointToLeg = function (a, b, d, e, f) {
            var n = this.geoinformation.convertSVGToPoint(b),
                n = this.geoinformation.convertPointToLatLon(n);
            a.points.push({
                lat: n.lat,
                lon: n.lon,
                _svg: {x: b.x, y: b.y, z: b.z},
                _routing: {
                    id: b.id,
                    isIntersection: b.isIntersection || !1,
                    pointAttributes: b.attributes,
                    edgeAttributes: f
                },
                _cumullength: d,
                _cumultime: e
            })
        };
        f.prototype._appendRunResult = function (a, d, e) {
            if (d && 0 < d.length) {
                var l = !1, m = a.duration, n = a.length, q = d.length, p = this;
                b.each(d, function (b, d, g) {
                    var x = b.time, w = b.lengthSvg * p.geoinformation.meters_per_pixel, z = p.nodes[b.startNode],
                        F = p.nodes[b.endNode];
                    !1 === l && (l = f.createLeg(p._getLayerName(z),
                        b.modality, z.z * p.geoinformation.meters_per_pixel, e), a.legs.push(l), p.addPointToLeg(l, z, n, m, b.attributes));
                    var B = l.modality !== b.modality, H = d + 1 < q ? g[d + 1].attributes : !1;
                    z.floor !== F.floor ? (b = d + 1 < q ? g[d + 1].modality : b.modality, l = f.createLeg(p._getLayerName(F), b, F.z * p.geoinformation.meters_per_pixel, e), m += x, n += w, p.addPointToLeg(l, F, n, m, H), a.legs.push(l)) : B ? (l = f.createLeg(p._getLayerName(F), b.modality, F.z * p.geoinformation.meters_per_pixel, e), p.addPointToLeg(l, z, n, m, b.attributes), m += x, n += w, p.addPointToLeg(l,
                        F, n, m, H), a.legs.push(l)) : (m += x, n += w, p.addPointToLeg(l, F, n, m, H))
                });
                a.length = n;
                a.duration = m;
                a.legs = b.filter(a.legs, function (a) {
                    return 0 < a.points.length
                });
                "undefined" === typeof a.destinationIndices ? a.destinationIndices = [e] : a.destinationIndices.push(e);
                return !0
            }
            return !1
        };
        f.createLeg = function (a, b, d, e) {
            return {dataset: a, modality: b, destinationIndex: e, points: [], height: d}
        };
        f.prototype.runInOrder = function (a, b, d, e) {
            for (var f = {legs: [], length: 0, duration: 0, status: 200}, n, q, p = 0, r = b.length; p < r; p++) {
                n = b[p];
                a = this.run(a,
                    n, d);
                q = e ? e[p] : p;
                if (!1 === this._appendRunResult(f, a, q)) {
                    f.status = 404;
                    f.error = "Route not found.src not routable.dst not routable.";
                    break
                }
                a = n
            }
            return f
        };
        f.prototype.runClosest = function (a, b, d) {
            var e, f;
            f = !1;
            for (var n = 1E99, q = !1, p = 0, r = b.length; p < r; p++) e = b[p], f = this.run(a, e, d), e = {
                legs: [],
                length: 0,
                duration: 0,
                status: 200
            }, !1 !== this._appendRunResult(e, f, p) && (f = d.fastest ? e.duration : e.length, f < n && (n = f, q = e));
            return !1 !== q ? q : {legs: [], length: 0, duration: 0, error: "Route not found", status: 404}
        };
        f.prototype.computeRoute =
            function (a) {
                var d = a.routingParameters || {}, k = {src: a.src, dst: a.dst, routingParameters: d};
                "undefined" !== typeof d.requestType & "shortest" === d.requestType ? (k.fastest = !1, k.weight = 1) : (k.fastest = !0, this.geoinformation = this.geoinformation || {}, this.geoinformation.meters_per_pixel = this.geoinformation.meters_per_pixel || 1, k.weight = this.geoinformation.meters_per_pixel / this.maxSpeed);
                var l, m, n = {}, q = !1, p, r, v;
                if ("undefined" !== typeof d.excludedAttributes) if (v = d.excludedAttributes, jQuery.isArray(v)) for (l = 0, m = v.length; l <
                m; l++) p = v[l], p = b.indexOf(this.attributes, p), -1 !== p && (q = n[p] = !0); else "string" === typeof v && (p = b.indexOf(this.attributes, v), -1 !== p && (q = n[p] = !0));
                0 == n.length && (n = !1);
                k.hasExcludedAttributes = q;
                k.excludedAttributes = n;
                v = {};
                p = !1;
                if ("undefined" !== typeof d.excludedModalities) if (q = d.excludedModalities, jQuery.isArray(q)) for (l = 0, m = q.length; l < m; l++) r = q[l], n = this.modalityToID[r], -1 !== n && (p = v[n] = !0); else "string" === typeof q && (n = this.modalityToID[q], -1 !== n && (p = v[n] = !0));
                k.hasExcludedModalities = p;
                k.excludedModalities =
                    v;
                if ("undefined" !== typeof d.remapResultingModality) {
                    k.remapResultingModalityByID = {};
                    for (r in d.remapResultingModality) l = this.modalityToID[r], m = this.modalityToID[d.remapResultingModality[r]], "undefined" !== typeof l && "undefined" !== typeof m && (k.remapResultingModalityByID[l] = m);
                    k.hasRemapResultinModality = !0
                } else k.hasRemapResultinModality = !1, k.remapResultingModalityByID = {};
                d = this.processSnapToEdgeRoutingNodes(k);
                l = !1;
                r = this.getRoutingNode(k.src);
                n = {legs: [], length: 0, duration: 0, status: 200};
                do if (!1 !== r) if (r =
                        r._hint, "node" === r.type) if (startNode = r.node, jQuery.isArray(k.dst)) {
                    q = [];
                    l = 0;
                    for (m = k.dst.length; l < m; l++) {
                        v = this.getRoutingNode(k.dst[l]);
                        if (!1 === v) {
                            n.status = 404;
                            n.error = "routable.dst " + l + " not routable.";
                            break
                        }
                        v = v._hint;
                        if ("node" === v.type) v = v.node; else {
                            n.status = 500;
                            n.error = "dst " + l + " is on edge, even after filtering..";
                            break
                        }
                        q.push(v)
                    }
                    if (200 == n.status) switch ("undefined" === typeof a.destinationOrder && (a.destinationOrder = "optimalFinishOnLast"), 1 == k.dst.length && (a.destinationOrder = "inOrder"), a.destinationOrder) {
                        case "inOrder":
                            n =
                                this.runInOrder(startNode, q, k);
                            break;
                        case "closest":
                            n = this.runClosest(startNode, q, k);
                            break;
                        case "optimal":
                            l = new e(this, startNode, q, k, !1);
                            n = l.compute();
                            break;
                        case "optimalFinishOnLast":
                            l = new e(this, startNode, q, k, !0);
                            n = l.compute();
                            break;
                        default:
                            n.status = 500, n.error = "Bad destination order: " + a.destinationOrder
                    }
                } else v = this.getRoutingNode(k.dst), !1 === v ? (n.status = 404, n.error = "routable.dst not routable.") : (v = v._hint, "node" === v.type ? (v = v.node, startNode.id === v.id ? (l = 0 < startNode.modalityEdges.length ? startNode.modalityEdges[0] :
                    {
                        modality: 0,
                        edge: {attributes: !1}
                    }, m = f.createLeg(this._getLayerName(startNode), l.modality, startNode.z * this.geoinformation.meters_per_pixel, -1), this.addPointToLeg(m, startNode, 0, 0, l.edge.attributes), n.legs.push(m)) : (l = this.run(startNode, v, k), !1 === this._appendRunResult(n, l, 0) && (n.status = 404, n.error = "Route not found.src not routable.dst not routable."))) : (n.status = 500, n.error = "dst is on edge, even after filtering..")); else n.status = 500, n.error = "src is on edge, even after filtering.."; else n.status = 404,
                    n.error = "Route not found.src not routable.dst not routable."; while (0);
                this.rollbackEdgeRoutingNodes(d);
                n.request = a;
                return n
            };
        f.prototype._displayNetwork = function (a) {
            var d = this;
            b.each(d.floors, function (e, f) {
                var m = e.name;
                b.each(d.nodesByFloor[f], function (b) {
                    var e = 2, f = "#ff0000";
                    if (!b.isVirtual) {
                        b.isAccess ? (e = 1.5, f = "#0000ff") : b.isIntersection && (e = 2.5, f = "#808080");
                        var k = d.geoinformation.convertSVGToPoint(b);
                        a.addPOI({
                            position: {x: k.x, y: k.y, z: 0},
                            text: b.id,
                            floor: m,
                            scale: e,
                            color: f,
                            opacity: .5,
                            overlay: !0
                        })
                    }
                })
            })
        };
        return f
    });
    define("com/visioglobe/common/navigation/NavigationSolver", ["vector", "underscoretiny"], function (a, b) {
        var d = function (a, b, d) {
            this.routingSolver = a;
            this.meters_per_pixel = b;
            this.hasIntersections = d || !1
        };
        d._getVector = function (b) {
            return new a(b.x, b.y, 0)
        };
        d._subVectors = function (a, b) {
            return a.subtract(b)
        };
        d._crossVectors = function (a, b) {
            return a.cross(b)
        };
        d._computeAngle = function (a, b) {
            var h = a.dot(b), g = d._crossVectors(b, a);
            if (.999999 < h) return 0;
            if (-.999999 > h) return 180;
            h = 180 * Math.acos(h) / Math.PI;
            0 > g.z && (h = -h);
            return -h
        };
        d.prototype._defaultNavigationParameters = {
            straightAngleThreshold: 30,
            distanceFromCouloirThreshold: 2,
            nearPlacesThreshold: 10,
            minimumInstructionLength: 0
        };
        d.prototype._getParam = function (a, b) {
            "undefined" === typeof a && console.log("BAD: undefined modality for getParam");
            "undefined" === typeof b && console.log("BAD: undefined parameterName for getParam");
            return "undefined" !== typeof this.mModalityParameters && "undefined" !== typeof this.mModalityParameters[a] && "undefined" !== typeof this.mModalityParameters[a][b] ?
                this.mModalityParameters[a][b] : "undefined" !== typeof this._defaultNavigationParameters[b] ? this._defaultNavigationParameters[b] : Infinity
        };
        d.prototype._angle2maneuver = function (a, b) {
            var d = this._getParam(b, "straightAngleThreshold"), g = 0 < a ? !0 : !1, k = Math.abs(a);
            return k < d ? "eVgManeuverTypeGoStraight" : 45 > k ? !0 === g ? "eVgManeuverTypeTurnGentleRight" : "eVgManeuverTypeTurnGentleLeft" : 135 > k ? !0 === g ? "eVgManeuverTypeTurnRight" : "eVgManeuverTypeTurnLeft" : !0 === g ? "eVgManeuverTypeTurnSharpRight" : "eVgManeuverTypeTurnSharpLeft"
        };
        d.prototype.computeNavigation = function (a, b) {
            b = b || {};
            b.algorithm = b.algorithm || "auto";
            var d = b.algorithm;
            "auto" === d && this.hasIntersections && (d = "intersectionAlgorithm");
            return "intersectionAlgorithm" === d ? this.computeNavigationIntersection(a, b) : this.computeNavigationOriginal(a, b)
        };
        d.prototype.computeNavigationOriginal = function (a, b) {
            b = b || {};
            b.mergeFloorChangeInstructions = "undefined" !== typeof b.mergeFloorChangeInstructions ? b.mergeFloorChangeInstructions : !0;
            b.modalityParameters = b.modalityParameters || {};
            var h =
                b.mergeFloorChangeInstructions;
            this.mModalityParameters = b.modalityParameters || {};
            if (0 === a.legs.length) return {
                instructions: [{
                    length: 0,
                    duration: 0,
                    maneuverType: "eVgManeuverTypeEnd",
                    icon: "transit_instruction_end.png",
                    destinationIndex: 0
                }],
                parameters: b,
                route: a,
                _algorithm: "originalAlgorithm, prefer to use explicit intersections algorithm"
            };
            for (var g = [], k = a.legs[a.legs.length - 1], k = k.points[k.points.length - 1]._cumultime, l = 0, m = a.legs, n = 0, q = m.length; n < q; n++) {
                for (var p = m[n], r = p.points.slice(0), v = !1; 2 > r.length;) v =
                    !0, r.push(r[0]);
                var u = {positions: [], attributes: []};
                u.position = r[0];
                u.height = u.position._svg.z * this.meters_per_pixel;
                u.modality = p.modality;
                u.dataset = p.dataset;
                u.destinationIndex = p.destinationIndex;
                l = r[0]._cumullength;
                u.time = r[0]._cumultime;
                var x = d._getVector(r[0]._svg), w = d._getVector(r[1]._svg);
                u.positions.push(r[0]);
                r[0]._routing.edgeAttributes && u.attributes.push(r[0]._routing.edgeAttributes);
                v || (u.positions.push(r[1]), r[1]._routing.edgeAttributes && u.attributes.push(r[1]._routing.edgeAttributes));
                for (var z = d._subVectors(x, w).length() * this.meters_per_pixel, F = 0, v = 2, B = r.length; v < B; v++) {
                    var H = d._subVectors(x, w).normalize(), E = d._getVector(r[v]._svg), x = d._subVectors(x, E),
                        I = x.clone().normalize(), F = d._computeAngle(H, I);
                    Math.abs(F);
                    F = d._crossVectors(H, I).length() * x.length() * this.meters_per_pixel;
                    F = Math.abs(F);
                    x = this._getParam(p.modality, "distanceFromCouloirThreshold");
                    this._getParam(p.modality, "straightAngleThreshold");
                    if (F = F > x || !1) if (x = d._subVectors(w, E).normalize(), x = d._computeAngle(H, x), Math.abs(x) <
                        this._getParam(p.modality, "straightAngleThreshold") || z < this._getParam(p.modality, "minimumInstructionLength")) F = !1, w.clone();
                    F ? (z = d._computeAngle(H, d._subVectors(w, E).normalize()), u.length = r[v - 1]._cumullength - l, u.duration = r[v - 1]._cumultime - u.time, u.maneuverType = this._angle2maneuver(z, p.modality), this._computeNearPlaces(u, H, z), g.push(u), u = {
                        positions: [],
                        attributes: []
                    }, l = r[v - 1]._cumullength, u.time = r[v - 1]._cumultime, z = d._subVectors(E, w).length() * this.meters_per_pixel, w.clone(), u.position = r[v - 1], u.height =
                        u.position._svg.z * this.meters_per_pixel, u.dataset = p.dataset, u.destinationIndex = p.destinationIndex, u.modality = p.modality, u.positions.push(u.position), r[v - 1]._routing.edgeAttributes && u.attributes.push(r[v - 1]._routing.edgeAttributes)) : z += d._subVectors(E, w).length() * this.meters_per_pixel;
                    x = w.clone();
                    w = E.clone();
                    d._subVectors(x, w).normalize();
                    u.positions.push(r[v]);
                    r[v]._routing.edgeAttributes && u.attributes.push(r[v]._routing.edgeAttributes)
                }
                u.maneuverType = "eVgManeuverTypeGoStraight";
                0 < z && (w = d._getVector({
                    x: 0,
                    y: 0
                }), B = u.positions.length, 1 < B && (w = d._subVectors(d._getVector(u.positions[B - 1]._svg), d._getVector(u.positions[B - 2]._svg)).normalize()), this._computeNearPlaces(u, w, 0), u.length = r[v - 1]._cumullength - l, u.duration = r[v - 1]._cumultime - u.time, g.push(u), u = {
                    positions: [],
                    attributes: []
                }, l = r[v - 1]._cumullength, u.time = r[v - 1]._cumultime);
                if (!1 === h) {
                    if (n === q - 1) u.maneuverType = "eVgManeuverTypeEnd", u.destinationIndex = p.destinationIndex, u.length = 0, u.duration = 0; else {
                        var A = m[n + 1], w = A.dataset, B = A.destinationIndex, H = p.dataset,
                            E = p.destinationIndex, F = A.modality, x = p.modality, I = r[0]._svg.z,
                            A = A.points[0]._svg.z;
                        A < I ? (u.maneuverType = "eVgManeuverTypeGoDown", u.length = 0) : A > I ? (u.maneuverType = "eVgManeuverTypeGoUp", u.length = 0) : I === A && H !== w ? (u.maneuverType = "eVgManeuverTypeChangeLayer", u.length = 0) : x !== F ? (u.maneuverType = "eVgManeuverTypeChangeModality", u.length = 0) : E !== B ? (u.maneuverType = "eVgManeuverTypeWaypoint", u.length = 0) : console.log("This should not happen yet")
                    }
                    0 === z && "undefined" === typeof u.position && console.log("BAD1");
                    0 < z && (u.position =
                        r[r.length - 1], u.height = u.position._svg.z * this.meters_per_pixel, u.positions.push(u.position), u.position._routing.edgeAttributes && u.attributes.push(u.position._routing.edgeAttributes));
                    u.dataset = p.dataset;
                    u.destinationIndex = p.destinationIndex;
                    u.modality = p.modality;
                    u.duration = r[v - 1]._cumultime - u.time;
                    u.length = r[v - 1]._cumullength - l;
                    this._computeNearPlaces(u);
                    g.push(u);
                    u = {positions: []};
                    u.time = r[v - 1]._cumultime
                }
            }
            h = 0;
            for (l = g.length; h < l; h++) u = g[h], u.totalTime = k, this._uniqueAndConvertAttributes(u), "undefined" ===
            typeof u.duration && console.log("HBXX fixme mDuration: " + h), "undefined" === typeof u.time && console.log("HBXX fixme time: " + h), "undefined" === typeof u.length && console.log("HBXX fixme length: " + h), u.icon = this._getIconName(u);
            0 === g.length && (g = [{
                length: 0,
                duration: 0,
                maneuverType: "eVgManeuverTypeEnd",
                icon: "transit_instruction_end.png",
                destinationIndex: 0
            }]);
            return {
                instructions: g,
                parameters: b,
                route: a,
                _algorithm: "originalAlgorithm, prefer to use explicit intersections algorithm"
            }
        };
        d.prototype._getIconName = function (a) {
            var b =
                "";
            switch (a.maneuverType) {
                case "eVgManeuverTypeUnknown":
                    b = "";
                    break;
                case "eVgManeuverTypeGoStraight":
                    b = "transit_instruction_straight.png";
                    break;
                case "eVgManeuverTypeTurnGentleRight":
                    b = "transit_instruction_turn_gentle_right.png";
                    break;
                case "eVgManeuverTypeTurnGentleLeft":
                    b = "transit_instruction_turn_gentle_left.png";
                    break;
                case "eVgManeuverTypeTurnRight":
                    b = "transit_instruction_turn_right.png";
                    break;
                case "eVgManeuverTypeTurnLeft":
                    b = "transit_instruction_turn_left.png";
                    break;
                case "eVgManeuverTypeTurnSharpRight":
                    b =
                        "transit_instruction_turn_sharp_right.png";
                    break;
                case "eVgManeuverTypeTurnSharpLeft":
                    b = "transit_instruction_turn_sharp_left.png";
                    break;
                case "eVgManeuverTypeUTurnLeft":
                    b = "transit_instruction_uturn_left.png";
                    break;
                case "eVgManeuverTypeUTurnRight":
                    b = "transit_instruction_uturn_right.png";
                    break;
                case "eVgManeuverTypeStart":
                    b = "transit_instruction_start.png";
                    break;
                case "eVgManeuverTypeEnd":
                    b = "transit_instruction_end.png";
                    break;
                case "eVgManeuverTypeGoUp":
                    b = "transit_instruction_up.png";
                    break;
                case "eVgManeuverTypeGoDown":
                    b =
                        "transit_instruction_down.png";
                    break;
                case "eVgManeuverTypeChangeModality":
                    b = "transit_instruction_modality_change.png";
                    break;
                case "eVgManeuverTypeChangeLayer":
                    b = "transit_instruction_layer_change.png";
                    break;
                case "eVgManeuverTypeWaypoint":
                    b = "transit_instruction_intermediate_destination.png";
                    break;
                default:
                    console.log("bad icon?")
            }
            return b
        };
        d.prototype._computeNearPlaces = function (a, f, h) {
            var g = this;
            a.nearPlaces = [];
            if ("undefined" !== typeof this.routingSolver) {
                "undefined" === typeof f && (f = d._getVector({
                    x: 0,
                    y: 0
                }));
                "undefined" === typeof h && (h = 0);
                a.actionAngle = h;
                var k = d._getVector(a.positions[a.positions.length - 1]._svg),
                    l = this._getParam(a.modality, "nearPlacesThreshold") / g.meters_per_pixel,
                    m = g.routingSolver.getLayerID(a.dataset), l = this.routingSolver.getAccessNearWithoutZ(k, l, m);
                b.each(l, function (b) {
                    var h = 0;
                    if (0 !== f.x || 0 !== f.y) {
                        var l = d._getVector(b.node), l = d._subVectors(k, l);
                        if (0 !== l.x || 0 !== l.y) l = l.normalize(), h = d._computeAngle(f, l)
                    }
                    a.nearPlaces.push({
                        id: b.accessName, distance: Math.sqrt(b.distSq) * g.meters_per_pixel,
                        angle: h
                    })
                });
                l = function (a) {
                    return function (b, d) {
                        var e = 0 < a ? 90 + .5 * a : -90 + .5 * a, f = 0 < a, g = b.angle - e, e = d.angle - e;
                        return .01 > Math.abs(g - e) ? b.distance - d.distance : f ? 0 <= g && 0 > e ? -1 : 0 > g && 0 <= e ? 1 : 0 <= g ? g - e : e - g : 0 <= g && 0 > e ? 1 : 0 > g && 0 <= e ? -1 : 0 <= g ? g - e : e - g
                    }
                };
                m = function (a, b) {
                    return a.distance - b.distance
                };
                a.nearPlaces = 0 === h ? a.nearPlaces.sort(m) : a.nearPlaces.sort(l(h))
            }
        };
        d.prototype.computeNavigationIntersection = function (a, b) {
            b = b || {};
            b.mergeFloorChangeInstructions = "undefined" === typeof b.mergeFloorChangeInstructions ? !0 : b.mergeFloorChangeInstructions;
            b.modalityParameters = b.modalityParameters || {};
            b.firstNodeAsIntersection = "undefined" === typeof b.firstNodeAsIntersection ? !1 : b.firstNodeAsIntersection;
            var h = b.mergeFloorChangeInstructions;
            this.mModalityParameters = b.modalityParameters || {};
            var g = b.firstNodeAsIntersection;
            if (0 === a.legs.length) return {
                instructions: [{
                    length: 0,
                    duration: 0,
                    maneuverType: "eVgManeuverTypeEnd",
                    icon: "transit_instruction_end.png",
                    destinationIndex: 0
                }], parameters: b, route: a, _algorithm: "intersectionAlgorithm"
            };
            for (var k = [], l = 0, m = a.legs,
                     n, q, p = 0, r = !1, v = 0, u = m.length; v < u; v++) {
                for (var x = m[v], w = x.points.slice(0), z = !1; 2 > w.length;) z = !0, w.push(w[0]);
                n = {
                    position: w[0],
                    positions: [],
                    attributes: [],
                    height: w[0]._svg.z * this.meters_per_pixel,
                    time: w[0]._cumultime,
                    modality: x.modality,
                    dataset: x.dataset,
                    destinationIndex: x.destinationIndex
                };
                l = w[0]._cumullength;
                0 < k.length && (q = k[k.length - 1], q.duration = n.time - q.time, q.length = n.position._cumullength - q.position._cumullength);
                var F = d._getVector(w[0]._svg), p = d._getVector(w[1]._svg);
                n.positions.push(w[0]);
                w[0]._routing.edgeAttributes &&
                n.attributes.push(w[0]._routing.edgeAttributes);
                z || (n.positions.push(w[1]), w[1]._routing.edgeAttributes && n.attributes.push(w[1]._routing.edgeAttributes));
                var B = this._getParam(x.modality, "straightAngleThreshold"), H;
                q = d._subVectors(F, p).normalize();
                var E = d._getVector({x: 0, y: 0}), I = 0;
                H = 0;
                for (var A = w[1]._routing.isIntersection || 0 == v && g || 0 < v && m[v].destinationIndex != m[v - 1].destinationIndex && g, z = 2, N = w.length; z < N; z++) {
                    F = d._getVector(w[z]._svg);
                    E = d._subVectors(p, F).normalize();
                    I = d._computeAngle(q, E);
                    H = Math.abs(I);
                    if (H = A && H > B) n.length = w[z - 1]._cumullength - l, n.duration = w[z - 1]._cumultime - n.time, n.maneuverType = this._angle2maneuver(I, x.modality), l = w[z - 1]._cumullength, this._computeNearPlaces(n, q, I), k.push(n), q = n, n = {
                        position: w[z - 1],
                        positions: [],
                        attributes: [],
                        height: q.height,
                        time: w[z - 1]._cumultime,
                        modality: q.modality,
                        dataset: q.dataset,
                        destinationIndex: q.destinationIndex
                    }, n.positions.push(n.position), w[z - 1]._routing.edgeAttributes && n.attributes.push(w[z - 1]._routing.edgeAttributes);
                    p.clone();
                    p = F.clone();
                    q = E;
                    A = w[z]._routing.isIntersection;
                    n.positions.push(w[z]);
                    w[z]._routing.edgeAttributes && n.attributes.push(w[z]._routing.edgeAttributes)
                }
                n.maneuverType = "eVgManeuverTypeGoStraight";
                p = w[z - 1]._cumullength - l;
                0 < p ? (this._computeNearPlaces(n, q, 0), n.length = w[z - 1]._cumullength - l, n.duration = w[z - 1]._cumultime - n.time, l = w[z - 1]._cumullength, k.push(n), n = {
                    positions: [],
                    attributes: [],
                    time: w[z - 1]._cumultime
                }) : r = !0;
                if (!h || r) r = !1, v === u - 1 ? (n.maneuverType = "eVgManeuverTypeEnd", n.length = 0, n.duration = 0) : (B = x.dataset, F = x.modality, q = x.destinationIndex, A = m[v + 1],
                    E = A.dataset, N = A.modality, I = A.destinationIndex, H = w[0]._svg.z, A = A.points[0]._svg.z, A < H ? n.maneuverType = "eVgManeuverTypeGoDown" : A > H ? n.maneuverType = "eVgManeuverTypeGoUp" : H === A && B !== E ? n.maneuverType = "eVgManeuverTypeChangeLayer" : F !== N ? n.maneuverType = "eVgManeuverTypeChangeModality" : q !== I ? n.maneuverType = "eVgManeuverTypeWaypoint" : console.log("This should not happen yet")), 0 === p && "undefined" === typeof n.position && console.log("BAD1"), 0 < p && (n.position = w[w.length - 1], n.height = n.position._svg.z * this.meters_per_pixel,
                    n.positions.push(n.position), n.position._routing.edgeAttributes && n.attributes.push(n.position._routing.edgeAttributes)), n.dataset = x.dataset, n.destinationIndex = x.destinationIndex, n.modality = x.modality, n.duration = w[z - 1]._cumultime - n.time, n.length = w[z - 1]._cumullength - l, this._computeNearPlaces(n), k.push(n)
            }
            n = a.legs[a.legs.length - 1];
            h = n.points[n.points.length - 1]._cumultime;
            g = 0;
            for (l = k.length; g < l; g++) n = k[g], k[g].totalTime = h, this._uniqueAndConvertAttributes(n), "undefined" === typeof k[g].duration && console.log("fixme duration: " +
                g), "undefined" === typeof k[g].time && console.log("fixme time: " + g), "undefined" === typeof k[g].length && console.log("fixme length: " + g), k[g].icon = this._getIconName(k[g]);
            0 === k.length && (k = [{
                length: 0,
                duration: 0,
                maneuverType: "eVgManeuverTypeEnd",
                icon: "transit_instruction_end.png",
                destinationIndex: 0
            }]);
            return {instructions: k, parameters: b, route: a, _algorithm: "intersectionAlgorithm"}
        };
        d.prototype._uniqueAndConvertAttributes = function (a) {
            for (var b = {}, d = [], g = !1, k = 0, l = a.attributes.length; k < l; k++) for (var m = a.attributes[k],
                                                                                                  n = 0, q = m.length; n < q; n++) {
                var p = m[n];
                void 0 === b[p] && (d.push(this.routingSolver.attributes[p]), g = b[p] = !0)
            }
            g && (a.attributes = d)
        };
        return d
    });
    define("com/visioglobe/web/SVG3Loader", ["./helpers/SvgUtils", "./helpers/ExtrudeGeometry"], function (a, b) {
        var d = function (a) {
            console.log("SVG3Loader");
            a = a || {};
            this.scene = new THREE.Scene;
            this.material = new THREE.MeshBasicMaterial({
                color: 16777215,
                specular: 13421772,
                vertexColors: THREE.VertexColors,
                transparent: !1
            });
            this.floors = {};
            this.svgHeight = 2048;
            this.geoinformation = {meters_per_pixel: 1};
            this.generateWalls = this.generateRoofs = !0;
            this.synchronousLoading = "undefined" !== typeof a.synchronous ? a.synchronous : !1;
            this.debug = !1
        };
        d.prototype.initialize = function () {
            this.debug && console.log("initialize")
        };
        d.prototype.convertSVGTo3D = function (a) {
            var b = {};
            b.x = (a.x - this.svgHeight / 2) * this.geoinformation.meters_per_pixel;
            b.y = (this.svgHeight / 2 - a.y) * this.geoinformation.meters_per_pixel;
            a.z && (b.z = a.z);
            return b
        };
        d.prototype.convertPathToShape = function (b) {
            var d = jQuery(b), h = d.attr("d");
            if ("undefined" === typeof h) return null;
            var g = b = new THREE.Shape, k = new a.Transform;
            d.attr("transform") && (k = d.attr("transform"), k = a.Transform.parse(k));
            var d = null, l, h = a.Parser.path(h);
            h.reset();
            for (var m, n, q, p = !1; !h.isEnd();) switch (h.nextCommand(), p && (g = new THREE.Shape, b.holes.push(g), p = !1), h.command.toUpperCase()) {
                case "Z":
                    a.equalsPoints(l, d, .01) && (g.actions.splice(-1, 1), g.curves.splice(-1, 1));
                    break;
                case "M":
                    m = h.getAsCurrentPoint().clone();
                    k.multiplyVector(m);
                    m = this.convertSVGTo3D(m);
                    g.moveTo(m.x, m.y);
                    for (d = l = m; !h.isCommandOrEnd();) m = h.getAsCurrentPoint().clone(), k.multiplyVector(m), m = this.convertSVGTo3D(m), a.equalsPoints(m, d, .01) || g.lineTo(m.x,
                        m.y), d = m;
                    break;
                case "L":
                    for (; !h.isCommandOrEnd();) m = h.getAsCurrentPoint().clone(), k.multiplyVector(m), m = this.convertSVGTo3D(m), a.equalsPoints(m, d, .01) || g.lineTo(m.x, m.y), d = m;
                    break;
                case "C":
                    for (; !h.isCommandOrEnd();) m = h.getAsControlPoint().clone(), n = h.getAsControlPoint().clone(), q = h.getAsCurrentPoint().clone(), k.multiplyVector(m), m = this.convertSVGTo3D(m), k.multiplyVector(n), n = this.convertSVGTo3D(n), k.multiplyVector(q), q = this.convertSVGTo3D(q), g.bezierCurveTo(m.x, m.y, n.x, n.y, q.x, q.y);
                    break;
                case "S":
                    for (; !h.isCommandOrEnd();) n =
                        h.getAsControlPoint().clone(), q = h.getAsCurrentPoint().clone(), m = h.getReflectedControlPoint(), k.multiplyVector(m), m = this.convertSVGTo3D(m), k.multiplyVector(n), n = this.convertSVGTo3D(n), k.multiplyVector(q), q = this.convertSVGTo3D(q), g.bezierCurveTo(m.x, m.y, n.x, n.y, q.x, q.y);
                    break;
                case "H":
                    for (; !h.isCommandOrEnd();) n = h.getScalar(), m = h.current.clone(), m.x = "h" === h.command ? m.x + n : n, h.current.x = m.x, k.multiplyVector(m), m = this.convertSVGTo3D(m), g.lineTo(m.x, m.y);
                    break;
                case "V":
                    for (; !h.isCommandOrEnd();) n = h.getScalar(),
                        m = h.current.clone(), m.y = "v" === h.command ? m.y + n : n, h.current.y = m.y, k.multiplyVector(m), m = this.convertSVGTo3D(m), g.lineTo(m.x, m.y);
                    break;
                default:
                    return null
            }
            return b
        };
        d.prototype.addPathToScene = function (d, f, h) {
            var g = this.convertPathToShape(d);
            if (null === g || 1 >= g.curves.length) console.log("Cannot convert to shape."); else {
                var k = jQuery(d);
                d = k.attr("fill");
                void 0 === d && (d = f.color);
                var l = a.Parser.color(d), m, n, q, p, r;
                d = this.floors[h.floor];
                d = !1 !== h.lod ? d.lods[h.lod] : d.floorContentLOD;
                var v = 0;
                f.reflection ? v = 1 : f.water &&
                    (v = 2);
                for (var u = v; d.children.length < v + 1;) d.add(new THREE.Mesh(void 0, this.material));
                f.reflection ? d.children[v].userData = {reflection: !0} : f.water && (d.children[v].userData = {water: !0});
                if (this.generateRoofs) {
                    m = {
                        amount: f.thickness,
                        steps: 1,
                        bevelEnabled: !1,
                        generateSides: !1,
                        generateTop: !0,
                        generateBottom: !1
                    };
                    try {
                        for (n = new b(g, m), n.computeBoundingBox(), q = new THREE.Color(l), p = 0, r = n.faces.length; p < r; ++p) n.faces[p].color = q
                    } catch (x) {
                        console.log("ExtrudeGeometry failed", x);
                        return
                    }
                    p = d.children[v].geometry.faces.length;
                    d.children[v].geometry.merge(n);
                    r = k.attr("vg_id");
                    "undefined" !== typeof r && (k = new THREE.Vector3, k.addVectors(n.boundingBox.max, n.boundingBox.min), k.multiplyScalar(.5), n = {
                        id: r,
                        floor: h.floor,
                        originalColor: l,
                        nb_faces: n.faces.length,
                        faces_offset: p,
                        position: k
                    }, d.userData.pickables = d.userData.pickables || [], d.userData.pickables.push(n))
                }
                if (this.generateWalls && 0 < f.thickness && !1 !== f.wall_geometry) {
                    m = {
                        amount: f.thickness,
                        steps: 1,
                        bevelEnabled: !1,
                        generateSides: !0,
                        generateTop: !1,
                        generateBottom: !1
                    };
                    n = new b(g, m);
                    n.computeVertexNormals();
                    g = new THREE.Color(l);
                    h = new THREE.Color(l);
                    f.wall_color_gradient && (p = parseFloat(f.wall_color_gradient_top_ratio), isNaN(p) || g.multiplyScalar(p), f = parseFloat(f.wall_color_gradient_bottom_ratio), isNaN(f) || h.multiplyScalar(f));
                    f = ["a", "b", "c"];
                    p = 0;
                    for (r = n.faces.length; p < r; ++p) {
                        var l = n.faces[p], w;
                        for (w in f) l.vertexColors[w] = 0 < n.vertices[l[f[w]]].z ? g : h
                    }
                    d.children[u].geometry.merge(n)
                }
            }
        };
        d.prototype.addSvgPath = function (a, b, d) {
            this.addPathToScene(a, b, d)
        };
        d.prototype.loadItem = function (b) {
            this.debug &&
            console.log("loadItem");
            var d = b.element, h = jQuery(d), g = b.info.type, k = h.attr("onabort");
            k && JSON.parse(k);
            h.attr("id") && h.attr("vg_id", h.attr("id"));
            if ("vg-model" !== g && "vg-image" !== g && "vg-label" !== g) switch (d.name || d.localName) {
                case "rect":
                    a.convertRectToPath(d);
                    this.addSvgPath(d, b.parameters, b.info);
                    break;
                case "polygon":
                    a.convertPolygonToPath(d);
                    this.addSvgPath(d, b.parameters, b.info);
                    break;
                case "polyline":
                    a.convertPolygonToPath(d);
                    this.addSvgPath(d, b.parameters, b.info);
                    break;
                case "ellipse":
                    a.convertEllipseToPath(d);
                    this.addSvgPath(d, b.parameters, b.info);
                    break;
                case "circle":
                    a.convertCircleToPath(d);
                    this.addSvgPath(d, b.parameters, b.info);
                    break;
                case "path":
                    this.addSvgPath(d, b.parameters, b.info)
            }
        };
        d.prototype.parseBoolean = function (a, b) {
            return "undefined" === typeof a ? b || !1 : !1 === a || "false" === a || "off" === a || "0" === a || 0 === a ? !1 : !0
        };
        d.prototype.loadSVG3 = function (a, b, d) {
            this.debug && console.log("loadSVG3");
            this.svgHeight = parseInt(b.find("svg").attr("height"), 10);
            var g = b.find("svg").attr("onabort"), g = JSON.parse(g);
            d && d(g);
            "undefined" !==
            typeof g.builder_parameters && "undefined" !== typeof g.builder_parameters.distance_coeff && (g.geo.distance_coef = g.builder_parameters.distance_coeff);
            this.geoinformation = g.geo;
            this.scene.userData = {
                svgHeight: this.svgHeight,
                geoinformation: this.geoinformation,
                proj4string: g.proj4string,
                offsetX: g.offsetX,
                offsetY: g.offsetY
            };
            this.debug && console.log("height= ", this.svgHeight);
            var k = this, l = [];
            b.find("svg>g[id^=floor]").each(function () {
                var a = jQuery(this), b = a.attr("id").substr(5), d = new THREE.Object3D, e = new THREE.Object3D;
                d.add(e);
                k.scene.add(d);
                d.userData = {name: b};
                k.floors[b] = {object: d, content: e, lods: {}};
                k.debug && console.log("floor= ", b);
                a.find(">g[id^=vg-common-foreground]>g[id^=vg-model]").each(function () {
                });
                a.find(">g[id^=lod]").each(function () {
                    var a = jQuery(this), e = a.attr("id").substr(3), f = new THREE.Object3D;
                    d.add(f);
                    f.userData = {index: parseInt(e, 10)};
                    k.floors[b].lods[e] = f;
                    k.debug && console.log(" lod= ", e);
                    a.children("g").each(function () {
                        var a = jQuery(this), d = a.attr("id");
                        k.debug && console.log("  type", d);
                        a.find(">*:not(.vghelper)").each(function () {
                            k.debug &&
                            console.log("   child");
                            var a = {thickness: 0, color: 10526880};
                            if ("undefined" === typeof g.parameters.styles[d] || "undefined" === typeof g.parameters.styles[d].footprint || !0 !== g.parameters.styles[d].footprint) g.parameters.styles[d] && (a.thickness = parseFloat(g.parameters.styles[d].extrusion_height), a.color = g.parameters.styles[d].color, a.wall_geometry = k.parseBoolean(g.parameters.styles[d].wall_geometry, !1), a.wall_color_gradient = k.parseBoolean(g.parameters.styles[d].wall_color_gradient, !1), a.wall_color_gradient_top_ratio =
                                parseFloat(g.parameters.styles[d].wall_color_gradient_top_ratio), a.wall_color_gradient_bottom_ratio = parseFloat(g.parameters.styles[d].wall_color_gradient_bottom_ratio), a.reflection = k.parseBoolean(g.parameters.styles[d].reflection), a.water = k.parseBoolean(g.parameters.styles[d].water)), l.push({
                                element: this,
                                parameters: a,
                                info: {floor: b, lod: e, type: d}
                            })
                        })
                    })
                })
            });
            if (this.synchronousLoading) {
                for (var m in l) this.loadItem(l[m]);
                a.resolve()
            } else {
                var n = 0, q = Math.ceil(l.length / 100), p = function () {
                    for (var b = Math.min(l.length -
                        n, q), d = 0; d < b; ++d) this.loadItem(l[n]), ++n;
                    n === l.length ? (a.notify(1), a.resolve()) : (a.notify(n / l.length), setTimeout(p.bind(this), 0))
                };
                setTimeout(p.bind(this), 0)
            }
        };
        d.prototype.getVgFile = function (a, b, d, g) {
            a instanceof THREE.Scene || !g || (a.object.userData.proj4string = g.proj4string, a.object.userData.offsetX = g.offsetX, a.object.userData.offsetY = g.offsetY);
            b = {scene: a, routing: b, pois: d};
            var k = function (a, b) {
                for (var d in a) a[d] = b.apply(this, [d, a[d]]), null !== a[d] && "object" == typeof a[d] && k(a[d], b);
                return a
            };
            a instanceof
            THREE.Scene || k(b, function (a, b) {
                "number" === typeof b && (b = parseFloat(b.toFixed(1)));
                return b
            });
            return b
        };
        return d
    });
    define("com/visioglobe/web/helpers/SceneLoader", [], function () {
        THREE.SceneLoader = function (a) {
            this.onLoadStart = function () {
            };
            this.onLoadProgress = function () {
            };
            this.onLoadComplete = function () {
            };
            this.callbackSync = function () {
            };
            this.callbackProgress = function () {
            };
            this.geometryHandlers = {};
            this.hierarchyHandlers = {};
            this.addGeometryHandler("ascii", THREE.JSONLoader);
            this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
        };
        THREE.SceneLoader.prototype = {
            constructor: THREE.SceneLoader, load: function (a, b, d, e) {
                var f = this,
                    h = new THREE.XHRLoader(f.manager);
                h.setCrossOrigin(this.crossOrigin);
                h.load(a, function (d) {
                    f.parse(JSON.parse(d), b, a)
                }, d, e)
            }, setCrossOrigin: function (a) {
                this.crossOrigin = a
            }, addGeometryHandler: function (a, b) {
                this.geometryHandlers[a] = {loaderClass: b}
            }, addHierarchyHandler: function (a, b) {
                this.hierarchyHandlers[a] = {loaderClass: b}
            }, parse: function (a, b, d) {
                function e(a, b) {
                    return "relativeToHTML" == b ? a : r + a
                }

                function f() {
                    G.object ? h(A.scene, G.object.children) : h(A.scene, G.objects)
                }

                function h(a, b) {
                    var d, f, g, k, m, n;
                    for (n in b) {
                        var q =
                            A.objects[n], r = b[n];
                        if (void 0 === q) {
                            if (r.type && r.type in p.hierarchyHandlers) void 0 === r.loading && (u = A.materials[r.material], r.loading = !0, p.hierarchyHandlers[r.type].loaderObject.load(e(r.url, G.urlBaseType), l(n, a, u, r))); else if (void 0 !== r.geometry) {
                                if (v = A.geometries[r.geometry]) {
                                    q = !1;
                                    u = A.materials[r.material];
                                    q = u instanceof THREE.ShaderMaterial;
                                    f = r.position;
                                    g = r.rotation;
                                    k = r.scale;
                                    d = r.matrix;
                                    m = r.quaternion;
                                    r.material || (u = new THREE.MeshFaceMaterial(A.face_materials[r.geometry]));
                                    u instanceof THREE.MeshFaceMaterial &&
                                    0 === u.materials.length && (u = new THREE.MeshFaceMaterial(A.face_materials[r.geometry]));
                                    if (u instanceof THREE.MeshFaceMaterial) for (var w = 0; w < u.materials.length; w++) q = q || u.materials[w] instanceof THREE.ShaderMaterial;
                                    q && v.computeTangents();
                                    r.skin ? q = new THREE.SkinnedMesh(v, u) : r.morph ? (q = new THREE.MorphAnimMesh(v, u), void 0 !== r.duration && (q.duration = r.duration), void 0 !== r.time && (q.time = r.time), void 0 !== r.mirroredLoop && (q.mirroredLoop = r.mirroredLoop), u.morphNormals && v.computeMorphNormals()) : q = new THREE.Mesh(v,
                                        u);
                                    q.name = n;
                                    d ? (q.matrixAutoUpdate = !1, q.matrix.set(d[0], d[4], d[8], d[12], d[1], d[5], d[9], d[13], d[2], d[6], d[10], d[14], d[3], d[7], d[11], d[15]), q.matrix.decompose(q.position, q.quaternion, q.scale)) : (q.position.fromArray(f), m ? q.quaternion.fromArray(m) : q.rotation.fromArray(g), q.scale.fromArray(k));
                                    q.visible = r.visible;
                                    q.castShadow = r.castShadow;
                                    q.receiveShadow = r.receiveShadow;
                                    a.add(q);
                                    A.objects[n] = q
                                }
                            } else if ("AmbientLight" === r.type || "PointLight" === r.type || "DirectionalLight" === r.type || "SpotLight" === r.type || "HemisphereLight" ===
                                r.type || "AreaLight" === r.type) {
                                w = r.color;
                                d = r.intensity;
                                f = r.distance;
                                g = r.position;
                                k = r.rotation;
                                switch (r.type) {
                                    case "AmbientLight":
                                        F = new THREE.AmbientLight(w);
                                        break;
                                    case "PointLight":
                                        F = new THREE.PointLight(w, d, f);
                                        F.position.fromArray(g);
                                        break;
                                    case "DirectionalLight":
                                        F = new THREE.DirectionalLight(w, d);
                                        F.position.fromArray(r.direction);
                                        break;
                                    case "SpotLight":
                                        F = new THREE.SpotLight(w, d, f, 1);
                                        F.angle = r.angle;
                                        F.position.fromArray(g);
                                        F.target.set(g[0], g[1] - f, g[2]);
                                        F.target.applyEuler(new THREE.Euler(k[0], k[1],
                                            k[2], "XYZ"));
                                        break;
                                    case "HemisphereLight":
                                        F = new THREE.DirectionalLight(w, d, f);
                                        F.target.set(g[0], g[1] - f, g[2]);
                                        F.target.applyEuler(new THREE.Euler(k[0], k[1], k[2], "XYZ"));
                                        break;
                                    case "AreaLight":
                                        F = new THREE.AreaLight(w, d), F.position.fromArray(g), F.width = r.size, F.height = r.size_y
                                }
                                a.add(F);
                                F.name = n;
                                A.lights[n] = F;
                                A.objects[n] = F
                            } else "PerspectiveCamera" === r.type || "OrthographicCamera" === r.type ? (f = r.position, g = r.rotation, m = r.quaternion, "PerspectiveCamera" === r.type ? x = new THREE.PerspectiveCamera(r.fov, r.aspect,
                                r.near, r.far) : "OrthographicCamera" === r.type && (x = new THREE.OrthographicCamera(r.left, r.right, r.top, r.bottom, r.near, r.far)), x.name = n, x.position.fromArray(f), void 0 !== m ? x.quaternion.fromArray(m) : void 0 !== g ? x.rotation.fromArray(g) : r.target && x.lookAt((new THREE.Vector3).fromArray(r.target)), a.add(x), A.cameras[n] = x, A.objects[n] = x) : (q = new THREE.Object3D, q.name = n, void 0 !== r.matrix ? (w = new THREE.Matrix4, w.fromArray(r.matrix), w.decompose(q.position, q.quaternion, q.scale)) : (void 0 !== r.position && q.position.fromArray(r.position),
                                void 0 !== r.rotation ? q.rotation.fromArray(r.rotation) : void 0 !== r.quaternion && q.quaternion.fromArray(r.quaternion), void 0 !== r.scale && q.scale.fromArray(r.scale)), q.visible = void 0 !== r.visible ? r.visible : !1, a.add(q), A.objects[n] = q, A.empties[n] = q);
                            if (q) {
                                if (void 0 !== r.userData) for (var z in r.userData) q.userData[z] = r.userData[z];
                                if (void 0 !== r.groups) for (w = 0; w < r.groups.length; w++) d = r.groups[w], void 0 === A.groups[d] && (A.groups[d] = []), A.groups[d].push(n)
                            }
                        }
                        void 0 !== q && void 0 !== r.children && h(q, r.children)
                    }
                }

                function g(a,
                           b, d, e, g) {
                    var h = g.rotation, k = g.quaternion, l = g.scale;
                    a.position.fromArray(g.position);
                    k ? a.quaternion.fromArray(k) : a.rotation.fromArray(h);
                    a.scale.fromArray(l);
                    e && a.traverse(function (a) {
                        a.material = e
                    });
                    var m = void 0 !== g.visible ? g.visible : !0;
                    a.traverse(function (a) {
                        a.visible = m
                    });
                    d.add(a);
                    a.name = b;
                    A.objects[b] = a;
                    f()
                }

                function k(a) {
                    return function (b, d) {
                        b.name = a;
                        A.geometries[a] = b;
                        A.face_materials[a] = d;
                        f();
                        --B;
                        p.onLoadComplete();
                        n()
                    }
                }

                function l(a, b, d, e) {
                    return function (f) {
                        g(f.content ? f.content : f.dae ? f.scene :
                            f, a, b, d, e);
                        --B;
                        p.onLoadComplete();
                        n()
                    }
                }

                function m(a) {
                    return function (b, d) {
                        b.name = a;
                        A.geometries[a] = b;
                        A.face_materials[a] = d
                    }
                }

                function n() {
                    p.callbackProgress({
                        totalModels: E,
                        totalTextures: I,
                        loadedModels: E - B,
                        loadedTextures: I - H
                    }, A);
                    p.onLoadProgress();
                    if (0 === B && 0 === H) {
                        for (var a = 0; a < N.length; a++) {
                            var d = N[a], e = A.objects[d.targetName];
                            e ? d.object.target = e : (d.object.target = new THREE.Object3D, A.scene.add(d.object.target));
                            d.object.target.userData.targetInverse = d.object
                        }
                        b(A)
                    }
                }

                function q(a, b) {
                    b(a);
                    if (void 0 !==
                        a.children) for (var d in a.children) q(a.children[d], b)
                }

                var p = this, r = THREE.Loader.prototype.extractUrlBase(d), v, u, x, w, z, F, B, H, E, I, A, N = [],
                    G = a, D;
                for (D in this.geometryHandlers) a = this.geometryHandlers[D].loaderClass, this.geometryHandlers[D].loaderObject = new a;
                for (D in this.hierarchyHandlers) a = this.hierarchyHandlers[D].loaderClass, this.hierarchyHandlers[D].loaderObject = new a;
                H = B = 0;
                A = {
                    scene: new THREE.Scene,
                    geometries: {},
                    face_materials: {},
                    materials: {},
                    textures: {},
                    objects: {},
                    cameras: {},
                    lights: {},
                    fogs: {},
                    empties: {},
                    groups: {}
                };
                G.transform && (D = G.transform.position, a = G.transform.rotation, d = G.transform.scale, D && A.scene.position.fromArray(D), a && A.scene.rotation.fromArray(a), d && A.scene.scale.fromArray(d), D || a || d) && (A.scene.updateMatrix(), A.scene.updateMatrixWorld());
                D = function (a) {
                    return function () {
                        H -= a;
                        n();
                        p.onLoadComplete()
                    }
                };
                for (var Y in G.fogs) a = G.fogs[Y], "linear" === a.type ? w = new THREE.Fog(0, a.near, a.far) : "exp2" === a.type && (w = new THREE.FogExp2(0, a.density)), a = a.color, w.color.setRGB(a[0], a[1], a[2]), A.fogs[Y] = w;
                for (var C in G.geometries) w =
                    G.geometries[C], w.type in this.geometryHandlers && (B += 1, p.onLoadStart());
                for (z in G.objects) q(G.objects[z], function (a) {
                    a.type && a.type in p.hierarchyHandlers && (B += 1, p.onLoadStart())
                });
                E = B;
                for (C in G.geometries) if (w = G.geometries[C], "cube" === w.type) v = new THREE.BoxGeometry(w.width, w.height, w.depth, w.widthSegments, w.heightSegments, w.depthSegments), v.name = C, A.geometries[C] = v; else if ("plane" === w.type) v = new THREE.PlaneGeometry(w.width, w.height, w.widthSegments, w.heightSegments), v.name = C, A.geometries[C] = v; else if ("sphere" ===
                    w.type) v = new THREE.SphereGeometry(w.radius, w.widthSegments, w.heightSegments), v.name = C, A.geometries[C] = v; else if ("cylinder" === w.type) v = new THREE.CylinderGeometry(w.topRad, w.botRad, w.height, w.radSegs, w.heightSegs), v.name = C, A.geometries[C] = v; else if ("torus" === w.type) v = new THREE.TorusGeometry(w.radius, w.tube, w.segmentsR, w.segmentsT), v.name = C, A.geometries[C] = v; else if ("icosahedron" === w.type) v = new THREE.IcosahedronGeometry(w.radius, w.subdivisions), v.name = C, A.geometries[C] = v; else if (w.type in this.geometryHandlers) {
                    var K =
                        this.geometryHandlers[w.type].loaderObject;
                    K.load(e(w.url, G.urlBaseType), k(C))
                } else "Geometry" === w.type ? (K = new THREE.JSONLoader, z = K.parse(w.data), z.geometry.name = w.uuid, A.geometries[w.uuid] = z.geometry) : "embedded" === w.type && (z = G.embeds[w.id], z.metadata = G.metadata, z && (z = this.geometryHandlers.ascii.loaderObject.parse(z, ""), m(C)(z.geometry, z.materials)));
                for (var J in G.textures) if (C = G.textures[J], C.url instanceof Array) for (H += C.url.length, z = 0; z < C.url.length; z++) p.onLoadStart(); else H += 1, p.onLoadStart();
                I = H;
                for (J in G.textures) {
                    C = G.textures[J];
                    void 0 !== C.mapping && void 0 !== THREE[C.mapping] && (C.mapping = THREE[C.mapping]);
                    if (C.url instanceof Array) {
                        z = C.url.length;
                        w = [];
                        for (var L = 0; L < z; L++) w[L] = e(C.url[L], G.urlBaseType);
                        K = THREE.Loader.Handlers.get(w[0]);
                        null !== K ? (z = K.load(w, D(z)), void 0 !== C.mapping && (z.mapping = C.mapping)) : z = THREE.ImageUtils.loadTextureCube(w, C.mapping, D(z))
                    } else {
                        if (C.image) {
                            z = !1;
                            for (L in G.images) if (G.images[L].uuid === C.image) {
                                z = G.images[L];
                                break
                            }
                            z && (C.url = z.url)
                        }
                        var U = e(C.url, G.urlBaseType),
                            aa = D(1), K = THREE.Loader.Handlers.get(U);
                        null !== K ? z = K.load(U, aa) : (z = new THREE.Texture, K = new THREE.ImageLoader, K.crossOrigin = this.crossOrigin, function (a) {
                            K.load(U, function (b) {
                                a.image = b;
                                a.needsUpdate = !0;
                                aa()
                            })
                        }(z));
                        void 0 !== C.mapping && (z.mapping = C.mapping);
                        void 0 !== THREE[C.minFilter] && (z.minFilter = THREE[C.minFilter]);
                        void 0 !== THREE[C.magFilter] && (z.magFilter = THREE[C.magFilter]);
                        C.anisotropy && (z.anisotropy = C.anisotropy);
                        C.repeat && (z.repeat.set(C.repeat[0], C.repeat[1]), 1 !== C.repeat[0] && (z.wrapS = THREE.RepeatWrapping),
                        1 !== C.repeat[1] && (z.wrapT = THREE.RepeatWrapping));
                        C.offset && z.offset.set(C.offset[0], C.offset[1]);
                        C.wrap && (w = {
                            repeat: THREE.RepeatWrapping,
                            mirror: THREE.MirroredRepeatWrapping
                        }, void 0 !== w[C.wrap[0]] && (z.wrapS = w[C.wrap[0]]), void 0 !== w[C.wrap[1]] && (z.wrapT = w[C.wrap[1]]))
                    }
                    A.textures[J] = z;
                    C.loadedTexture = z
                }
                var Z, P;
                for (Z in G.materials) {
                    J = G.materials[Z];
                    for (P in J.parameters) "envMap" === P || "map" === P || "lightMap" === P || "bumpMap" === P || "normalMap" === P || "alphaMap" === P ? J.parameters[P] = A.textures[J.parameters[P]] :
                        "shading" === P ? J.parameters[P] = "flat" === J.parameters[P] ? THREE.FlatShading : THREE.SmoothShading : "side" === P ? J.parameters[P] = "double" == J.parameters[P] ? THREE.DoubleSide : "back" == J.parameters[P] ? THREE.BackSide : THREE.FrontSide : "blending" === P ? J.parameters[P] = J.parameters[P] in THREE ? THREE[J.parameters[P]] : THREE.NormalBlending : "combine" === P ? J.parameters[P] = J.parameters[P] in THREE ? THREE[J.parameters[P]] : THREE.MultiplyOperation : "vertexColors" === P ? "face" == J.parameters[P] ? J.parameters[P] = THREE.FaceColors : J.parameters[P] &&
                            (J.parameters[P] = THREE.VertexColors) : "wrapRGB" === P ? (D = J.parameters[P], J.parameters[P] = new THREE.Vector3(D[0], D[1], D[2])) : "normalScale" === P && (D = J.parameters[P], J.parameters[P] = new THREE.Vector2(D[0], D[1]));
                    if ("undefined" === typeof J.parameters) {
                        if (J.map) {
                            z = !1;
                            for (L in G.textures) if (G.textures[L].uuid === J.map) {
                                z = G.textures[L];
                                break
                            }
                            z && (J.map = z.loadedTexture)
                        }
                        Z = J.uuid;
                        u = new THREE[J.type](J)
                    } else void 0 !== J.parameters.opacity && 1 > J.parameters.opacity && (J.parameters.transparent = !0), u = new THREE[J.type](J.parameters);
                    u.name = Z;
                    A.materials[Z] = u
                }
                for (Z in G.materials) if (J = G.materials[Z], J.parameters && J.parameters.materials) {
                    P = [];
                    for (L = 0; L < J.parameters.materials.length; L++) P.push(A.materials[J.parameters.materials[L]]);
                    A.materials[Z].materials = P
                }
                f();
                A.cameras && G.defaults && G.defaults.camera && (A.currentCamera = A.cameras[G.defaults.camera]);
                A.fogs && G.defaults && G.defaults.fog && (A.scene.fog = A.fogs[G.defaults.fog]);
                p.callbackSync(A);
                n()
            }
        };
        return THREE.SceneLoader
    });
    define("com/visioglobe/common/AjaxProgress", ["require"], function (a) {
        (function (a) {
            var d = a.ajaxSettings.xhr;
            a.ajaxSetup({
                xhr: function () {
                    var a = this, b = d.bind(a)();
                    b && ("function" == typeof b.addEventListener && void 0 !== a.progress && b.addEventListener("progress", function (b) {
                        a.progress(b)
                    }, !1), "object" == typeof b.upload && void 0 !== a.progressUpload && b.upload.addEventListener("progress", function (b) {
                        a.progressUpload(b)
                    }, !1));
                    return b
                }
            })
        })(jQuery);
        return jQuery
    });
    define("com/visioglobe/common/SlotHelper", ["require"], function (a) {
        var b = function () {
        };
        b.compareVersions = function (a, b) {
            for (var f = a.split(/\./), h = b.split(/\./), g = f.length, k = h.length; k < g;) h.push("0"), k++;
            for (; g < k;) f.push("0"), g++;
            for (k = 0; k < g; k++) {
                var l = parseInt(f[k], 10), m = parseInt(h[k], 10);
                if (l < m) return -1;
                if (l > m) return 1
            }
            return 0
        };
        b.checkSlotDescriptionOrLoadJSON = function (a, e, f, h, g, k, l) {
            a.notify(.25, "finish download");
            setTimeout(function () {
                var m = "string" === typeof h.sdkType ? [h.sdkType] : h.sdkType, n = h.sdkVersion,
                    q = h.minimumDataSDKVersion || h.sdkVersion, p = new Date;
                try {
                    var r = JSON.parse(e);
                    e = null;
                    a.notify(.5, "finished JSON parse")
                } catch (v) {
                    a.reject({message: "error parsing json map data", exception: v});
                    return
                }
                if ("undefined" !== typeof r.maps) {
                    if ("undefined" === typeof r.version || 1 != r.version) {
                        a.reject({message: "missing overall version or not equal to 1"});
                        return
                    }
                    if (!0 === l) {
                        a.reject({message: "error: slot.descrition refers to another slot description"});
                        return
                    }
                    if (jQuery.isArray(r.maps) && 0 < r.maps.length) {
                        r = r.maps[0];
                        if ("string" !== typeof r.sdk_type || -1 === m.indexOf(r.sdk_type)) {
                            a.reject({message: "missing or wrong slot sdk_type: " + r.sdk_type});
                            return
                        }
                        if ("undefined" === typeof r.sdk_version) {
                            a.reject({message: "missing slot attribute sdk_version"});
                            return
                        }
                        "undefined" === typeof r.sdk_min_version && (r.sdk_min_version = r.sdk_version);
                        if (1 == b.compareVersions(r.sdk_min_version, n)) {
                            a.reject({message: "data's minimum sdk_version " + r.sdk_min_version + " is higher than this SDK's version " + n + " Data too new, update SDK, or get different data"});
                            return
                        }
                        if (-1 == b.compareVersions(r.sdk_version, q)) {
                            a.reject({message: "data's sdk_version " + r["sdk.version"] + " is smaller than this SDK's minimumDataSDKVersion " + q + " Data is too old, update data"});
                            return
                        }
                        if ("undefined" !== typeof r.expiry_date) {
                            m = new Date(r.expiry_date + " UTC");
                            if (isNaN(m.getTime())) {
                                a.reject({message: "Bad slot expiry_date: " + r.expiry_date});
                                return
                            }
                            if (m < p) {
                                a.reject({message: "map has expired on: " + r.expiry_date});
                                return
                            }
                        }
                        if ("string" === typeof r.path) {
                            p = jQuery.extend(!0, {}, f);
                            m = f.path.replace(/\/[^/]+$/,
                                "/");
                            /\//.test(m) || (m = "");
                            n = /http|https|\/\//i;
                            q = /^\/[^/]/;
                            if (r.base_url) var u = r.base_url,
                                r = n.test(u) || q.test(u) ? u + "/" + r.path : m + u + "/" + r.path; else r = m + r.path;
                            p.path = r;
                            g(a, p)
                        } else {
                            a.reject({message: "invalid slot.description: maps missing .path"});
                            return
                        }
                    } else {
                        a.reject({message: "invalid slot.description: missing maps, or not array or length == 0"});
                        return
                    }
                } else setTimeout(function (b) {
                    return function () {
                        k(a, b)
                    }
                }(r), 0);
                r = null
            }, 0)
        };
        return b
    });
    (function (a) {
        function b(a, b, d) {
            var e = 0, f = [], h = 0, p, q, r, v, u, x, w, z = !1, B = !1, F = [], I = [], la, ea = !1;
            d = d || {};
            p = d.encoding || "UTF8";
            la = d.numRounds || 1;
            r = n(b, p);
            if (la !== parseInt(la, 10) || 1 > la) throw Error("numRounds must a integer >= 1");
            x = function (b, d) {
                return E(b, d, a)
            };
            w = function (b, d, e, f) {
                var g, h;
                if ("SHA-224" === a || "SHA-256" === a) g = (d + 65 >>> 9 << 4) + 15, h = 16; else throw Error("Unexpected error in SHA-2 implementation");
                for (; b.length <= g;) b.push(0);
                b[d >>> 5] |= 128 << 24 - d % 32;
                b[g] = d + e;
                e = b.length;
                for (d = 0; d < e; d += h) f = E(b.slice(d,
                    d + h), f, a);
                if ("SHA-224" === a) b = [f[0], f[1], f[2], f[3], f[4], f[5], f[6]]; else if ("SHA-256" === a) b = f; else throw Error("Unexpected error in SHA-2 implementation");
                return b
            };
            if ("SHA-224" === a) u = 512, v = 224; else if ("SHA-256" === a) u = 512, v = 256; else throw Error("Chosen SHA variant is not supported");
            q = H(a);
            this.setHMACKey = function (b, d, f) {
                var g;
                if (!0 === B) throw Error("HMAC key already set");
                if (!0 === z) throw Error("Cannot set HMAC key after finalizing hash");
                if (!0 === ea) throw Error("Cannot set HMAC key after calling update");
                p = (f || {}).encoding || "UTF8";
                d = n(d, p)(b);
                b = d.binLen;
                d = d.value;
                g = u >>> 3;
                f = g / 4 - 1;
                if (g < b / 8) {
                    for (d = w(d, b, 0, H(a)); d.length <= f;) d.push(0);
                    d[f] &= 4294967040
                } else if (g > b / 8) {
                    for (; d.length <= f;) d.push(0);
                    d[f] &= 4294967040
                }
                for (b = 0; b <= f; b += 1) F[b] = d[b] ^ 909522486, I[b] = d[b] ^ 1549556828;
                q = x(F, q);
                e = u;
                B = !0
            };
            this.update = function (a) {
                var b, d, g, k = 0, l = u >>> 5;
                b = r(a, f, h);
                a = b.binLen;
                d = b.value;
                b = a >>> 5;
                for (g = 0; g < b; g += l) k + u <= a && (q = x(d.slice(g, g + l), q), k += u);
                e += k;
                f = d.slice(k >>> 5);
                h = a % u;
                ea = !0
            };
            this.getHash = function (b, d) {
                var n, p, r;
                if (!0 ===
                    B) throw Error("Cannot call getHash after setting HMAC key");
                r = m(d);
                switch (b) {
                    case "HEX":
                        n = function (a) {
                            return g(a, r)
                        };
                        break;
                    case "B64":
                        n = function (a) {
                            return k(a, r)
                        };
                        break;
                    case "BYTES":
                        n = l;
                        break;
                    default:
                        throw Error("format must be HEX, B64, or BYTES");
                }
                if (!1 === z) for (q = w(f, h, e, q), p = 1; p < la; p += 1) q = w(q, v, 0, H(a));
                z = !0;
                return n(q)
            };
            this.getHMAC = function (b, d) {
                var n, p, r;
                if (!1 === B) throw Error("Cannot call getHMAC without first setting HMAC key");
                r = m(d);
                switch (b) {
                    case "HEX":
                        n = function (a) {
                            return g(a, r)
                        };
                        break;
                    case "B64":
                        n = function (a) {
                            return k(a, r)
                        };
                        break;
                    case "BYTES":
                        n = l;
                        break;
                    default:
                        throw Error("outputFormat must be HEX, B64, or BYTES");
                }
                !1 === z && (p = w(f, h, e, q), q = x(I, H(a)), q = w(p, v, u, q));
                z = !0;
                return n(q)
            }
        }

        function d() {
        }

        function e(a, b, d) {
            var e = a.length, f, g, h, k, l;
            b = b || [0];
            d = d || 0;
            l = d >>> 3;
            if (0 !== e % 2) throw Error("String of HEX type must be in byte increments");
            for (f = 0; f < e; f += 2) {
                g = parseInt(a.substr(f, 2), 16);
                if (isNaN(g)) throw Error("String of HEX type contains invalid characters");
                k = (f >>> 1) + l;
                for (h = k >>> 2; b.length <=
                h;) b.push(0);
                b[h] |= g << 8 * (3 - k % 4)
            }
            return {value: b, binLen: 4 * e + d}
        }

        function f(a, b, d) {
            var e = [], f, g, h, k, e = b || [0];
            d = d || 0;
            g = d >>> 3;
            for (f = 0; f < a.length; f += 1) b = a.charCodeAt(f), k = f + g, h = k >>> 2, e.length <= h && e.push(0), e[h] |= b << 8 * (3 - k % 4);
            return {value: e, binLen: 8 * a.length + d}
        }

        function h(a, b, d) {
            var e = [], f = 0, g, h, k, l, m, n, e = b || [0];
            d = d || 0;
            b = d >>> 3;
            if (-1 === a.search(/^[a-zA-Z0-9=+\/]+$/)) throw Error("Invalid character in base-64 string");
            h = a.indexOf("=");
            a = a.replace(/\=/g, "");
            if (-1 !== h && h < a.length) throw Error("Invalid '=' found in base-64 string");
            for (h = 0; h < a.length; h += 4) {
                m = a.substr(h, 4);
                for (k = l = 0; k < m.length; k += 1) g = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(m[k]), l |= g << 18 - 6 * k;
                for (k = 0; k < m.length - 1; k += 1) {
                    n = f + b;
                    for (g = n >>> 2; e.length <= g;) e.push(0);
                    e[g] |= (l >>> 16 - 8 * k & 255) << 8 * (3 - n % 4);
                    f += 1
                }
            }
            return {value: e, binLen: 8 * f + d}
        }

        function g(a, b) {
            var d = "", e = 4 * a.length, f, g;
            for (f = 0; f < e; f += 1) g = a[f >>> 2] >>> 8 * (3 - f % 4), d += "0123456789abcdef".charAt(g >>> 4 & 15) + "0123456789abcdef".charAt(g & 15);
            return b.outputUpper ? d.toUpperCase() : d
        }

        function k(a,
                   b) {
            var d = "", e = 4 * a.length, f, g, h;
            for (f = 0; f < e; f += 3) for (h = f + 1 >>> 2, g = a.length <= h ? 0 : a[h], h = f + 2 >>> 2, h = a.length <= h ? 0 : a[h], h = (a[f >>> 2] >>> 8 * (3 - f % 4) & 255) << 16 | (g >>> 8 * (3 - (f + 1) % 4) & 255) << 8 | h >>> 8 * (3 - (f + 2) % 4) & 255, g = 0; 4 > g; g += 1) 8 * f + 6 * g <= 32 * a.length ? d += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(h >>> 6 * (3 - g) & 63) : d += b.b64Pad;
            return d
        }

        function l(a) {
            var b = "", d = 4 * a.length, e, f;
            for (e = 0; e < d; e += 1) f = a[e >>> 2] >>> 8 * (3 - e % 4) & 255, b += String.fromCharCode(f);
            return b
        }

        function m(a) {
            var b = {outputUpper: !1, b64Pad: "="};
            a = a || {};
            b.outputUpper = a.outputUpper || !1;
            !0 === a.hasOwnProperty("b64Pad") && (b.b64Pad = a.b64Pad);
            if ("boolean" !== typeof b.outputUpper) throw Error("Invalid outputUpper formatting option");
            if ("string" !== typeof b.b64Pad) throw Error("Invalid b64Pad formatting option");
            return b
        }

        function n(a, b) {
            var d;
            switch (b) {
                case "UTF8":
                case "UTF16BE":
                case "UTF16LE":
                    break;
                default:
                    throw Error("encoding must be UTF8, UTF16BE, or UTF16LE");
            }
            switch (a) {
                case "HEX":
                    d = e;
                    break;
                case "TEXT":
                    d = function (a, d, e) {
                        var f = [], g = [], h = 0, k, l, m,
                            n, p, f = d || [0];
                        d = e || 0;
                        m = d >>> 3;
                        if ("UTF8" === b) for (k = 0; k < a.length; k += 1) for (e = a.charCodeAt(k), g = [], 128 > e ? g.push(e) : 2048 > e ? (g.push(192 | e >>> 6), g.push(128 | e & 63)) : 55296 > e || 57344 <= e ? g.push(224 | e >>> 12, 128 | e >>> 6 & 63, 128 | e & 63) : (k += 1, e = 65536 + ((e & 1023) << 10 | a.charCodeAt(k) & 1023), g.push(240 | e >>> 18, 128 | e >>> 12 & 63, 128 | e >>> 6 & 63, 128 | e & 63)), l = 0; l < g.length; l += 1) {
                            p = h + m;
                            for (n = p >>> 2; f.length <= n;) f.push(0);
                            f[n] |= g[l] << 8 * (3 - p % 4);
                            h += 1
                        } else if ("UTF16BE" === b || "UTF16LE" === b) for (k = 0; k < a.length; k += 1) {
                            e = a.charCodeAt(k);
                            "UTF16LE" === b &&
                            (l = e & 255, e = l << 8 | e >>> 8);
                            p = h + m;
                            for (n = p >>> 2; f.length <= n;) f.push(0);
                            f[n] |= e << 8 * (2 - p % 4);
                            h += 2
                        }
                        return {value: f, binLen: 8 * h + d}
                    };
                    break;
                case "B64":
                    d = h;
                    break;
                case "BYTES":
                    d = f;
                    break;
                default:
                    throw Error("format must be HEX, TEXT, B64, or BYTES");
            }
            return d
        }

        function q(a, b) {
            return a >>> b | a << 32 - b
        }

        function p(a, b, d) {
            return a & b ^ ~a & d
        }

        function r(a, b, d) {
            return a & b ^ a & d ^ b & d
        }

        function v(a) {
            return q(a, 2) ^ q(a, 13) ^ q(a, 22)
        }

        function u(a) {
            return q(a, 6) ^ q(a, 11) ^ q(a, 25)
        }

        function x(a) {
            return q(a, 7) ^ q(a, 18) ^ a >>> 3
        }

        function w(a) {
            return q(a,
                17) ^ q(a, 19) ^ a >>> 10
        }

        function z(a, b) {
            var d = (a & 65535) + (b & 65535);
            return ((a >>> 16) + (b >>> 16) + (d >>> 16) & 65535) << 16 | d & 65535
        }

        function F(a, b, d, e) {
            var f = (a & 65535) + (b & 65535) + (d & 65535) + (e & 65535);
            return ((a >>> 16) + (b >>> 16) + (d >>> 16) + (e >>> 16) + (f >>> 16) & 65535) << 16 | f & 65535
        }

        function B(a, b, d, e, f) {
            var g = (a & 65535) + (b & 65535) + (d & 65535) + (e & 65535) + (f & 65535);
            return ((a >>> 16) + (b >>> 16) + (d >>> 16) + (e >>> 16) + (f >>> 16) + (g >>> 16) & 65535) << 16 | g & 65535
        }

        function H(a) {
            var b, e;
            b = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839,
                3204075428];
            e = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225];
            switch (a) {
                case "SHA-224":
                    a = b;
                    break;
                case "SHA-256":
                    a = e;
                    break;
                case "SHA-384":
                    a = [new d, new d, new d, new d, new d, new d, new d, new d];
                    break;
                case "SHA-512":
                    a = [new d, new d, new d, new d, new d, new d, new d, new d];
                    break;
                default:
                    throw Error("Unknown SHA variant");
            }
            return a
        }

        function E(a, b, d) {
            var e, f, g, h, k, l, m, n, q, E, H, da, ca, M, la, ea, ka, na, T, X, ra, Fa, va = [], Va;
            if ("SHA-224" === d || "SHA-256" === d) E = 64, da = 1, Fa = Number, ca = z,
                M = F, la = B, ea = x, ka = w, na = v, T = u, ra = r, X = p, Va = I; else throw Error("Unexpected error in SHA-2 implementation");
            d = b[0];
            e = b[1];
            f = b[2];
            g = b[3];
            h = b[4];
            k = b[5];
            l = b[6];
            m = b[7];
            for (H = 0; H < E; H += 1) 16 > H ? (q = H * da, n = a.length <= q ? 0 : a[q], q = a.length <= q + 1 ? 0 : a[q + 1], va[H] = new Fa(n, q)) : va[H] = M(ka(va[H - 2]), va[H - 7], ea(va[H - 15]), va[H - 16]), n = la(m, T(h), X(h, k, l), Va[H], va[H]), q = ca(na(d), ra(d, e, f)), m = l, l = k, k = h, h = ca(g, n), g = f, f = e, e = d, d = ca(n, q);
            b[0] = ca(d, b[0]);
            b[1] = ca(e, b[1]);
            b[2] = ca(f, b[2]);
            b[3] = ca(g, b[3]);
            b[4] = ca(h, b[4]);
            b[5] = ca(k, b[5]);
            b[6] = ca(l, b[6]);
            b[7] = ca(m, b[7]);
            return b
        }

        var I;
        I = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
            3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
        "function" === typeof define && define.amd ? define("sha256", [], function () {
            return b
        }) : "undefined" !== typeof exports ? "undefined" !== typeof module && module.exports ? module.exports = exports = b : exports = b : a.jsSHA = b
    })(this);
    define("com/visioglobe/common/utils/MapChecker", ["require", "sha256"], function (a) {
        var b = a("sha256");
        return {
            check: function (a, e, f) {
                f = f || {};
                if (void 0 === a || void 0 === a.pois || void 0 === a.pois.hedVersion) return !0;
                var h = JSON.stringify({
                    expiration: a.expiration,
                    nbRoutingNodes: a.routing ? a.routing.nodes.length : 0,
                    nbRoutingEdges: a.routing ? a.routing.edges.length : 0
                }), g = new b("SHA-256", "TEXT");
                g.update(e + h);
                hashedCredential = g.getHash("HEX");
                if (hashedCredential !== a.credentials) return f.message = "map integrity failure",
                    !1;
                if ("never" === a.expiration) return !0;
                a = new Date(a.expiration);
                return new Date > a ? (f.message = "map expired on " + a, !1) : !0
            }
        }
    });
    define("com/visioglobe/common/Notifications", [], function () {
        var a = function () {
            this.onNotificationHandlers = {};
            this.onStickyNotification = {}
        };
        a.prototype.on = function (a, d, e) {
            e = e || !1;
            var f = a.split(/ /);
            if (1 != f.length) for (var h in f) this.on(f[h], d); else "undefined" === typeof this.onNotificationHandlers[a] && (this.onNotificationHandlers[a] = []), this.onNotificationHandlers[a].push({
                callback: d,
                once: e
            }), "undefined" !== typeof this.onStickyNotification[a] && d(this.onStickyNotification[a].event)
        };
        a.prototype.off = function (a,
                                    d) {
            var e = a.split(/ /);
            if (1 != e.length) for (var f in e) this.off(e[f], d); else {
                if ("undefined" === typeof this.onNotificationHandlers[a]) return !1;
                if ("undefined" === typeof d) return this.onNotificationHandlers[a] = [], !0;
                e = this.onNotificationHandlers[a];
                f = 0;
                for (var h = e.length; f < h; ++f) if (e[f].callback === d) return e.splice(f, 1), !0;
                return !1
            }
        };
        a.prototype.trigger = function (a, d, e) {
            var f = a.split(/ /), h;
            if (1 != f.length) for (var g in f) {
                if (h = this.trigger(f[g], d, e), !1 === h) return !1
            } else if (e && (this.onStickyNotification[a] =
                    {event: k}), "undefined" !== typeof this.onNotificationHandlers[a]) {
                var k = {type: a, args: d};
                h = this.onNotificationHandlers[a];
                d = [];
                g = 0;
                for (e = h.length; g < e; ++g) d.push(h[g]);
                g = 0;
                for (e = d.length; g < e; ++g) if (f = d[g], h = f.callback(k), f.once && this.off(a, f.function), !1 === h) return !1
            }
        };
        return a
    });
    define("text!com/visioglobe/web/shaders/depth.frag", [], function () {
        return "varying vec3 vPos;void main(){float a=vPos.z;float b=clamp(1.0-a/5.0,0.0,1.0);gl_FragColor=vec4(vec3(b),1.0);}"
    });
    define("text!com/visioglobe/web/shaders/depth.vert", [], function () {
        return "varying vec3 vPos;void main(){vPos=position;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}"
    });
    define("text!com/visioglobe/web/shaders/water.frag", [], function () {
        return "float a(const in vec4 b){const vec4 c=vec4(1.0/(256.0*256.0*256.0),1.0/(256.0*256.0),1.0/256.0,1.0);float d=dot(b,c);return d;}varying vec2 vUv;varying vec3 vPos;varying vec3 vColor;uniform sampler2D tDiffuse;uniform sampler2D tDepth;uniform sampler2D tNoise;uniform float viewWidth;uniform float viewHeight;uniform vec3 uColor;uniform float near;uniform float far;uniform float time;uniform vec3 eye;uniform vec3 sunDirection;uniform vec3 sunColor;vec4 e(vec2 f){vec2 g=(f/103.0)+vec2(time/17.0,time/29.0);vec2 h=f/107.0-vec2(time/-19.0,time/31.0);vec2 i=f/vec2(897.0,983.0)+vec2(time/101.0,time/97.0);vec2 j=f/vec2(991.0,877.0)-vec2(time/109.0,time/-113.0);vec4 k=(texture2D(tNoise,g))+(texture2D(tNoise,h))+(texture2D(tNoise,i))+(texture2D(tNoise,j));return k*0.5-1.0;}void l(const vec3 m,const vec3 n,float o,float p,float q,inout vec3 r,inout vec3 s){vec3 t=normalize(reflect(-sunDirection,m));float u=max(0.0,dot(n,t));s+=pow(u,o)*sunColor*p;r+=max(dot(sunDirection,m),0.0)*sunColor*q;}void main(){vec2 v=gl_FragCoord.xy*vec2(1.0/viewWidth,1.0/viewHeight);vec4 w=texture2D(tDepth,v);float d=w.x;float x=d*0.5;vec4 k=e(vPos.xy*4.0);vec3 m=normalize(k.xzy*vec3(2.0,1.0,2.0));vec3 q=vec3(0.0);vec3 y=vec3(0.0);vec3 z=eye-vPos;vec3 A=normalize(z);l(m,A,100.0,2.0,0.5,q,y);vec4 B=texture2D(tDiffuse,v+m.xz*(1.0-w.x)*0.025);vec3 C=vColor;gl_FragColor=vec4(mix(C.xyz,B.xyz,0.5),1.0);}"
    });
    define("text!com/visioglobe/web/shaders/water.vert", [], function () {
        return "attribute vec3 color;varying vec2 vUv;varying vec3 vPos;varying vec3 vColor;void main(){vUv=uv;vPos=position;vColor=color;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}"
    });
    define("text!com/visioglobe/web/shaders/sky.frag", [], function () {
        return "uniform vec3 topColor;uniform vec3 bottomColor;uniform float offset;uniform float exponent;varying vec3 vWorldPosition;void main(){float a=normalize(vWorldPosition.yzx+offset).y;gl_FragColor=vec4(mix(bottomColor,topColor,max(pow(max(a,0.0),exponent),0.0)),1.0);}"
    });
    define("text!com/visioglobe/web/shaders/sky.vert", [], function () {
        return "varying vec3 vWorldPosition;void main(){vec4 a=modelMatrix*vec4(position,1.0);vWorldPosition=a.xyz;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}"
    });
    (function (a, b, d, e) {
        function f(a, b, d) {
            return setTimeout(n(a, d), b)
        }

        function h(a, b, d) {
            return Array.isArray(a) ? (g(a, d[b], d), !0) : !1
        }

        function g(a, b, d) {
            var f;
            if (a) if (a.forEach) a.forEach(b, d); else if (a.length !== e) for (f = 0; f < a.length;) b.call(d, a[f], f, a), f++; else for (f in a) a.hasOwnProperty(f) && b.call(d, a[f], f, a)
        }

        function k(a, b, d) {
            for (var f = Object.keys(b), g = 0; g < f.length;) {
                if (!d || d && a[f[g]] === e) a[f[g]] = b[f[g]];
                g++
            }
            return a
        }

        function l(a, b) {
            return k(a, b, !0)
        }

        function m(a, b, d) {
            b = b.prototype;
            var e;
            e = a.prototype = Object.create(b);
            e.constructor = a;
            e._super = b;
            d && k(e, d)
        }

        function n(a, b) {
            return function () {
                return a.apply(b, arguments)
            }
        }

        function q(a, b) {
            return "function" == typeof a ? a.apply(b ? b[0] || e : e, b) : a
        }

        function p(a, b, d) {
            g(u(b), function (b) {
                a.addEventListener(b, d, !1)
            })
        }

        function r(a, b, d) {
            g(u(b), function (b) {
                a.removeEventListener(b, d, !1)
            })
        }

        function v(a, b) {
            for (; a;) {
                if (a == b) return !0;
                a = a.parentNode
            }
            return !1
        }

        function u(a) {
            return a.trim().split(/\s+/g)
        }

        function x(a, b, d) {
            if (a.indexOf && !d) return a.indexOf(b);
            for (var e = 0; e < a.length;) {
                if (d && a[e][d] ==
                    b || !d && a[e] === b) return e;
                e++
            }
            return -1
        }

        function w(a) {
            return Array.prototype.slice.call(a, 0)
        }

        function z(a, b, d) {
            for (var e = [], f = [], g = 0; g < a.length;) {
                var h = b ? a[g][b] : a[g];
                0 > x(f, h) && e.push(a[g]);
                f[g] = h;
                g++
            }
            d && (e = b ? e.sort(function (a, d) {
                return a[b] > d[b]
            }) : e.sort());
            return e
        }

        function F(a, b) {
            for (var d, f = b[0].toUpperCase() + b.slice(1), g = 0; g < ya.length;) {
                d = (d = ya[g]) ? d + f : b;
                if (d in a) return d;
                g++
            }
            return e
        }

        function B(a) {
            a = a.ownerDocument;
            return a.defaultView || a.parentWindow
        }

        function H(a, b) {
            var d = this;
            this.manager =
                a;
            this.callback = b;
            this.element = a.element;
            this.target = a.options.inputTarget;
            this.domHandler = function (b) {
                q(a.options.enable, [a]) && d.handler(b)
            };
            this.init()
        }

        function E(a) {
            var b = a.options.inputClass;
            return new (b ? b : bb ? K : Sa ? L : ja ? aa : C)(a, I)
        }

        function I(a, b, d) {
            var f = d.pointers.length, g = d.changedPointers.length, h = b & 1 && 0 === f - g;
            d.isFirst = !!h;
            d.isFinal = !!(b & 12 && 0 === f - g);
            h && (a.session = {});
            d.eventType = b;
            b = a.session;
            f = d.pointers;
            g = f.length;
            b.firstInput || (b.firstInput = A(d));
            1 < g && !b.firstMultiple ? b.firstMultiple =
                A(d) : 1 === g && (b.firstMultiple = !1);
            var h = b.firstInput, k = (g = b.firstMultiple) ? g.center : h.center, l = d.center = N(f);
            d.timeStamp = vb();
            d.deltaTime = d.timeStamp - h.timeStamp;
            d.angle = Y(k, l);
            d.distance = D(k, l);
            var h = d.center, k = b.offsetDelta || {}, l = b.prevDelta || {}, m = b.prevInput || {};
            if (1 === d.eventType || 4 === m.eventType) l = b.prevDelta = {
                x: m.deltaX || 0,
                y: m.deltaY || 0
            }, k = b.offsetDelta = {x: h.x, y: h.y};
            d.deltaX = l.x + (h.x - k.x);
            d.deltaY = l.y + (h.y - k.y);
            d.offsetDirection = G(d.deltaX, d.deltaY);
            g ? (h = g.pointers, h = D(f[0], f[1], Ya) / D(h[0],
                h[1], Ya)) : h = 1;
            d.scale = h;
            g ? (g = g.pointers, f = Y(f[1], f[0], Ya) - Y(g[1], g[0], Ya)) : f = 0;
            d.rotation = f;
            k = b.lastInterval || d;
            f = d.timeStamp - k.timeStamp;
            8 != d.eventType && (25 < f || k.velocity === e) ? (h = k.deltaX - d.deltaX, k = k.deltaY - d.deltaY, l = h / f || 0, m = k / f || 0, f = l, g = m, l = $a(l) > $a(m) ? l : m, h = G(h, k), b.lastInterval = d) : (l = k.velocity, f = k.velocityX, g = k.velocityY, h = k.direction);
            d.velocity = l;
            d.velocityX = f;
            d.velocityY = g;
            d.direction = h;
            b = a.element;
            v(d.srcEvent.target, b) && (b = d.srcEvent.target);
            d.target = b;
            a.emit("hammer.input", d);
            a.recognize(d);
            a.session.prevInput = d
        }

        function A(a) {
            for (var b = [], d = 0; d < a.pointers.length;) b[d] = {
                clientX: ma(a.pointers[d].clientX),
                clientY: ma(a.pointers[d].clientY)
            }, d++;
            return {timeStamp: vb(), pointers: b, center: N(b), deltaX: a.deltaX, deltaY: a.deltaY}
        }

        function N(a) {
            var b = a.length;
            if (1 === b) return {x: ma(a[0].clientX), y: ma(a[0].clientY)};
            for (var d = 0, e = 0, f = 0; f < b;) d += a[f].clientX, e += a[f].clientY, f++;
            return {x: ma(d / b), y: ma(e / b)}
        }

        function G(a, b) {
            return a === b ? 1 : $a(a) >= $a(b) ? 0 < a ? 2 : 4 : 0 < b ? 8 : 16
        }

        function D(a, b, d) {
            d || (d = Ea);
            var e = b[d[0]] -
                a[d[0]];
            a = b[d[1]] - a[d[1]];
            return Math.sqrt(e * e + a * a)
        }

        function Y(a, b, d) {
            d || (d = Ea);
            return 180 * Math.atan2(b[d[1]] - a[d[1]], b[d[0]] - a[d[0]]) / Math.PI
        }

        function C() {
            this.evEl = cb;
            this.evWin = y;
            this.allow = !0;
            this.pressed = !1;
            H.apply(this, arguments)
        }

        function K() {
            this.evEl = Qa;
            this.evWin = ta;
            H.apply(this, arguments);
            this.store = this.manager.session.pointerEvents = []
        }

        function J() {
            this.evTarget = "touchstart";
            this.evWin = "touchstart touchmove touchend touchcancel";
            this.started = !1;
            H.apply(this, arguments)
        }

        function L() {
            this.evTarget =
                Aa;
            this.targetIds = {};
            H.apply(this, arguments)
        }

        function U(a, b) {
            var d = w(a.touches), e = this.targetIds;
            if (b & 3 && 1 === d.length) return e[d[0].identifier] = !0, [d, d];
            var f, g = w(a.changedTouches), h = [], k = this.target;
            f = d.filter(function (a) {
                return v(a.target, k)
            });
            if (1 === b) for (d = 0; d < f.length;) e[f[d].identifier] = !0, d++;
            for (d = 0; d < g.length;) e[g[d].identifier] && h.push(g[d]), b & 12 && delete e[g[d].identifier], d++;
            if (h.length) return [z(f.concat(h), "identifier", !0), h]
        }

        function aa() {
            H.apply(this, arguments);
            var a = n(this.handler,
                this);
            this.touch = new L(this.manager, a);
            this.mouse = new C(this.manager, a)
        }

        function Z(a, b) {
            this.manager = a;
            this.set(b)
        }

        function P(a) {
            if (-1 < a.indexOf("none")) return "none";
            var b = -1 < a.indexOf("pan-x"), d = -1 < a.indexOf("pan-y");
            return b && d ? "pan-x pan-y" : b || d ? b ? "pan-x" : "pan-y" : -1 < a.indexOf("manipulation") ? "manipulation" : "auto"
        }

        function S(a) {
            this.id = Q++;
            this.manager = null;
            this.options = l(a || {}, this.defaults);
            a = this.options.enable;
            this.options.enable = a === e ? !0 : a;
            this.state = 1;
            this.simultaneous = {};
            this.requireFail =
                []
        }

        function da(a) {
            return 16 == a ? "down" : 8 == a ? "up" : 2 == a ? "left" : 4 == a ? "right" : ""
        }

        function ca(a, b) {
            var d = b.manager;
            return d ? d.get(a) : a
        }

        function M() {
            S.apply(this, arguments)
        }

        function la() {
            M.apply(this, arguments);
            this.pY = this.pX = null
        }

        function ea() {
            M.apply(this, arguments)
        }

        function ka() {
            S.apply(this, arguments);
            this._input = this._timer = null
        }

        function na() {
            M.apply(this, arguments)
        }

        function T() {
            M.apply(this, arguments)
        }

        function X() {
            S.apply(this, arguments);
            this.pCenter = this.pTime = !1;
            this._input = this._timer = null;
            this.count =
                0
        }

        function ra(a, b) {
            b = b || {};
            var d = b.recognizers;
            b.recognizers = d === e ? ra.defaults.preset : d;
            return new Fa(a, b)
        }

        function Fa(a, b) {
            b = b || {};
            this.options = l(b, ra.defaults);
            this.options.inputTarget = this.options.inputTarget || a;
            this.handlers = {};
            this.session = {};
            this.recognizers = [];
            this.element = a;
            this.input = E(this);
            this.touchAction = new Z(this, this.options.touchAction);
            va(this, !0);
            g(b.recognizers, function (a) {
                var b = this.add(new a[0](a[1]));
                a[2] && b.recognizeWith(a[2]);
                a[3] && b.requireFailure(a[3])
            }, this)
        }

        function va(a,
                    b) {
            var d = a.element;
            g(a.options.cssProps, function (a, e) {
                d.style[F(d.style, e)] = b ? a : ""
            })
        }

        function Va(a, d) {
            var e = b.createEvent("Event");
            e.initEvent(a, !0, !0);
            e.gesture = d;
            d.target.dispatchEvent(e)
        }

        var ya = " webkit moz MS ms o".split(" "), nb = b.createElement("div"), ma = Math.round, $a = Math.abs,
            vb = Date.now, Q = 1, lb = /mobile|tablet|ip(ad|hone|od)|android/i, ja = "ontouchstart" in a,
            bb = F(a, "PointerEvent") !== e, Sa = ja && lb.test(navigator.userAgent), Ea = ["x", "y"],
            Ya = ["clientX", "clientY"];
        H.prototype = {
            handler: function () {
            }, init: function () {
                this.evEl &&
                p(this.element, this.evEl, this.domHandler);
                this.evTarget && p(this.target, this.evTarget, this.domHandler);
                this.evWin && p(B(this.element), this.evWin, this.domHandler)
            }, destroy: function () {
                this.evEl && r(this.element, this.evEl, this.domHandler);
                this.evTarget && r(this.target, this.evTarget, this.domHandler);
                this.evWin && r(B(this.element), this.evWin, this.domHandler)
            }
        };
        var Cb = {mousedown: 1, mousemove: 2, mouseup: 4}, cb = "mousedown", y = "mousemove mouseup";
        m(C, H, {
            handler: function (a) {
                var b = Cb[a.type];
                b & 1 && 0 === a.button && (this.pressed =
                    !0);
                b & 2 && 1 !== a.which && (b = 4);
                this.pressed && this.allow && (b & 4 && (this.pressed = !1), this.callback(this.manager, b, {
                    pointers: [a],
                    changedPointers: [a],
                    pointerType: "mouse",
                    srcEvent: a
                }))
            }
        });
        var La = {pointerdown: 1, pointermove: 2, pointerup: 4, pointercancel: 8, pointerout: 8},
            ob = {2: "touch", 3: "pen", 4: "mouse", 5: "kinect"}, Qa = "pointerdown",
            ta = "pointermove pointerup pointercancel";
        a.MSPointerEvent && (Qa = "MSPointerDown", ta = "MSPointerMove MSPointerUp MSPointerCancel");
        m(K, H, {
            handler: function (a) {
                var b = this.store, d = !1, e = a.type.toLowerCase().replace("ms",
                    ""), e = La[e], f = ob[a.pointerType] || a.pointerType, g = "touch" == f,
                    h = x(b, a.pointerId, "pointerId");
                e & 1 && (0 === a.button || g) ? 0 > h && (b.push(a), h = b.length - 1) : e & 12 && (d = !0);
                0 > h || (b[h] = a, this.callback(this.manager, e, {
                    pointers: b,
                    changedPointers: [a],
                    pointerType: f,
                    srcEvent: a
                }), d && b.splice(h, 1))
            }
        });
        var Za = {touchstart: 1, touchmove: 2, touchend: 4, touchcancel: 8};
        m(J, H, {
            handler: function (a) {
                var b = Za[a.type];
                1 === b && (this.started = !0);
                if (this.started) {
                    var d;
                    d = w(a.touches);
                    var e = w(a.changedTouches);
                    b & 12 && (d = z(d.concat(e), "identifier",
                        !0));
                    d = [d, e];
                    b & 12 && 0 === d[0].length - d[1].length && (this.started = !1);
                    this.callback(this.manager, b, {
                        pointers: d[0],
                        changedPointers: d[1],
                        pointerType: "touch",
                        srcEvent: a
                    })
                }
            }
        });
        var Ja = {touchstart: 1, touchmove: 2, touchend: 4, touchcancel: 8},
            Aa = "touchstart touchmove touchend touchcancel";
        m(L, H, {
            handler: function (a) {
                var b = Ja[a.type], d = U.call(this, a, b);
                d && this.callback(this.manager, b, {
                    pointers: d[0],
                    changedPointers: d[1],
                    pointerType: "touch",
                    srcEvent: a
                })
            }
        });
        m(aa, H, {
            handler: function (a, b, d) {
                var e = "mouse" == d.pointerType;
                if ("touch" == d.pointerType) this.mouse.allow = !1; else if (e && !this.mouse.allow) return;
                b & 12 && (this.mouse.allow = !0);
                this.callback(a, b, d)
            }, destroy: function () {
                this.touch.destroy();
                this.mouse.destroy()
            }
        });
        var Pa = F(nb.style, "touchAction"), Ta = Pa !== e;
        Z.prototype = {
            set: function (a) {
                "compute" == a && (a = this.compute());
                Ta && (this.manager.element.style[Pa] = a);
                this.actions = a.toLowerCase().trim()
            }, update: function () {
                this.set(this.manager.options.touchAction)
            }, compute: function () {
                var a = [];
                g(this.manager.recognizers, function (b) {
                    q(b.options.enable,
                        [b]) && (a = a.concat(b.getTouchAction()))
                });
                return P(a.join(" "))
            }, preventDefaults: function (a) {
                if (!Ta) {
                    var b = a.srcEvent;
                    a = a.offsetDirection;
                    if (this.manager.session.prevented) b.preventDefault(); else {
                        var d = this.actions, e = -1 < d.indexOf("none"), f = -1 < d.indexOf("pan-y"),
                            d = -1 < d.indexOf("pan-x");
                        if (e || f && a & 6 || d && a & 24) return this.preventSrc(b)
                    }
                }
            }, preventSrc: function (a) {
                this.manager.session.prevented = !0;
                a.preventDefault()
            }
        };
        S.prototype = {
            defaults: {}, set: function (a) {
                k(this.options, a);
                this.manager && this.manager.touchAction.update();
                return this
            }, recognizeWith: function (a) {
                if (h(a, "recognizeWith", this)) return this;
                var b = this.simultaneous;
                a = ca(a, this);
                b[a.id] || (b[a.id] = a, a.recognizeWith(this));
                return this
            }, dropRecognizeWith: function (a) {
                if (h(a, "dropRecognizeWith", this)) return this;
                a = ca(a, this);
                delete this.simultaneous[a.id];
                return this
            }, requireFailure: function (a) {
                if (h(a, "requireFailure", this)) return this;
                var b = this.requireFail;
                a = ca(a, this);
                -1 === x(b, a) && (b.push(a), a.requireFailure(this));
                return this
            }, dropRequireFailure: function (a) {
                if (h(a,
                        "dropRequireFailure", this)) return this;
                a = ca(a, this);
                a = x(this.requireFail, a);
                -1 < a && this.requireFail.splice(a, 1);
                return this
            }, hasRequireFailures: function () {
                return 0 < this.requireFail.length
            }, canRecognizeWith: function (a) {
                return !!this.simultaneous[a.id]
            }, emit: function (a) {
                function b(f) {
                    d.manager.emit(d.options.event + (f ? e & 16 ? "cancel" : e & 8 ? "end" : e & 4 ? "move" : e & 2 ? "start" : "" : ""), a)
                }

                var d = this, e = this.state;
                8 > e && b(!0);
                b();
                8 <= e && b(!0)
            }, tryEmit: function (a) {
                if (this.canEmit()) return this.emit(a);
                this.state = 32
            }, canEmit: function () {
                for (var a =
                    0; a < this.requireFail.length;) {
                    if (!(this.requireFail[a].state & 33)) return !1;
                    a++
                }
                return !0
            }, recognize: function (a) {
                a = k({}, a);
                q(this.options.enable, [this, a]) ? (this.state & 56 && (this.state = 1), this.state = this.process(a), this.state & 30 && this.tryEmit(a)) : (this.reset(), this.state = 32)
            }, process: function (a) {
            }, getTouchAction: function () {
            }, reset: function () {
            }
        };
        m(M, S, {
            defaults: {pointers: 1}, attrTest: function (a) {
                var b = this.options.pointers;
                return 0 === b || a.pointers.length === b
            }, process: function (a) {
                var b = this.state, d = a.eventType,
                    e = b & 6;
                a = this.attrTest(a);
                return e && (d & 8 || !a) ? b | 16 : e || a ? d & 4 ? b | 8 : b & 2 ? b | 4 : 2 : 32
            }
        });
        m(la, M, {
            defaults: {event: "pan", threshold: 10, pointers: 1, direction: 30}, getTouchAction: function () {
                var a = this.options.direction, b = [];
                a & 6 && b.push("pan-y");
                a & 24 && b.push("pan-x");
                return b
            }, directionTest: function (a) {
                var b = this.options, d = !0, e = a.distance, f = a.direction, g = a.deltaX, h = a.deltaY;
                f & b.direction || (b.direction & 6 ? (f = 0 === g ? 1 : 0 > g ? 2 : 4, d = g != this.pX, e = Math.abs(a.deltaX)) : (f = 0 === h ? 1 : 0 > h ? 8 : 16, d = h != this.pY, e = Math.abs(a.deltaY)));
                a.direction =
                    f;
                return d && e > b.threshold && f & b.direction
            }, attrTest: function (a) {
                return M.prototype.attrTest.call(this, a) && (this.state & 2 || !(this.state & 2) && this.directionTest(a))
            }, emit: function (a) {
                this.pX = a.deltaX;
                this.pY = a.deltaY;
                var b = da(a.direction);
                b && this.manager.emit(this.options.event + b, a);
                this._super.emit.call(this, a)
            }
        });
        m(ea, M, {
            defaults: {event: "pinch", threshold: 0, pointers: 2}, getTouchAction: function () {
                return ["none"]
            }, attrTest: function (a) {
                return this._super.attrTest.call(this, a) && (Math.abs(a.scale - 1) > this.options.threshold ||
                    this.state & 2)
            }, emit: function (a) {
                this._super.emit.call(this, a);
                1 !== a.scale && this.manager.emit(this.options.event + (1 > a.scale ? "in" : "out"), a)
            }
        });
        m(ka, S, {
            defaults: {event: "press", pointers: 1, time: 500, threshold: 5}, getTouchAction: function () {
                return ["auto"]
            }, process: function (a) {
                var b = this.options, d = a.pointers.length === b.pointers, e = a.distance < b.threshold,
                    g = a.deltaTime > b.time;
                this._input = a;
                if (!e || !d || a.eventType & 12 && !g) this.reset(); else if (a.eventType & 1) this.reset(), this._timer = f(function () {
                        this.state = 8;
                        this.tryEmit()
                    },
                    b.time, this); else if (a.eventType & 4) return 8;
                return 32
            }, reset: function () {
                clearTimeout(this._timer)
            }, emit: function (a) {
                8 === this.state && (a && a.eventType & 4 ? this.manager.emit(this.options.event + "up", a) : (this._input.timeStamp = vb(), this.manager.emit(this.options.event, this._input)))
            }
        });
        m(na, M, {
            defaults: {event: "rotate", threshold: 0, pointers: 2}, getTouchAction: function () {
                return ["none"]
            }, attrTest: function (a) {
                return this._super.attrTest.call(this, a) && (Math.abs(a.rotation) > this.options.threshold || this.state & 2)
            }
        });
        m(T, M, {
            defaults: {event: "swipe", threshold: 10, velocity: .65, direction: 30, pointers: 1},
            getTouchAction: function () {
                return la.prototype.getTouchAction.call(this)
            },
            attrTest: function (a) {
                var b = this.options.direction, d;
                b & 30 ? d = a.velocity : b & 6 ? d = a.velocityX : b & 24 && (d = a.velocityY);
                return this._super.attrTest.call(this, a) && b & a.direction && a.distance > this.options.threshold && $a(d) > this.options.velocity && a.eventType & 4
            },
            emit: function (a) {
                var b = da(a.direction);
                b && this.manager.emit(this.options.event + b, a);
                this.manager.emit(this.options.event,
                    a)
            }
        });
        m(X, S, {
            defaults: {event: "tap", pointers: 1, taps: 1, interval: 300, time: 250, threshold: 2, posThreshold: 10},
            getTouchAction: function () {
                return ["manipulation"]
            },
            process: function (a) {
                var b = this.options, d = a.pointers.length === b.pointers, e = a.distance < b.threshold,
                    g = a.deltaTime < b.time;
                this.reset();
                if (a.eventType & 1 && 0 === this.count) return this.failTimeout();
                if (e && g && d) {
                    if (4 != a.eventType) return this.failTimeout();
                    d = this.pTime ? a.timeStamp - this.pTime < b.interval : !0;
                    e = !this.pCenter || D(this.pCenter, a.center) < b.posThreshold;
                    this.pTime = a.timeStamp;
                    this.pCenter = a.center;
                    this.count = e && d ? this.count + 1 : 1;
                    this._input = a;
                    if (0 === this.count % b.taps) return this.hasRequireFailures() ? (this._timer = f(function () {
                        this.state = 8;
                        this.tryEmit()
                    }, b.interval, this), 2) : 8
                }
                return 32
            },
            failTimeout: function () {
                this._timer = f(function () {
                    this.state = 32
                }, this.options.interval, this);
                return 32
            },
            reset: function () {
                clearTimeout(this._timer)
            },
            emit: function () {
                8 == this.state && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input))
            }
        });
        ra.VERSION =
            "2.0.4";
        ra.defaults = {
            domEvents: !1,
            touchAction: "compute",
            enable: !0,
            inputTarget: null,
            inputClass: null,
            preset: [[na, {enable: !1}], [ea, {enable: !1}, ["rotate"]], [T, {direction: 6}], [la, {direction: 6}, ["swipe"]], [X], [X, {
                event: "doubletap",
                taps: 2
            }, ["tap"]], [ka]],
            cssProps: {
                userSelect: "none",
                touchSelect: "none",
                touchCallout: "none",
                contentZooming: "none",
                userDrag: "none",
                tapHighlightColor: "rgba(0,0,0,0)"
            }
        };
        Fa.prototype = {
            set: function (a) {
                k(this.options, a);
                a.touchAction && this.touchAction.update();
                a.inputTarget && (this.input.destroy(),
                    this.input.target = a.inputTarget, this.input.init());
                return this
            }, stop: function (a) {
                this.session.stopped = a ? 2 : 1
            }, recognize: function (a) {
                var b = this.session;
                if (!b.stopped) {
                    this.touchAction.preventDefaults(a);
                    var d, e = this.recognizers, f = b.curRecognizer;
                    if (!f || f && f.state & 8) f = b.curRecognizer = null;
                    for (var g = 0; g < e.length;) d = e[g], 2 === b.stopped || f && d != f && !d.canRecognizeWith(f) ? d.reset() : d.recognize(a), !f && d.state & 14 && (f = b.curRecognizer = d), g++
                }
            }, get: function (a) {
                if (a instanceof S) return a;
                for (var b = this.recognizers,
                         d = 0; d < b.length; d++) if (b[d].options.event == a) return b[d];
                return null
            }, add: function (a) {
                if (h(a, "add", this)) return this;
                var b = this.get(a.options.event);
                b && this.remove(b);
                this.recognizers.push(a);
                a.manager = this;
                this.touchAction.update();
                return a
            }, remove: function (a) {
                if (h(a, "remove", this)) return this;
                var b = this.recognizers;
                a = this.get(a);
                b.splice(x(b, a), 1);
                this.touchAction.update();
                return this
            }, on: function (a, b) {
                var d = this.handlers;
                g(u(a), function (a) {
                    d[a] = d[a] || [];
                    d[a].push(b)
                });
                return this
            }, off: function (a,
                              b) {
                var d = this.handlers;
                g(u(a), function (a) {
                    b ? d[a].splice(x(d[a], b), 1) : delete d[a]
                });
                return this
            }, emit: function (a, b) {
                this.options.domEvents && Va(a, b);
                var d = this.handlers[a] && this.handlers[a].slice();
                if (d && d.length) {
                    b.type = a;
                    b.preventDefault = function () {
                        b.srcEvent.preventDefault()
                    };
                    for (var e = 0; e < d.length;) d[e](b), e++
                }
            }, destroy: function () {
                this.element && va(this, !1);
                this.handlers = {};
                this.session = {};
                this.input.destroy();
                this.element = null
            }
        };
        k(ra, {
            INPUT_START: 1,
            INPUT_MOVE: 2,
            INPUT_END: 4,
            INPUT_CANCEL: 8,
            STATE_POSSIBLE: 1,
            STATE_BEGAN: 2,
            STATE_CHANGED: 4,
            STATE_ENDED: 8,
            STATE_RECOGNIZED: 8,
            STATE_CANCELLED: 16,
            STATE_FAILED: 32,
            DIRECTION_NONE: 1,
            DIRECTION_LEFT: 2,
            DIRECTION_RIGHT: 4,
            DIRECTION_UP: 8,
            DIRECTION_DOWN: 16,
            DIRECTION_HORIZONTAL: 6,
            DIRECTION_VERTICAL: 24,
            DIRECTION_ALL: 30,
            Manager: Fa,
            Input: H,
            TouchAction: Z,
            TouchInput: L,
            MouseInput: C,
            PointerEventInput: K,
            TouchMouseInput: aa,
            SingleTouchInput: J,
            Recognizer: S,
            AttrRecognizer: M,
            Tap: X,
            Pan: la,
            Swipe: T,
            Pinch: ea,
            Rotate: na,
            Press: ka,
            on: p,
            off: r,
            each: g,
            merge: l,
            extend: k,
            inherit: m,
            bindFn: n,
            prefixed: F
        });
        "function" == typeof define && define.amd ? define("hammer", [], function () {
            return ra
        }) : "undefined" != typeof module && module.exports ? module.exports = ra : a[d] = ra
    })(window, document, "Hammer");
    define("text!com/visioglobe/web/resources/visioglobe.png.base64", [], function () {
        return "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"
    });
    define("text!com/visioglobe/web/resources/laser.png.base64", [], function () {
        return "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"
    });
    define("text!com/visioglobe/web/resources/water.jpg.base64", [], function () {
        return "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"
    });
    define("com/visioglobe/web/MapviewerPrivate", "require com/visioglobe/web/helpers/StringUtils com/visioglobe/web/helpers/MathUtils com/visioglobe/web/helpers/CachedTexture com/visioglobe/web/Camera com/visioglobe/web/helpers/ExtrudeGeometry com/visioglobe/web/Floor com/visioglobe/web/Path com/visioglobe/web/helpers/PathGeometry com/visioglobe/web/Place com/visioglobe/web/poi/POIFactory com/visioglobe/web/helpers/SvgUtils com/visioglobe/web/TrackballManipulator com/visioglobe/common/routing/AStarRoutingSolver com/visioglobe/common/navigation/NavigationSolver com/visioglobe/web/SVG3Loader com/visioglobe/web/helpers/SceneLoader com/visioglobe/common/AjaxProgress com/visioglobe/common/SlotHelper com/visioglobe/common/utils/MapChecker com/visioglobe/web/helpers/TextureAtlas com/visioglobe/web/helpers/TextGenerator com/visioglobe/common/Notifications text!com/visioglobe/web/shaders/depth.frag text!com/visioglobe/web/shaders/depth.vert text!com/visioglobe/web/shaders/water.frag text!com/visioglobe/web/shaders/water.vert text!com/visioglobe/web/shaders/sky.frag text!com/visioglobe/web/shaders/sky.vert underscoretiny hammer text!com/visioglobe/web/resources/visioglobe.png.base64 text!com/visioglobe/web/resources/laser.png.base64 text!com/visioglobe/web/resources/water.jpg.base64".split(" "),
        function (a) {
            var b = jQuery.deparam && jQuery.deparam.querystring() || {},
                d = a("com/visioglobe/web/helpers/StringUtils"), e = a("com/visioglobe/web/helpers/MathUtils"),
                f = a("com/visioglobe/web/helpers/CachedTexture"), h = a("com/visioglobe/web/Camera"),
                g = a("com/visioglobe/web/helpers/ExtrudeGeometry"), k = a("com/visioglobe/web/Floor"),
                l = a("com/visioglobe/web/Path"), m = a("com/visioglobe/web/helpers/PathGeometry"),
                n = a("com/visioglobe/web/Place"), q = a("com/visioglobe/web/poi/POIFactory"),
                p = a("com/visioglobe/web/helpers/SvgUtils"),
                r = a("com/visioglobe/web/TrackballManipulator"),
                v = a("com/visioglobe/common/routing/AStarRoutingSolver"),
                u = a("com/visioglobe/common/navigation/NavigationSolver");
            a("com/visioglobe/web/SVG3Loader");
            a("com/visioglobe/web/helpers/SceneLoader");
            a("com/visioglobe/common/AjaxProgress");
            var x = a("com/visioglobe/common/SlotHelper"), w = a("com/visioglobe/common/utils/MapChecker");
            a("com/visioglobe/web/helpers/TextureAtlas");
            var z = a("com/visioglobe/web/helpers/TextGenerator"), F = a("com/visioglobe/common/Notifications");
            a("text!com/visioglobe/web/shaders/depth.frag");
            a("text!com/visioglobe/web/shaders/depth.vert");
            a("text!com/visioglobe/web/shaders/water.frag");
            a("text!com/visioglobe/web/shaders/water.vert");
            a("text!com/visioglobe/web/shaders/sky.frag");
            a("text!com/visioglobe/web/shaders/sky.vert");
            var B = a("underscoretiny"), H = a("hammer"), E = window.console;
            a = function () {
            };
            E || (E = {}, E.log = a, E.warn = a, E.error = a, E.time = a, E.timeEnd = a);
            E.time = E.time || a;
            E.timeEnd = E.timeEnd || a;
            var I = function () {
                var a, N, G;

                function D() {
                    var a = document.createElement("img");
                    a.src = "data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
                    THREE.Texture.DEFAULT_IMAGE = a
                }

                function Y() {
                    function a(b) {
                        var d = Ma[0].getBoundingClientRect();
                        return {left: b.center.x - d.left, top: b.center.y - d.top}
                    }

                    function b(a, d) {
                        var e = Date.now();
                        if (!(200 > e - Ob || 200 < e - tc) && (Ob = e, !1 === y.customPreManipulatorListener || !1 !== y.customPreManipulatorListener(d))) {
                            switch (y.manipulatorTypeName) {
                                case "map":
                                case "trackball":
                                    e = $a(a), !1 !== e && 0 < e.length && Oa(d, e[0].target, e[0].vg.poi)
                            }
                            !1 !== y.customPostManipulatorListener &&
                            y.customPostManipulatorListener(d)
                        }
                    }

                    var d, e, f = !1, g, h, k = 0, l = 1;
                    y.onTapWithCenter = b;
                    var m = new H.Manager(Aa.domElement);
                    m.add(new H.Pan({threshold: 0, pointers: 0}));
                    m.add(new H.Rotate({threshold: 0})).recognizeWith(m.get("pan"));
                    m.add(new H.Pinch({threshold: 0})).recognizeWith([m.get("pan"), m.get("rotate")]);
                    m.add(new H.Tap({event: "doubletap", taps: 2}));
                    m.add(new H.Tap);
                    m.on("panstart panmove", function (b) {
                        if (y.manipulator.panManipulatorEnabled && (!1 === y.customPreManipulatorListener || !1 !== y.customPreManipulatorListener(b))) {
                            switch (y.manipulatorTypeName) {
                                case "map":
                                    if ("panstart" ==
                                        b.type) {
                                        var k = a(b);
                                        d = y.convertScreenToPoint(k)
                                    } else {
                                        var k = a(b), k = y.convertScreenToPoint(k), l = y.publicCamera.position;
                                        y.publicCamera.position = {
                                            x: d.x - k.x + l.x,
                                            y: d.y - k.y + l.y,
                                            radius: l.radius
                                        }
                                    }
                                    break;
                                case "trackball":
                                    if ("panstart" == b.type) e = b.center, g = y.publicCamera.pitch, h = y.publicCamera.rotation, k = a(b), f = k.top < .5 * Ma.height(); else {
                                        var k = b.center.x - e.x, l = b.center.y - e.y, m = !1;
                                        y.manipulator.pitchManipulatorEnabled && (0 == f && (l = -l), y.publicCamera.pitch = g + y.manipulator.rotationSpeed * l, m = !0);
                                        y.manipulator.rotationManipulatorEnabled &&
                                        (0 == f && (k = -k), y.publicCamera.rotation = h + y.manipulator.rotationSpeed * k, m = !0);
                                        m && y.manipulator.update()
                                    }
                            }
                            !1 !== y.customPostManipulatorListener && y.customPostManipulatorListener(b)
                        }
                    });
                    m.on("rotatestart rotatemove", function (b) {
                        if (!1 !== y.manipulator.rotationManipulatorEnabled && (!1 === y.customPreManipulatorListener || !1 !== y.customPreManipulatorListener(b))) {
                            switch (y.manipulatorTypeName) {
                                case "map":
                                    if ("rotatestart" == b.type) k = y.publicCamera.rotation; else {
                                        var d = a(b), e = y.convertScreenToPoint(d), f = d.top, d = d.left,
                                            g = y.viewportWidth - d - 1, h = y.viewportHeight - f - 1;
                                        y.publicCamera.rotation = k + b.rotation;
                                        y.manipulator.panManipulatorEnabled && (e = y.getViewpointFromPositions({
                                            points: [e],
                                            top: f,
                                            bottom: h,
                                            left: d,
                                            right: g
                                        }), y.publicCamera.position = e)
                                    }
                            }
                            !1 !== y.customPostManipulatorListener && y.customPostManipulatorListener(b)
                        }
                    });
                    m.on("pinchstart pinchmove", function (b) {
                        if (!1 !== y.manipulator.zoomManipulatorEnabled && (!1 === y.customPreManipulatorListener || !1 !== y.customPreManipulatorListener(b))) {
                            switch (y.manipulatorTypeName) {
                                case "map":
                                    if ("pinchstart" ==
                                        b.type) y.publicCamera.position.radius, l = y.publicCamera.position.radius || 1; else {
                                        var d = y.publicCamera.position;
                                        d.radius = l / b.scale;
                                        var e = a(b), f = y.convertScreenToPoint(e), g = e.top, e = e.left,
                                            h = y.viewportWidth - e - 1, k = y.viewportHeight - g - 1;
                                        y.publicCamera.position = d;
                                        d = y.getViewpointFromPositions({
                                            points: [f],
                                            top: g,
                                            bottom: k,
                                            left: e,
                                            right: h
                                        });
                                        y.publicCamera.position = d
                                    }
                                    break;
                                case "trackball":
                                    "pinchstart" == b.type ? (y.publicCamera.position.radius, l = y.publicCamera.position.radius || 1) : (d = y.publicCamera.position, d.radius =
                                        l / b.scale, y.publicCamera.position = d)
                            }
                            !1 !== y.customPostManipulatorListener && y.customPostManipulatorListener(b)
                        }
                    });
                    m.on("tap", function (d) {
                        oa = !1;
                        var e = a(d);
                        return b({x: e.left, y: e.top}, d)
                    });
                    m.on("doubletap", function (a) {
                    });
                    V.addEventListener("mousedown", Fa, !1);
                    V.addEventListener("mousemove", vb, !1);
                    V.addEventListener("mouseup", Va, !1);
                    document.addEventListener("mouseup", va, !1);
                    V.addEventListener("mouseout", nb, !1);
                    V.addEventListener("contextmenu", lb, !1);
                    Ma.bind("mousewheel", Q);
                    m = y.getExtraData().background;
                    if ("undefined" !== typeof m) switch (m.type) {
                        case "image":
                            Ma.css("background-image", "url(" + ta + m.file + ")");
                            Ma.css("background-size", "cover");
                            break;
                        case "gradient":
                            Ma.css("background", "linear-gradient(" + m.start + "," + m.stop + ")");
                            break;
                        case "color":
                            Ma.css("background-color", m.color)
                    }
                    y.resizeInternal(Ma.width(), Ma.height(), !1)
                }

                function C(a) {
                    0 === a.indexOf("Surface") && (a = a.substr(7));
                    return a
                }

                function K(a) {
                    var b = {};
                    if (0 !== a.indexOf("Vg")) return b;
                    a = a.substr(2);
                    var d = a.indexOf("Floor"), e = a.indexOf("Lod"), f = -1;
                    jQuery.each("Surface Routing Image Legend Label Background".split(" "), function (b, d) {
                        f = a.indexOf(d);
                        if (-1 !== f) return !1
                    });
                    b.type = a.substr(f);
                    -1 !== e ? b.lod = parseInt(a.substr(e + 3, f - (e + 3)), 10) : e = f;
                    -1 !== d && (b.floor = a.substr(d + 5, e - (d + 5)));
                    return b
                }

                function J(a) {
                    var b = new k(y, a);
                    b.index = Ha.length;
                    Ha.push(b);
                    return t[a] = b
                }

                function L(a, b, d) {
                    var e;
                    a:{
                        var f = new THREE.Shape;
                        e = f;
                        f.matrixAutoUpdate = !1;
                        var h = jQuery(a), k = h.attr("d");
                        if ("undefined" !== typeof k) {
                            var l = new p.Transform;
                            h.attr("transform") && (l = h.attr("transform"),
                                l = p.Transform.parse(l));
                            var h = null, m, k = p.Parser.path(k);
                            k.reset();
                            for (var n, q, r, t = !1; !k.isEnd();) switch (k.nextCommand(), t && (e = new THREE.Shape, f.holes.push(e), t = !1), k.command.toUpperCase()) {
                                case "Z":
                                    p.equalsPoints(m, h, .01) && (e.actions.splice(-1, 1), e.curves.splice(-1, 1));
                                    t = !0;
                                    break;
                                case "M":
                                    n = k.getAsCurrentPoint().clone();
                                    l.multiplyVector(n);
                                    n = ja(n);
                                    e.moveTo(n.x, n.y);
                                    for (h = m = n; !k.isCommandOrEnd();) n = k.getAsCurrentPoint().clone(), l.multiplyVector(n), n = ja(n), p.equalsPoints(n, h, .01) || e.lineTo(n.x, n.y),
                                        h = n;
                                    break;
                                case "L":
                                    for (; !k.isCommandOrEnd();) n = k.getAsCurrentPoint().clone(), l.multiplyVector(n), n = ja(n), p.equalsPoints(n, h, .01) || e.lineTo(n.x, n.y), h = n;
                                    break;
                                case "C":
                                    for (; !k.isCommandOrEnd();) n = k.getAsControlPoint().clone(), q = k.getAsControlPoint().clone(), r = k.getAsCurrentPoint().clone(), l.multiplyVector(n), n = ja(n), l.multiplyVector(q), q = ja(q), l.multiplyVector(r), r = ja(r), e.bezierCurveTo(n.x, n.y, q.x, q.y, r.x, r.y);
                                    break;
                                case "S":
                                    for (; !k.isCommandOrEnd();) q = k.getAsControlPoint().clone(), r = k.getAsCurrentPoint().clone(),
                                        n = k.getReflectedControlPoint(), l.multiplyVector(n), n = ja(n), l.multiplyVector(q), q = ja(q), l.multiplyVector(r), r = ja(r), e.bezierCurveTo(n.x, n.y, q.x, q.y, r.x, r.y);
                                    break;
                                case "H":
                                    for (; !k.isCommandOrEnd();) q = k.getScalar(), n = k.current.clone(), n.x = "h" === k.command ? n.x + q : q, k.current.x = n.x, l.multiplyVector(n), n = ja(n), e.lineTo(n.x, n.y);
                                    break;
                                case "V":
                                    for (; !k.isCommandOrEnd();) q = k.getScalar(), n = k.current.clone(), n.y = "v" === k.command ? n.y + q : q, k.current.y = n.y, l.multiplyVector(n), n = ja(n), e.lineTo(n.x, n.y);
                                    break;
                                default:
                                    e =
                                        null;
                                    break a
                            }
                            e = f
                        } else e = void 0
                    }
                    if (null === e || 1 >= e.curves.length) E.log("Cannot convert to shape."); else {
                        m = y.getFloor(d.floor);
                        f = m.getLOD(d.lod);
                        null === f && (f = m.floorContentLOD);
                        m = jQuery(a);
                        a = U(m.attr("vg_id"), "VgID");
                        m = m.attr("fill");
                        void 0 === m && (m = b.color);
                        m = p.Parser.color(m);
                        var h = new THREE.MeshBasicMaterial({
                            color: 16777215,
                            specular: 13421772,
                            vertexColors: THREE.VertexColors,
                            transparent: !1
                        }), l = {
                            amount: b.thickness,
                            steps: 1,
                            bevelEnabled: !1,
                            generateSides: !1,
                            generateTop: !0,
                            generateBottom: !1
                        }, u;
                        try {
                            u = new g(e,
                                l);
                            for (var v = new THREE.Color(m), x = u.faces, l = 0, w = x.length; l < w; ++l) x[l].color = v
                        } catch (z) {
                            E.log("ExtrudeGeometry failed", z);
                            return
                        }
                        b.is_reflection && (Qb.uniforms.uColor.value = new THREE.Color(m), h = Qb);
                        w = new THREE.Matrix4;
                        w.makeTranslation(0, 0, b.offset);
                        u.applyMatrix(w);
                        u = new THREE.Mesh(u, h);
                        u.matrixAutoUpdate = !1;
                        u.geometry.computeBoundingBox();
                        w = f.node;
                        b.is_reflection && (w = f.node);
                        v = 0;
                        ua && 0 !== w.children.length ? (v = w.children[0].geometry.faces.length, w.children[0].geometry.merge(u.geometry)) : w.add(u);
                        "undefined" !==
                        typeof a && (u.vg = {
                            id: a,
                            floor: d.floor,
                            originalColor: m,
                            nb_faces: u.geometry.faces.length,
                            faces_offset: v,
                            layer: w
                        }, f.pickables.push(u), "undefined" === typeof y.places_list[a] && (y.places_list[a] = []), y.places_list[a].push(u), w = new THREE.Vector3, w.addVectors(u.geometry.boundingBox.max, u.geometry.boundingBox.min), w.multiplyScalar(.5), w.multiply(u.scale), w.add(u.position), u.vg.position = w);
                        if (0 < b.thickness && b.wall_geometry && y.layersParameters.wall.enabled) {
                            w = 9671571;
                            w = m;
                            d = new THREE.MeshBasicMaterial({
                                color: 16777215,
                                specular: 13421772, emissive: 5592405, vertexColors: THREE.VertexColors, transparent: !1
                            });
                            l = {
                                amount: b.thickness,
                                steps: 1,
                                bevelEnabled: !1,
                                generateSides: !0,
                                generateTop: !1,
                                generateBottom: !1
                            };
                            u = new g(e, l);
                            u.computeVertexNormals();
                            v = new THREE.Color(w);
                            x = new THREE.Color(w);
                            b.wall_color_gradient && (w = parseFloat(b.wall_color_gradient_top_ratio), isNaN(w) || v.multiplyScalar(w), w = parseFloat(b.wall_color_gradient_bottom_ratio), isNaN(w) || x.multiplyScalar(w));
                            a = ["a", "b", "c"];
                            l = 0;
                            for (w = u.faces.length; l < w; ++l) {
                                e = u.faces[l];
                                for (var B in a) e.vertexColors[B] = 0 < u.vertices[e[a[B]]].z ? v : x
                            }
                            w = new THREE.Matrix4;
                            w.makeTranslation(0, 0, b.offset);
                            u.applyMatrix(w);
                            b = new THREE.Mesh(u, d);
                            b.matrixAutoUpdate = !1;
                            B = f.getOrCreateLayer(y.layersParameters.wall.order);
                            0 === B.children.length ? B.add(b) : B.children[0].geometry.merge(b.geometry)
                        }
                    }
                }

                function U(a, b) {
                    if (!a) return a;
                    var d = a.replace(b, "").split(/(_x[0-9A-Fa-f]*_)/), e;
                    for (e in d) if (-1 !== d[e].indexOf("_x")) {
                        var f = parseInt(d[e].substr(2), 16);
                        d[e] = String.fromCharCode(f)
                    }
                    return d.join("")
                }

                function aa(a) {
                    null !== a && (a.geoinformation ? (W = a.geoinformation, W.rotation_angle_in_degrees = parseFloat(W.rotation_angle_in_degrees), W.meters_per_pixel = parseFloat(W.meters_per_pixel), W.geo_xref = parseFloat(W.geo_xref), W.geo_yref = parseFloat(W.geo_yref), W.pixel_xref = parseFloat(W.pixel_xref), y.cameraNorthRotation = -W.rotation_angle_in_degrees) : y.cameraNorthRotation = !1, jQuery.each(a.features, function (a, b) {
                        y.layersParameters[d.ucfirst(a)] = {
                            thickness: parseFloat(b.extrusion_height),
                            side_color: b.side_color
                        }
                    }),
                    a.proj4string && a.offsetX && a.offsetY && !1 === y.initializeProjection(a) && E.log("Cannot initialize projection"))
                }

                function Z() {
                    var a = W.rotation_angle_in_degrees * e.DEG2RAD;
                    W.matrixUTMToSVG = new THREE.Matrix4;
                    W.matrixUTMToSVG.elements[0] = Math.cos(-a) / W.meters_per_pixel;
                    W.matrixUTMToSVG.elements[1] = -Math.sin(-a) / W.meters_per_pixel;
                    W.matrixUTMToSVG.elements[2] = -Math.sin(-a) / W.meters_per_pixel;
                    W.matrixUTMToSVG.elements[3] = -Math.cos(-a) / W.meters_per_pixel;
                    W.matrixUTMToSVG.elements[4] = ga;
                    W.matrixUTMToSVG.elements[5] =
                        ga;
                    W.matrixSVGToUTM = new THREE.Matrix4;
                    W.matrixSVGToUTM.elements[0] = Math.cos(a) * W.meters_per_pixel;
                    W.matrixSVGToUTM.elements[1] = -Math.sin(a) * W.meters_per_pixel;
                    W.matrixSVGToUTM.elements[2] = Math.sin(a) * W.meters_per_pixel;
                    W.matrixSVGToUTM.elements[3] = Math.cos(a) * W.meters_per_pixel;
                    W.matrixSVGToUTM.elements[4] = -ga;
                    W.matrixSVGToUTM.elements[5] = ga
                }

                function P(a) {
                    var b = jQuery.deparam && jQuery.deparam.fragment() || {};
                    y.manipulator.maxRadius = .5 * a / Math.tan(.5 * Math.min(Ja.fovY, Ja.fovX) * e.DEG2RAD);
                    y.manipulator.wholeRadius =
                        y.manipulator.maxRadius;
                    void 0 === b.radius && (y.manipulator.radius = y.manipulator.maxRadius);
                    y.layersParameters.global.fog.far = 3 * a;
                    y.sideInMeters = a;
                    y.camera.far = y.layersParameters.global.fog.far;
                    y.manipulator.minTarget = {x: .5 * -a, y: .5 * -a};
                    y.manipulator.maxTarget = {x: .5 * a, y: .5 * a};
                    y.manipulator.update()
                }

                function S(a, b, d) {
                    var e;
                    e = E.log;
                    E.log = function () {
                    };
                    "Fence" !== d.type && L(a, b, d);
                    E.log = e
                }

                function da(a, b, d) {
                    var e = jQuery(a);
                    b = e.attr("transform");
                    var f = p.Transform.parse(b), g = y.layersParameters.sprite, h = null ===
                        a.getAttribute("x") ? 0 : parseFloat(a.getAttribute("x")),
                        k = null === a.getAttribute("y") ? 0 : parseFloat(a.getAttribute("y"));
                    b = parseFloat(a.getAttribute("width"));
                    var l = parseFloat(a.getAttribute("height")), m = new p.Point(h, k);
                    f.multiplyVector(m);
                    h = new p.Point(h + b, k + l);
                    f.multiplyVector(h);
                    f = f.decompose();
                    b *= Math.abs(f.sx);
                    l *= Math.abs(f.sy);
                    g = {x: (m.x + h.x) / 2, y: (m.y + h.y) / 2, z: g.offset};
                    g = ja(g);
                    e = U(e.attr("vg_id"), "VgID");
                    m = a.getAttribute("xlink:href");
                    h = "fixed" === a.getAttribute("vg_orientationType");
                    a = null === a.getAttribute("vg_face2d") ?
                        !0 : "true" === a.getAttribute("vg_face2d");
                    y.addPOI({
                        url: ta + m,
                        id: e,
                        position: g,
                        scale: {x: b * W.meters_per_pixel, y: l * W.meters_per_pixel, z: 1},
                        floor: d.floor,
                        lod: d.lod,
                        fixed: h,
                        angle: f.angle,
                        face2d: a,
                        image: !0,
                        clickable: e && null === e.match(/^mapIcon/) ? !0 : !1
                    })
                }

                function ca(a, b, d) {
                    b = jQuery(a);
                    a = b.find("rect");
                    var e = b.find("text"), f = b.attr("transform"), g = p.Transform.parse(f),
                        h = y.layersParameters.sprite,
                        k = null === a[0].getAttribute("x") ? 0 : parseFloat(a[0].getAttribute("x")),
                        l = null === a[0].getAttribute("y") ? 0 : parseFloat(a[0].getAttribute("y")),
                        m = parseFloat(a[0].getAttribute("width")), n = parseFloat(a[0].getAttribute("height")),
                        q = new p.Point(k, l);
                    g.multiplyVector(q);
                    k = new p.Point(k + m, l + n);
                    g.multiplyVector(k);
                    g = g.decompose();
                    m *= Math.abs(g.sx);
                    n *= Math.abs(g.sy);
                    h = {x: (q.x + k.x) / 2, y: (q.y + k.y) / 2, z: h.offset};
                    h = ja(h);
                    y.layersParameters.debugLabel.enabled && (p.convertRectToPath(a), a.attr("fill", "#ff0000"), a.attr("transform", f), S(a, y.layersParameters.debugLabel, d));
                    f = U(b.attr("vg_id"), "VgLabel");
                    Math.min(Math.abs(m), Math.abs(n));
                    q = 0 !== e.length ? p.Parser.color(e.attr("fill")) :
                        p.Parser.color(a.attr("stroke"));
                    a = "";
                    e.length && "true" === b.attr("vg_legend") ? a = U(e.text()) : 0 === e.length && b.attr("vg_legend") && (a = b.attr("vg_legend"));
                    y.addPOI({
                        id: f,
                        text: a,
                        color: q,
                        position: h,
                        scale: {x: 1, y: 1, z: 1},
                        floor: d.floor,
                        lod: d.lod,
                        fixed: !0,
                        angle: g.angle,
                        width: m * W.meters_per_pixel,
                        height: n * W.meters_per_pixel,
                        flip: !0,
                        clickable: !1
                    })
                }

                function M(a) {
                    var b = y.getFloor(Db);
                    b ? (y.currentFloorName = Db, y.currentFloor = b) : (y.currentFloorName = Ha[0].name, y.currentFloor = Ha[0]);
                    for (var d = 0, e = Ha.length; d < e; ++d) {
                        b =
                            Ha[d];
                        b.setEnabled(b.name === y.currentFloorName);
                        b.name === y.currentFloorName && (y.current_lod = b.lods[b.lods.length - 1].index);
                        for (var f = 0, g = b.lods.length; f < g; ++f) {
                            var h = b.lods[f];
                            "undefined" !== typeof h && (h.setEnabled(b.name === y.currentFloorName && h.index === y.current_lod), h.node.traverse(function (a) {
                            }))
                        }
                    }
                    for (var k in y.places_list) new n(y, y.places_list[k], k, W.meters_per_pixel);
                    d = new THREE.Vector3(0, 0, -1);
                    e = new THREE.Vector3;
                    f = new THREE.Raycaster(e, d);
                    if (ub) for (k in y.pois) {
                        var g = y.pois[k], l;
                        for (l in g) {
                            var m =
                                g[l], h = m.options("lod");
                            if ("undefined" !== typeof h) {
                                var p = m.options("position"), b = m.options("floor"), b = y.getFloor(b);
                                e.copy({x: p.x, y: p.y, z: 1E3});
                                f.set(e, d);
                                var q = b.floorContentLOD.pickables, h = b.getLOD(h), q = q.concat(h.node),
                                    b = f.intersectObjects(q, !0);
                                0 !== b.length && (b = b[0].point.z, b !== p.z && (p.z = b, m.options("position", p, !0)))
                            }
                        }
                    }
                    a.notify(1, "done");
                    a.resolve();
                    y.mustUpdateCameraObjects = !0;
                    y.requestRedraw()
                }

                function la(a, b) {
                    function d(a, b) {
                        var e = jQuery(b), f = e.find("title").text(), g = K(f);
                        if (!(-1 !== r.indexOf(g.type) ||
                                0 !== Ya.length && -1 === Ya.indexOf(g.floor) || 0 !== Cb.length && -1 === Cb.indexOf(g.lod))) {
                            g.type = C(g.type);
                            var h = q[g.type];
                            this.getFloor(g.floor).getLOD(g.lod);
                            e.find(">rect").each(function (a, b) {
                                p.convertRectToPath(b);
                                S(b, h, g)
                            });
                            e.find(">circle").each(function (a, b) {
                                p.convertCircleToPath(b);
                                S(b, h, g)
                            });
                            e.find(">path").each(function (a, b) {
                                S(b, h, g)
                            });
                            e.find(">image").each(function (a, b) {
                                da(b, h, g)
                            });
                            e.find(">g[vg_id^=VgLabel]").each(function (a, b) {
                                ca(b, h, g)
                            })
                        }
                    }

                    cb = !1;
                    y.useDepthWriteForPOIs = !1;
                    Ua = parseInt(b.find("svg").attr("height"),
                        10);
                    ga = Ua / 2;
                    var e = b.find("svg>g"), f = e.length, g = b.find("metadata").text(),
                        h = "" != g ? jQuery.parseJSON(g) : null;
                    null === h && jQuery.ajax(ta + "layer_parameters.json", {
                        async: !1,
                        dataType: "json",
                        success: function (a) {
                            h = a
                        }
                    });
                    aa(h);
                    Z();
                    P(Ua * W.meters_per_pixel);
                    var k = 0, l = Math.ceil(f / 100), m = 0, n = [], q = {},
                        r = ["AccessPoint", "Routing", "Background"];
                    e.each(function (a, b) {
                        var d = jQuery(b).find("title").text(), d = K(d);
                        if (d.floor) {
                            var e = y.getFloor(d.floor);
                            null === e && (e = J(d.floor), y.scene.add(e.node));
                            "undefined" !== typeof d.lod &&
                            null === e.getLOD(d.lod) && e.createLOD(d.lod);
                            d.type && -1 === n.indexOf(d.type) && n.push(d.type)
                        }
                    });
                    n.sort(function (a, b) {
                        a = C(a);
                        b = C(b);
                        a = y.layersParameters[a] ? y.layersParameters[a].thickness : 0;
                        b = y.layersParameters[b] ? y.layersParameters[b].thickness : 0;
                        return a - b
                    });
                    jQuery.each(n, function (a, b) {
                        var d = {lod: 0, thickness: 0, offset: 0, order: n.indexOf(b)};
                        b = C(b);
                        "undefined" !== typeof y.layersParameters[b] && jQuery.extend(d, y.layersParameters[b]);
                        d.order = 0;
                        q[b] = d
                    });
                    var t = function () {
                        for (; ;) {
                            var b = k;
                            d.apply(y, [b, e[b]]);
                            k++;
                            m++;
                            if (k === f) {
                                a.notify(1);
                                M(a);
                                break
                            }
                            if (m === l) {
                                m = 0;
                                a.notify(k / f);
                                setTimeout(t.bind(y), 0);
                                break
                            }
                        }
                    };
                    setTimeout(t.bind(y), 0)
                }

                function ea(a, b) {
                    ub = !1;
                    var d = {};
                    if (w.check(b, "String.length*Math.cos(window.length)", d)) {
                        var e = b, f = new THREE.ObjectLoader, d = b.scene;
                        d instanceof THREE.Scene || (d = f.parse(d), a.notify(.6, "sceneLoader parse finished"));
                        "undefined" !== typeof e.extra_data && (y.extraData = e.extra_data);
                        var g = {};
                        if ("undefined" !== typeof e.routing) for (f = 0; f < e.routing.floors.length; ++f) {
                            var h = e.routing.floors[f];
                            g[h.name] = h
                        }
                        new THREE.Box3;
                        for (f = 0; f < d.children.length; ++f) {
                            var k = d.children[f].userData.name, h = J(k);
                            "undefined" !== typeof g[k] && (h.heightMin = g[k].zmin, h.heightMax = g[k].zmax);
                            k = d.children[f].children.slice();
                            k[0].traverse(function (a) {
                                a.matrixAutoUpdate = !1;
                                "undefined" !== typeof a.userData.water && !0 === a.userData.water && h.floorContentLOD.groundObjects.push(a)
                            });
                            h.floorContentLOD.node.add(k[0]);
                            for (var l = 1, m = k.length; l < m; ++l) {
                                var n = k[l], p = h.createLOD(n.userData.index);
                                n.traverse(function (a) {
                                    a.matrixAutoUpdate =
                                        !1;
                                    "undefined" !== typeof a.userData.water && !0 === a.userData.water && p.groundObjects.push(a)
                                });
                                p.node.add(n);
                                if ("undefined" !== typeof n.userData.pickables) {
                                    p.pickables = n.userData.pickables;
                                    for (var q = 0, r = p.pickables.length; q < r; ++q) {
                                        var t = p.pickables[q];
                                        "undefined" === typeof y.places_list[t.id] && (y.places_list[t.id] = []);
                                        var x = {};
                                        x.vg = t;
                                        x.geometry = n.children[0].geometry;
                                        y.places_list[t.id].push(x)
                                    }
                                }
                            }
                        }
                        f = 0;
                        for (g = Ha.length; f < g; ++f) h = Ha[f], y.scene.add(h.node);
                        Ua = d.userData.svgHeight;
                        ga = Ua / 2;
                        aa({
                            features: [],
                            geoinformation: d.userData.geoinformation,
                            proj4string: d.userData.proj4string,
                            offsetX: d.userData.offsetX,
                            offsetY: d.userData.offsetY
                        });
                        Z();
                        "undefined" !== typeof e.routing && (d = {
                            convertSVGToPoint: ja,
                            convertPointToSVG: bb,
                            convertPointToLatLon: y.convertPointToLatLon.bind(y),
                            convertLatLonToPoint: y.convertLatLonToPoint.bind(y),
                            meters_per_pixel: W.meters_per_pixel,
                            rotation_angle_in_degrees: W.rotation_angle_in_degrees
                        }, y.routingSolver = new v({routing: e.routing}, d), y.navigationSolver = new u(y.routingSolver, d.meters_per_pixel, y.routingSolver.hasIntersections()),
                            y.setRoutingURL("#javascript"));
                        P(Ua * W.meters_per_pixel);
                        a.notify(.75, "setup except POIs finished");
                        if ("undefined" !== typeof e.pois) {
                            var d = e.pois, z = d.pois, B = d.images, D = d.labels, A = d.models;
                            y.loaderStatistics.pois += B.length;
                            y.loaderStatistics.pois += A.length;
                            y.loaderStatistics.pois += D.length;
                            y.deferredPoiLoading.active = !0;
                            (function () {
                                for (var a = y.deferredPoiLoading, b = a.setPlaceName, a = a.setPlaceIcon, d = y.pois_floor_table, f = 0, g = z.length; f < g; ++f) {
                                    var h = z[f];
                                    d[h.poiID] = h
                                }
                                if ("undefined" !== typeof e.pois.polygons) for (h =
                                                                                     e.pois.polygons, f = 0, g = h.length; f < g; ++f) {
                                    var k = h[f];
                                    "undefined" === typeof y.polygons_table[k.poiID] && (y.polygons_table[k.poiID] = []);
                                    y.polygons_table[k.poiID].push(k)
                                }
                                if ("undefined" !== typeof e.pois.points) for (k = e.pois.points, f = 0, g = k.length; f < g; ++f) h = k[f], y.points_table[h.poiID] = h;
                                f = 0;
                                for (g = B.length; f < g; ++f) k = B[f], h = {
                                    x: k.centerX,
                                    y: k.centerY,
                                    z: k.altitude
                                }, "facing" === k.type && (h.z += .5 * k.width), h = ja(h), y.addPOI({
                                    url: ta + "icons/" + k.imageName + ".png",
                                    id: k.poiID,
                                    position: h,
                                    scale: {x: k.width, y: k.height, z: 1},
                                    floor: d[k.poiID].floorName,
                                    lod: k.lod,
                                    fixed: "fixed" === k.type,
                                    angle: k.angleInDegrees,
                                    face2d: "facing" !== k.type,
                                    image: !0,
                                    clickable: k.poiID && null === k.poiID.match(/^mapIcon/) ? !0 : !1
                                }), y.loaderStatistics.pois--;
                                f = 0;
                                for (g = A.length; f < g; ++f) k = A[f], h = {
                                    x: k.centerX,
                                    y: k.centerY,
                                    z: k.altitude
                                }, h = ja(h), y.addPOI({
                                    model: ta + "models/" + k.modelName + ".json",
                                    id: k.poiID,
                                    position: h,
                                    scale: {x: k.width, y: k.height, z: 1},
                                    floor: d[k.poiID].floorName,
                                    lod: k.lod,
                                    fixed: "fixed" === k.type,
                                    angle: k.angleInDegrees,
                                    face2d: "facing" !== k.type,
                                    clickable: k.poiID && null === k.poiID.match(/^mapModel/) ?
                                        !0 : !1
                                }), y.loaderStatistics.pois--;
                                f = 0;
                                for (g = D.length; f < g; ++f) {
                                    var k = D[f], l = k.poiID, m = d[l],
                                        h = {x: k.centerX, y: k.centerY, z: k.altitude}, h = ja(h);
                                    y.addPOI({
                                        id: l,
                                        text: b[l] || m.name,
                                        url: a[l],
                                        color: k.fontColor,
                                        position: h,
                                        scale: {x: 1, y: 1, z: 1},
                                        floor: m.floorName,
                                        lod: k.lod,
                                        fixed: !0,
                                        angle: k.angleInDegrees,
                                        width: k.width,
                                        height: k.height,
                                        flip: !0,
                                        clickable: k.poiID && null === k.poiID.match(/^mapLabel/) ? !0 : !1
                                    });
                                    y.loaderStatistics.pois--
                                }
                                y.deferredPoiLoading.active = !1;
                                y.deferredPoiLoading.setPlaceIcon = {};
                                y.deferredPoiLoading.setPlaceName =
                                    {}
                            })()
                        }
                        b = e = null;
                        M(a)
                    } else a.reject({message: d.message})
                }

                function ka(a, b) {
                    var d;
                    a.notify(0);
                    try {
                        d = JSON.parse(b)
                    } catch (e) {
                        a.reject({message: "error parsing json map data", exception: e});
                        return
                    }
                    ea(a, d)
                }

                function na(a) {
                    var b = {}, d;
                    for (d in a.parameters) {
                        var e = a.parameters[d];
                        "object" !== typeof e && (b[d] = e)
                    }
                    a = a.parameters.styles;
                    for (d in a) {
                        var e = a[d], f;
                        for (f in b) "undefined" === typeof e[f] && (e[f] = b[f])
                    }
                }

                function T(a, b) {
                    cb = !1;
                    y.useDepthWriteForPOIs = !1;
                    Ua = parseInt(b.find("svg").attr("height"), 10);
                    ga = Ua / 2;
                    var d =
                        b.find("svg").attr("onabort"), d = JSON.parse(d);
                    if (1 < d.version) a.reject({message: "map data version " + d.version + ", this SDK supports 1. Please update SDK"}); else {
                        na(d);
                        y.extraData = {};
                        d.parameters.background && (y.extraData.background = d.parameters.background);
                        var e = {
                            features: d.parameters.styles,
                            geoinformation: d.geo,
                            proj4string: d.proj4string,
                            offsetX: d.offsetX,
                            offsetY: d.offsetY
                        };
                        "undefined" !== typeof d.builder_parameters && "undefined" !== typeof d.builder_parameters.distance_coeff && (e.geoinformation.distance_coef =
                            d.builder_parameters.distance_coeff);
                        aa(e);
                        Z();
                        "undefined" !== typeof d.routing && (e = {
                            convertSVGToPoint: ja,
                            convertPointToSVG: bb,
                            convertPointToLatLon: y.convertPointToLatLon.bind(y),
                            convertLatLonToPoint: y.convertLatLonToPoint.bind(y),
                            meters_per_pixel: W.meters_per_pixel
                        }, y.routingSolver = new v({routing: d.routing}, e), y.navigationSolver = new u(y.routingSolver, e.meters_per_pixel, y.routingSolver.hasIntersections()), y.setRoutingURL("#javascript"));
                        var f = [], g;
                        for (g in d.parameters.styles) f.push(g);
                        f.sort(function (a,
                                         b) {
                            a = d.parameters.styles[a] && "undefined" !== typeof d.parameters.styles[a].extrusion_height ? parseFloat(d.parameters.styles[a].extrusion_height) : 0;
                            b = d.parameters.styles[b] && "undefined" !== typeof d.parameters.styles[b].extrusion_height ? parseFloat(d.parameters.styles[b].extrusion_height) : 0;
                            return a - b
                        });
                        P(Ua * W.meters_per_pixel);
                        var h = [], k = {};
                        "undefined" !== typeof d.routing && "undefined" !== typeof d.routing.floors && B.each(d.routing.floors, function (a) {
                            k[a.name] = a
                        });
                        b.find("svg>g[id^=floor]").each(function () {
                            var a =
                                jQuery(this), b = a.attr("id").substr(5), e = {};
                            e.floor = b;
                            var g = y.getFloor(e.floor);
                            null === g && (g = J(e.floor), y.scene.add(g.node), "undefined" !== typeof k[e.floor] && (g.heightMin = k[e.floor].zmin, g.heightMax = k[e.floor].zmax));
                            a.find(">g[id^=vg-common-foreground]>g[id^=vg-model]").each(function () {
                                var a = jQuery(this), b = {thickness: 0, offset: 0, order: f.indexOf("vg-model")};
                                jQuery.extend(b, d.parameters.styles["vg-model"]);
                                b.thickness = parseFloat(b.extrusion_height);
                                b.order = 0;
                                a.find(">image").each(function () {
                                    h.push({
                                        element: this,
                                        type: "vg-model",
                                        parameters: jQuery.extend({}, b),
                                        layer_info: jQuery.extend({}, e)
                                    })
                                })
                            });
                            a.find(">g[id^=lod]").each(function () {
                                var a = jQuery(this), b = a.attr("id").substr(3);
                                e.lod = parseInt(b, 10);
                                b = g.getLOD(e.lod);
                                null === b && (b = g.createLOD(e.lod));
                                a.find(">g").each(function () {
                                    var a = jQuery(this), b = a.attr("id");
                                    e.type = b;
                                    var g = {lod: 0, thickness: 0, offset: 0, order: f.indexOf(b)};
                                    jQuery.extend(g, d.parameters.styles[b]);
                                    if ("undefined" === typeof g.footprint || !0 !== g.footprint) g.thickness = parseFloat(g.extrusion_height),
                                        g.order = 0, a.find(">*:not(.vghelper)").each(function () {
                                        h.push({
                                            element: this,
                                            type: b,
                                            parameters: jQuery.extend({}, g),
                                            layer_info: jQuery.extend({}, e)
                                        })
                                    })
                                })
                            })
                        });
                        var l = function (a, b) {
                            var d = b.element, e = b.type, f = jQuery(d), g = f.attr("onabort");
                            g && (g = JSON.parse(g));
                            f.attr("id") && f.attr("vg_id", f.attr("id"));
                            if ("vg-model" === e) {
                                !g || "fixed" !== g.vg_orientationType && "fixed" !== g.vg_orientationtype ? !g || "facing" !== g.vg_orientationType && "facing" !== g.vg_orientationtype ? f.attr("vg_face2d", "true") : f.attr("vg_face2d", "false") :
                                    f.attr("vg_orientationType", "fixed");
                                g && "undefined" !== typeof g.vg_model && f.attr("vg_model", g.vg_model);
                                var e = b.layer_info, h = jQuery(d), f = h.attr("transform"), k = p.Transform.parse(f),
                                    l = null === d.getAttribute("x") ? 0 : parseFloat(d.getAttribute("x")),
                                    m = null === d.getAttribute("y") ? 0 : parseFloat(d.getAttribute("y")),
                                    f = parseFloat(d.getAttribute("width")), g = parseFloat(d.getAttribute("height")),
                                    n = new p.Point(l, m);
                                k.multiplyVector(n);
                                l = new p.Point(l + f, m + g);
                                k.multiplyVector(l);
                                k = k.decompose();
                                f *= Math.abs(k.sx);
                                g *=
                                    Math.abs(k.sy);
                                n = {x: (n.x + l.x) / 2, y: (n.y + l.y) / 2, z: 0};
                                n = ja(n);
                                h = U(h.attr("vg_id"), "VgID");
                                l = d.getAttribute("vg_model");
                                m = "fixed" === d.getAttribute("vg_orientationType");
                                d = null === d.getAttribute("vg_face2d") ? !0 : "true" === d.getAttribute("vg_face2d");
                                y.addPOI({
                                    model: ta + l,
                                    id: h,
                                    position: n,
                                    scale: {x: f * W.meters_per_pixel, y: g * W.meters_per_pixel, z: 1},
                                    floor: e.floor,
                                    lod: e.lod,
                                    fixed: m,
                                    angle: k.angle,
                                    face2d: d,
                                    clickable: h && null === h.match(/^mapModel/) ? !0 : !1
                                })
                            } else if ("vg-image" === e) !g || "fixed" !== g.vg_orientationType && "fixed" !==
                            g.vg_orientationtype ? !g || "facing" !== g.vg_orientationType && "facing" !== g.vg_orientationtype ? f.attr("vg_face2d", "true") : f.attr("vg_face2d", "false") : f.attr("vg_orientationType", "fixed"), da(d, b.parameters, b.layer_info); else if ("vg-label" === e) g && g.vg_legend && f.attr("vg_legend", g.vg_legend), ca(d, b.parameters, b.layer_info); else switch (d.localName) {
                                case "rect":
                                    p.convertRectToPath(d);
                                    S(d, b.parameters, b.layer_info);
                                    break;
                                case "polygon":
                                    p.convertPolygonToPath(d);
                                    S(d, b.parameters, b.layer_info);
                                    break;
                                case "polyline":
                                    p.convertPolygonToPath(d);
                                    S(d, b.parameters, b.layer_info);
                                    break;
                                case "ellipse":
                                    p.convertEllipseToPath(d);
                                    S(d, b.parameters, b.layer_info);
                                    break;
                                case "circle":
                                    p.convertCircleToPath(d);
                                    S(d, b.parameters, b.layer_info);
                                    break;
                                case "path":
                                    S(d, b.parameters, b.layer_info)
                            }
                        }, m = 0, n = Math.ceil(h.length / 100), q = 0, r = function () {
                            for (; ;) {
                                var b = m;
                                l.apply(y, [b, h[b]]);
                                m++;
                                q++;
                                if (m === h.length) {
                                    a.notify(1);
                                    M(a);
                                    break
                                }
                                if (q === n) {
                                    q = 0;
                                    a.notify(m / h.length);
                                    setTimeout(r.bind(y), 0);
                                    break
                                }
                            }
                        };
                        setTimeout(r.bind(y), 0)
                    }
                }

                function X(a, b) {
                    a.notify(0);
                    var d = jQuery(jQuery.parseXML(b));
                    d.find("svg").attr("onabort") ? T(a, d) : la(a, d)
                }

                function ra(a, b, d) {
                    var e = b.svg || b.mapContentString;
                    "undefined" !== typeof b.mapContentDirectory && (ta = b.mapContentDirectory + "/");
                    if ("string" === typeof e) null !== e.match(/^</) ? X(a, e) : ka(a, e); else {
                        var f = b.path || "map.svg", g = "ajax", h = "text";
                        b.useJSONP && (h = "jsonp text", g = "jsonp");
                        (e = f.match(/^(.*\/)[^\/]+$/)) && 0 < e.length && (ta = e[1]);
                        "//" !== ta.substr(0, 2) && -1 === ta.indexOf("http://") && -1 === ta.indexOf("https://") || -1 === ta.indexOf("/content/") || y.setRoutingURL(ta.replace("/content/",
                            "/route"));
                        var k = function (b, d, e) {
                            var f = 0;
                            a.notify(0, "ajax request called, method: " + g);
                            jQuery[g]({
                                url: b, dataType: h, callbackParameter: "callback", success: function (b, e, f) {
                                    d.apply(y, [a, b])
                                }, error: function (a, b, d, f) {
                                    e()
                                }, progress: function (b) {
                                    b.lengthComputable ? a.notify(b.loaded / b.total * .25) : (f = Math.min(f + .0024, .24), a.notify(f))
                                }
                            })
                        };
                        null !== f.match(/.svg$/) ? k(f, X, function () {
                            k(f.replace(".svg", ".json"), ka, function () {
                                a.reject({message: "error obtaining map file"})
                            })
                        }) : k(f, function (a, e) {
                            x.checkSlotDescriptionOrLoadJSON(a,
                                e, b, {
                                    sdkType: ["web", "kiosk"],
                                    sdkVersion: y.version,
                                    minimumDataSDKVersion: y.minimumDataSDKVersion
                                }, function (a, b) {
                                    ra(a, b, !0)
                                }, ea, d)
                        }, function () {
                            null !== f.match(/map.json$/) ? k(f.replace(".json", ".svg"), X, function () {
                                a.reject({message: "error obtaining map file after trying .svg"})
                            }) : a.reject({message: "error obtaining map file"})
                        })
                    }
                }

                function Fa(b) {
                    oa = !1;
                    tc = Date.now();
                    switch (y.manipulatorTypeName) {
                        case "map":
                        case "trackball":
                            if (b.target !== Aa.domElement) break;
                            jQuery.each(y.pois_with_selector, function (a, b) {
                                jQuery(b.selector).css("pointer-events",
                                    "none")
                            });
                            var d = ma(b);
                            a = b.button;
                            N = d.x;
                            G = d.y
                    }
                    return !1
                }

                function va(a) {
                    oa = !1;
                    return ya(a)
                }

                function Va(a) {
                    oa = !1;
                    return ya(a)
                }

                function ya(b) {
                    if (0 == a && 0 == b.button) {
                        var d = ma(b);
                        y.onTapWithCenter(d, b)
                    }
                    switch (y.manipulatorTypeName) {
                        case "map":
                        case "trackball":
                            jQuery.each(y.pois_with_selector, function (a, b) {
                                jQuery(b.selector).css("pointer-events", "all")
                            })
                    }
                    a = -1
                }

                function nb(b) {
                    a = -1
                }

                function ma(a) {
                    return "undefined" === typeof a.offsetX ? {
                        x: a.layerX - a.target.offsetLeft,
                        y: a.layerY - a.target.offsetTop
                    } : {
                        x: a.offsetX,
                        y: a.offsetY
                    }
                }

                function $a(a) {
                    var b = [],
                        d = new THREE.Vector3(a.x / y.viewportWidth * 2 - 1, 2 * -(a.y / y.viewportHeight) + 1, .5);
                    d.unproject(y.camera);
                    y.camera instanceof THREE.OrthographicCamera ? (d = new THREE.Vector3(a.x / y.viewportWidth * 2 - 1, 2 * -(a.y / y.viewportHeight) + 1, 1), d.unproject(y.camera), a = new THREE.Vector3(a.x / y.viewportWidth * 2 - 1, 2 * -(a.y / y.viewportHeight) + 1, -1), a.unproject(y.camera), d.sub(a).normalize(), a = new THREE.Raycaster(a, d)) : a = new THREE.Raycaster(y.camera.position, d.sub(y.camera.position).normalize());
                    d = [];
                    if (cb) {
                        for (var e = 0, f = y.activeLODList.length; e < f; ++e) d.push(y.activeLODList[e].node);
                        a = a.intersectObjects(d, !0);
                        jQuery.each(a, function (a, d) {
                            var e = !1, f = d.object;
                            if (!1 !== f.visible && -1 === jQuery.inArray(f, Ab)) {
                                var g, h, k = f.parent.userData.pickables;
                                if ("undefined" !== typeof k) for (var l = 0, m = k.length; l < m; ++l) {
                                    var n = k[l];
                                    if (d.faceIndex >= n.faces_offset && d.faceIndex < n.faces_offset + n.nb_faces && (g = y.places[n.id], "undefined" !== typeof g)) {
                                        h = n;
                                        break
                                    }
                                }
                                if ("undefined" === typeof g) if (f.vg && f.vg.batch) (f = f.vg.batch.getPickableFromIntersection(d)) &&
                                f.options.poi.clickable && (g = f.publicObject, h = f.options, e = h.poi.overlay); else if ("undefined" !== typeof f && "undefined" !== typeof f.vg && null !== f.vg.id && f.vg.poi && f.vg.poi.clickable) {
                                    g = y.pois[f.vg.id];
                                    if (1 === g.length) g = g[0]; else for (l = 0, m = g.length; l < m; l++) if (B.isMatch(f.vg.poi, g[l].options())) {
                                        g = g[l];
                                        break
                                    }
                                    h = f.vg;
                                    e = f.vg.poi.overlay
                                }
                                if ("undefined" === typeof g) return !1;
                                b.push({vg: h, target: g, distance: d.distance, overlay: e})
                            }
                        })
                    } else {
                        e = 0;
                        for (f = y.activeLODList.length; e < f; ++e) d.push(y.activeLODList[e].pickables);
                        d = d.concat.apply([], d);
                        a = a.intersectObjects(d, !0);
                        jQuery.each(a, function (a, d) {
                            var e, f, g, h = !1, k = d.object;
                            if (!1 !== k.visible && -1 === jQuery.inArray(d.object, Ab) && !("undefined" === typeof k.vg || "undefined" === typeof k.vg.id && "undefined" === typeof k.vg.batch || null === k.vg.id || k.vg.poi && !1 === k.vg.poi.clickable)) {
                                g = k.vg;
                                if (k.vg.batch) (e = k.vg.batch.getPickableFromIntersection(d)) && e.options.poi.clickable && (f = e.publicObject, g = e.options, h = g.poi.overlay); else if (f = y.places[k.vg.id], "undefined" === typeof f) {
                                    if (0 === k.vg.poi._opacity) return;
                                    h = k.vg.poi.overlay;
                                    f = y.pois[k.vg.id];
                                    if (1 === f.length) f = f[0]; else {
                                        e = 0;
                                        for (var l = f.length; e < l; e++) if (B.isMatch(k.vg.poi, f[e].options())) {
                                            f = f[e];
                                            break
                                        }
                                    }
                                }
                                "undefined" !== typeof f && b.push({vg: g, target: f, distance: d.distance, overlay: h})
                            }
                        })
                    }
                    b.sort(function (a, b) {
                        return a.overlay === b.overlay ? a.distance - b.distance : a.overlay ? -1 : 1
                    });
                    return 0 < b.length ? [b[0]] : []
                }

                function vb(b) {
                    if (oa) {
                        switch (y.manipulatorTypeName) {
                            case "map":
                            case "trackball":
                                if (b.target !== Aa.domElement) break;
                                b.preventDefault();
                                var d = ma(b);
                                if (0 !== a) if (1 ===
                                    a) {
                                    if (y.manipulator.zoomManipulatorEnabled && (y.manipulator.radius *= 1 + y.manipulator.zoomSpeed * (G - d.y), y.manipulator.update(), !1 !== y.customPostManipulatorListener && !1 === y.customPostManipulatorListener({
                                            type: "dragmiddle",
                                            center: d,
                                            event: b
                                        }))) break
                                } else if (2 === a) {
                                    var e = !1;
                                    y.manipulator.pitchManipulatorEnabled && (y.publicCamera.pitch += y.manipulator.rotationSpeed * (d.y - G), e = !0);
                                    y.manipulator.rotationManipulatorEnabled && (y.publicCamera.rotation += y.manipulator.rotationSpeed * (d.x - N), e = !0);
                                    if (e && (y.manipulator.update(),
                                        !1 !== y.customPostManipulatorListener && !1 === y.customPostManipulatorListener({
                                            type: "dragright",
                                            center: d,
                                            event: b
                                        }))) break
                                } else if (e = $a(d), !1 !== e) {
                                    var f = Ab.slice(0);
                                    Ab = e;
                                    var g, h, k, l, m, n;
                                    for (g in f) {
                                        k = f[g];
                                        m = k.vg.id;
                                        n = !1;
                                        for (h in e) if (l = e[h], l = l.vg.id, m === l) {
                                            n = !0;
                                            break
                                        }
                                        n || (m = k.vg, k = k.target, l = !0, m.poi && m.poi.onObjectMouseOut && (l = m.poi.onObjectMouseOut(b, k, $b)), !1 !== l && "undefined" !== typeof ab && ab(b, k, $b))
                                    }
                                    for (h in e) l = e[h], m = l.vg, k = l.target, f = !0, m.poi && m.poi.onObjectMouseOver && (f = m.poi.onObjectMouseOver(b,
                                        k, $b)), !1 !== f && "undefined" !== typeof Yb && Yb(b, k, $b);
                                    $b++
                                }
                                N = d.x;
                                G = d.y
                        }
                        return !1
                    }
                    oa = !0
                }

                function Q(a, b) {
                    "undefined" === typeof b && (a.wheelDeltaY ? b = a.wheelDeltaY : a.wheelDelta ? b = a.wheelDelta : a.detail && (b = a.detail), "undefined" === typeof b && window.event && (a = window.event, a.wheelDeltaY ? b = a.wheelDeltaY : a.wheelDelta ? b = a.wheelDelta : a.detail && (b = a.detail)));
                    if (!1 === y.customPreManipulatorListener || !1 !== y.customPreManipulatorListener({
                            type: "wheel",
                            delta: b
                        })) {
                        switch (y.manipulatorTypeName) {
                            case "map":
                            case "trackball":
                                if (a.preventDefault(),
                                    "undefined" !== typeof b && y.manipulator.zoomManipulatorEnabled) {
                                    var d = Ma[0].getBoundingClientRect(),
                                        d = {left: a.clientX - d.left, top: a.clientY - d.top};
                                    positionBefore = y.convertScreenToPoint(d);
                                    y.manipulator.radius = 0 < b ? .8 * y.manipulator.radius : y.manipulator.radius / .8;
                                    y.manipulator.update();
                                    if ("map" == y.manipulatorTypeName) {
                                        var d = y.convertScreenToPoint(d), e = y.publicCamera.position;
                                        y.publicCamera.position = {
                                            x: positionBefore.x - d.x + e.x,
                                            y: positionBefore.y - d.y + e.y,
                                            radius: e.radius
                                        }
                                    }
                                }
                        }
                        if (!1 === y.customPostManipulatorListener ||
                            !1 !== y.customPostManipulatorListener({type: "wheel", delta: b})) return !1
                    }
                }

                function lb(a) {
                    if (a.target !== Aa.domElement) return !1;
                    a.preventDefault();
                    return !1
                }

                function ja(a) {
                    var b = {};
                    b.x = (a.x - ga) * W.meters_per_pixel;
                    b.y = (ga - a.y) * W.meters_per_pixel;
                    "undefined" !== typeof a.z && (b.z = a.z);
                    return b
                }

                function bb(a) {
                    var b = {};
                    b.x = a.x / W.meters_per_pixel + ga;
                    b.y = ga - a.y / W.meters_per_pixel;
                    "undefined" !== typeof a.z && (b.z = a.z);
                    return b
                }

                function Sa(a, b, d, e, f, g) {
                    void 0 === a.initialValue && (a.initialValue = {});
                    for (var h in b) f ? a.initialValue[h] =
                        a[h] : ("undefined" === typeof a.initialValue[h] && (a.initialValue[h] = a[h]), a[h] = b[h]);
                    e = e || 0;
                    if (f) f = b; else {
                        f = {};
                        for (var k in b) "undefined" !== typeof a.initialValue[k] && (f[k] = a.initialValue[k])
                    }
                    if (0 === d && 0 === e) {
                        for (k in f) a[k] = f[k];
                        "function" === typeof g && g()
                    } else if (a = (new TWEEN.Tween(a)).to(f, d).delay(e).start(), "function" === typeof g) a.onUpdate(g)
                }

                function Ea(a, b, d, e) {
                    var f = jQuery.Deferred(), g = f.promise();
                    d = a.index < d.index ? -1 : 1;
                    d = nc.translate.clone().multiplyScalar(d);
                    var h = e && "number" === typeof e.animationDuration ?
                        e.animationDuration : nc.transitionTime;
                    Sa(a.node.position, {x: d.x, y: d.y, z: d.z}, h, 0, b, function () {
                        a.node.updateMatrix();
                        a.node.updateMatrixWorld(!0)
                    });
                    f.done(function () {
                        y.forcePoiUpdateOpacity || (y.forcePoiUpdateOpacity = !0, y.updateCameraObjects(), y.forcePoiUpdateOpacity = !1, y.requestRedraw())
                    });
                    a.node.traverse(function (a) {
                        if ("undefined" !== typeof a.material) if (a.material instanceof THREE.MeshFaceMaterial) for (var d in a.material.materials) Sa(a.material.materials[d], {opacity: 0}, h, 0, b); else Sa(a.material, {opacity: 0},
                            h, 0, b)
                    });
                    0 === h ? f.resolve() : (new TWEEN.Tween({dummy: 0})).to({dummy: 1}, h).onComplete(function () {
                        f.resolve()
                    }).start();
                    return g
                }

                var Ya = [], Cb = [], cb = !0;
                this.useDepthWriteForPOIs = !0;
                var y = this;
                this.pois = {};
                this._anonymous_poi_counter = 0;
                this.pois_with_selector = [];
                this.places_list = {};
                this.polygons_table = {};
                this.points_table = {};
                this.pois_floor_table = {};
                this.places = {};
                this.plugins = {};
                this.viewportHeight = this.viewportWidth = 0;
                this.camera = this.scene = null;
                this.nbUpdatableObjects = 0;
                this.mustUpdateCameraObjects =
                    !1;
                this.textures = {};
                this.models = {};
                this.loaderStatistics = {models: 0, textures: 0, pois: 0};
                this.current_lod = 2;
                this.currentFloorName = "";
                this.currentFloor = null;
                this.activeLODList = [];
                this.manipulator = null;
                this.manipulatorTypeName = "map";
                this.customPostManipulatorListener = this.customPreManipulatorListener = !1;
                this.globalCameraUpdatebleLinks = [];
                this.extraData = this.navigationSolver = this.routingSolver = !1;
                this.deferredPoiLoading = {active: !1, setPlaceName: {}, setPlaceIcon: {}};
                this.publicLodFactor = 1;
                this.publicCamera =
                    null;
                this.layersParameters = {
                    receiveShadow: {order: 9},
                    wall: {enabled: !0, order: 10},
                    debugLabel: {enabled: !1, order: 87, offset: 5.5, thickness: 0},
                    reflection: {order: 89},
                    sprite: {order: 90, offset: 2, scale: 2},
                    overlay: {order: 91},
                    global: {fog: {color: 0, near: 6500, far: 7E3}}
                };
                var La = null, ob = null, Qa = !1, ta = "", Za = "", Ja = {
                        fovX: 45, fovY: 45, near: 1, far: 7E3, update: function (a, b) {
                            if (0 !== a && 0 !== b) {
                                var d = .5 * this.fovY * e.DEG2RAD, f = Math.tan(d) / b;
                                this.projectedPixelSize = Math.tan(d) / b;
                                this.cosFovY = Math.cos(d);
                                this.fovX = 2 * Math.atan(f * a) * e.RAD2DEG
                            }
                        }
                    },
                    Aa, Pa = !1, Ta = !1, V, Ma, Ua, ga, ub = !0, ua = !1;
                new THREE.Box3;
                var wb = 0, Fb = Date.now();
                this.plane_geometry = new THREE.PlaneBufferGeometry(1, 1);
                this.plane_geometry.vg = {permanent: !0};
                var ib = "undefined" !== typeof b.vgcontinuous ? !1 : !0, Tb = !1, Ab = [], Yb, ab,
                    Oa = function (a, b, d) {
                    }, Zb = !1, Ha = [];
                this.floors = Ha;
                var t = {};
                this.publicFloors = !1;
                var Db = "", nc = {translate: new THREE.Vector3(0, 0, 2048), opacity: !0, transitionTime: 500};
                a = -1;
                G = N = 0;
                var oa = !1, Ob = 0, tc = 0, W = {
                    rotation_angle_in_degrees: 0, meters_per_pixel: .2, geo_xref: 0, geo_yref: 0,
                    utm_zone: 1
                }, Nb = !1, Kb, Mb, Pb = 0, dc = 0, Qb, xb;
                this.initialize = function (a, d) {
                    for (var e in I.available_plugins) {
                        var f = I.available_plugins[e];
                        this.plugins[f.name] = new f.factory(this)
                    }
                    e = jQuery.Deferred();
                    f = e.promise();
                    e.done(function () {
                        y.trigger("initializeCompleted", void 0, !0)
                    });
                    e.fail(function () {
                        y.trigger("initializeFailed", void 0, !0)
                    });
                    V = a;
                    Ma = jQuery(V);
                    this.viewportWidth = Ma.width();
                    this.viewportHeight = Ma.height();
                    this.vgbatchfacing = this.vgnobatchicon = this.vgnobatch = !1;
                    "undefined" !== typeof b.vgnobatch && (this.vgnobatch =
                        !0);
                    "undefined" !== typeof b.vgnobatchicon && (this.vgnobatchicon = !0);
                    "undefined" !== typeof b.vgnobatchfacing && (this.vgnobatchfacing = !0);
                    if ("undefined" !== typeof d.optimizations) {
                        var g = d.optimizations;
                        "undefined" !== typeof g.load1 && (ub = !g.load1);
                        "undefined" !== typeof g.framerate1 && (ua = g.framerate1);
                        "undefined" !== typeof g.nobatch && (this.vgnobatch = g.nobatch)
                    }
                    Db = d.initialFloorName || Db;
                    g = {
                        antialias: "undefined" !== typeof d.antialias ? d.antialias : !0,
                        stencil: !1,
                        alpha: !0,
                        devicePixelRatio: d.devicePixelRatio,
                        bugPixelStorei: d.bugPixelStorei,
                        bugWP81: d.bugWP81,
                        disable_console: "undefined" !== typeof d.disable_console ? d.disable_console : !0,
                        useSkeleton: !1,
                        recomputeCameraInverse: !1
                    };
                    THREE.ImageUtils.crossOrigin = "";
                    try {
                        Aa = new THREE.WebGLRenderer(g)
                    } catch (h) {
                        return e.reject({message: h}), f
                    }
                    Aa && Aa.setSize || E.log("bad");
                    this.renderer = Aa;
                    Aa.setSize(this.viewportWidth, this.viewportHeight);
                    Ma.empty();
                    Ma.append(Aa.domElement);
                    D();
                    this.scene = new THREE.Scene;
                    this.scene.autoUpdate = !1;
                    this.scene.matrixAutoUpdate = !1;
                    this.scene.fog = !1;
                    Ja.update(this.viewportWidth,
                        this.viewportHeight);
                    this.camera = "undefined" === typeof b.vgorthographic ? new THREE.PerspectiveCamera(Ja.fovY, this.viewportWidth / this.viewportHeight, Ja.near, Ja.far) : new THREE.OrthographicCamera(this.viewportWidth / -2, this.viewportWidth / 2, this.viewportHeight / 2, this.viewportHeight / -2, .1, 2E4);
                    this.camera.matrixAutoUpdate = !1;
                    this.camera.position.copy({x: 0, y: 0, z: 300});
                    this.camera.updateMatrix();
                    this.scene.add(this.camera);
                    this.manipulator = new r(this, this.camera);
                    y.manipulator.update();
                    g = new THREE.AmbientLight(4473924);
                    g.matrixAutoUpdate = !1;
                    this.scene.add(g);
                    xb = new THREE.DirectionalLight(16777215, 1);
                    xb.matrixAutoUpdate = !1;
                    xb.position.set(0, 100, 100);
                    xb.target.position.set(0, 0, 0);
                    xb.updateMatrix();
                    this.scene.add(xb);
                    "undefined" !== typeof d.path || "undefined" !== typeof d.svg || "undefined" !== typeof d.mapContentString ? ra(e, d) : e.reject({message: "missing .path or .mapContentString parameter"});
                    Yb = d.onObjectMouseOver;
                    ab = d.onObjectMouseOut;
                    Oa = function (a, b, e) {
                        var f = !0;
                        e && e.onObjectMouseUp && (f = e.onObjectMouseUp(a, b));
                        if (!1 ===
                            f || !1 === y.trigger("mouseup", {event: a, element: b})) return !1;
                        if (d.onObjectMouseUp) d.onObjectMouseUp(a, b)
                    };
                    e.done(Y);
                    return f
                };
                this.setup = function () {
                    this.animateBind = this.animate.bind(this);
                    this.publicCamera = new h(this)
                };
                this.getFloor = function (a) {
                    a = t[a];
                    return "undefined" === typeof a ? null : a
                };
                this.setShapeColor = function (a, b) {
                    for (var d = ua ? a.vg.layer.children[0].geometry : a.geometry, e = d.faces, f = a.vg.nb_faces, g = a.vg.faces_offset, h = new THREE.Color(b), k = g; k < g + f; ++k) e[k].color = h;
                    d.colorsNeedUpdate = !0
                };
                var $b = 0;
                this.requestRedraw = function () {
                    Ta && (Tb || !1 !== Pa || (Pa = requestAnimationFrame(y.animateBind)))
                };
                this.requestContinuousUpdate = function (a) {
                    Ta && (Tb = a, !1 === Pa && (Pa = requestAnimationFrame(y.animateBind)))
                };
                var Lb = function (a, b) {
                    var d = Math.sin(W.rotation_angle_in_degrees * Math.PI / 180),
                        e = Math.cos(W.rotation_angle_in_degrees * Math.PI / 180), f = a - W.pixel_xref,
                        g = b - W.pixel_yref;
                    return [W.meters_per_pixel * (f * e - g * d), W.meters_per_pixel * (f * d + g * e)]
                };
                this.setAutoUpdateLOD = function (a) {
                    for (var b = 0, d = Ha.length; b < d; b++) Ha[b].setAutoUpdateLOD(a)
                };
                this.forcePoiUpdateOpacity = !1;
                this._updateObjectOpacity = function (a, b) {
                    if (a.vg.poi && a.vg.poi.visibilityRampStartVisible && a.vg.poi.visibilityRampFullyVisible && a.vg.poi.visibilityRampStartInvisible && a.vg.poi.visibilityRampFullyInvisible) {
                        var d = y.computeOpacity(a.position, a.vg.poi, b);
                        a.visible = 0 == d || !1 === a.vg.poi.visible ? !1 : !0;
                        var e = a.vg.poi._opacity;
                        if (this.forcePoiUpdateOpacity || e !== d) a.vg.poi._opacity = d, a.traverse(function (a) {
                            if (a.material) {
                                a.material.opacity = d;
                                var b = a.material.materials;
                                if (b) for (var e =
                                    0, f = b.length; e < f; ++e) b[e].opacity = d
                            }
                            a.vg && a.vg.poi && a.vg.poi.selector && (0 === d || !1 === a.vg.poi.visible ? jQuery(a.vg.poi.selector).hide() : jQuery(a.vg.poi.selector).css("opacity", d).show())
                        })
                    }
                };
                this.updateCameraObjects = function () {
                    for (var a = 0, b = Ha.length; a < b; a++) {
                        var d = Ha[a];
                        if (d.isAutoUpdateLOD() && d.isEnabled()) for (var e = this.computeTargetLod(d.name), f = 0, g = d.lods.length; f < g; f++) d.lods[f].setEnabled(f == e);
                        d.name == this.currentFloorName && (this.current_lod = e)
                    }
                    a = 0;
                    for (b = y.activeLODList.length; a < b; ++a) {
                        d = y.activeLODList[a];
                        f = y.camera.position.clone();
                        d.node.worldToLocal(f);
                        for (var g = 0, h = d.rampObjects.length; g < h; ++g) e = d.rampObjects[g], this._updateObjectOpacity(e, f);
                        f = 0;
                        for (g = d.cameraUpdatableObjects.length; f < g; ++f) e = d.cameraUpdatableObjects[f], e.updateMatrix(), e.updateMatrixWorld()
                    }
                    b = new THREE.Vector3;
                    a = 0;
                    for (e = this.pois_with_selector.length; a < e; ++a) if (f = this.pois_with_selector[a], f.selector) if (g = jQuery(f.selector), d = y.getFloor(f.floor), d = "undefined" !== typeof f.lod ? d.getLOD(f.lod) : d.floorContentLOD, !1 === d.isActive() ||
                        !1 === f.visible || 0 === f._opacity) g.hide(), f._opacity = 0; else if (b.copy(f.position), d = y.getFloor(f.floor).getPosition(), b.add(d), b.project(y.camera), 1 < b.z) g.hide(); else {
                        g.show();
                        var d = (b.x + 1) / 2 * this.viewportWidth, h = (1 - b.y) / 2 * this.viewportHeight,
                            k = g.width(), l = g.height(), d = d + k * (f.alignment.x - 1) / 2,
                            h = h - l * (f.alignment.y + 1) / 2;
                        "" !== g.text() && (d = Math.round(d), h = Math.round(h));
                        g.css("transform", "translate(" + d + "px," + h + "px)");
                        g.css("webkit-transform", "translate(" + d + "px," + h + "px)")
                    }
                    a = 0;
                    for (b = y.globalCameraUpdatebleLinks.length; a <
                    b; ++a) y.globalCameraUpdatebleLinks[a].updateCamerafacing()
                };
                this.removeLink = function (a) {
                    for (var b = 0, d = y.globalCameraUpdatebleLinks.length; b < d; b++) if (y.globalCameraUpdatebleLinks[b] === a) return y.globalCameraUpdatebleLinks.splice(b, 1), !0;
                    return !1
                };
                this.addLink = function (a) {
                    this.globalCameraUpdatebleLinks.push(a)
                };
                this.removePath = function (a) {
                    var b = a.lod.pathObjects.indexOf(a);
                    -1 !== b && a.lod.pathObjects.splice(b, 1)
                };
                this.addActiveLOD = function (a) {
                    this.activeLODList.push(a)
                };
                this.removeActiveLOD = function (a) {
                    for (var b =
                        0, d = y.activeLODList.length; b < d; b++) if (y.activeLODList[b] === a) return y.activeLODList.splice(b, 1), !0;
                    return !1
                };
                this.computeTargetLod = function (a) {
                    var b = 0;
                    if (null === La || ob !== a) {
                        var d = this.getFloor(a).lods.length;
                        La = [];
                        ob = a;
                        var f;
                        if (W.meters_per_pixel) {
                            W.distance_coef || (W.distance_coef = .5);
                            if (!1 === Qa) {
                                a = Ua;
                                var g, h, k, l, m;
                                g = Lb(0, 0);
                                f = g[0];
                                g = g[1];
                                h = f;
                                l = g;
                                k = f;
                                m = g;
                                g = Lb(0, a);
                                f = g[0];
                                g = g[1];
                                h = Math.min(h, f);
                                l = Math.min(l, g);
                                k = Math.max(k, f);
                                m = Math.max(m, g);
                                g = Lb(a, a);
                                f = g[0];
                                g = g[1];
                                h = Math.min(h, f);
                                l = Math.min(l, g);
                                k = Math.max(k, f);
                                m = Math.max(m, g);
                                g = Lb(a, 0);
                                f = g[0];
                                g = g[1];
                                h = Math.min(h, f);
                                l = Math.min(l, g);
                                k = Math.max(k, f);
                                m = Math.max(m, g);
                                Qa = Math.max(k - h, m - l)
                            }
                            f = .5 * Qa * W.distance_coef;
                            a = Math.tan(.5 * Ja.fovY * e.DEG2RAD) / this.viewportHeight;
                            f /= 1800 * a;
                            for (a = 0; a < d - 1; a++) La.push(f), f *= .5
                        } else if (f = 800, 1 < d) for (h = 700 / (d - 1), a = 0; a < d - 1; a++) f -= h, La.push(f)
                    }
                    d = this.manipulator.radius / this.publicLodFactor;
                    W.meters_per_pixel && (d = d * Math.sin(-this.publicCamera.pitch * e.DEG2RAD) * W.meters_per_pixel);
                    a = 0;
                    for (f = La.length; a < f; ++a) if (d < La[a]) b++;
                    else break;
                    return b
                };
                this.computeOpacity = function () {
                    var a = new THREE.Vector3;
                    return function (b, d, e) {
                        a.copy(b);
                        a.sub(e);
                        b = a.length();
                        return b = b < d.visibilityRampStartVisible || b > d.visibilityRampFullyInvisible ? 0 : b < d.visibilityRampFullyVisible ? THREE.Math.mapLinear(b, d.visibilityRampStartVisible, d.visibilityRampFullyVisible, 0, 1) : b <= d.visibilityRampStartInvisible ? 1 : THREE.Math.mapLinear(b, d.visibilityRampFullyInvisible, d.visibilityRampStartInvisible, 0, 1)
                    }
                }();
                this.frameCounter = 0;
                this.frameRateDivider = 1;
                navigator &&
                navigator.userAgent && -1 != navigator.userAgent.indexOf("Windows Phone") && (this.frameRateDivider = 3);
                this.frameRateProbing = !1;
                this.frameTimeLastProbe = 0;
                this.animate = function (a) {
                    Pa = !1;
                    this.frameCounter++;
                    if (Tb && (Pa = requestAnimationFrame(y.animateBind), 0 != this.frameCounter % this.frameRateDivider)) return;
                    y.mustUpdateCameraObjects && (y.updateCameraObjects(), y.mustUpdateCameraObjects = !1);
                    for (var b = 0, d = y.activeLODList.length; b < d; ++b) for (var e = y.activeLODList[b], f = 0, g = e.pathObjects.length; f < g; ++f) a = e.pathObjects[f].mesh,
                    a.vg.path && a.material.map && (a.material.map.offset.x = -wb * a.vg.path.speed);
                    this.render()
                };
                this.postRenderListeners = [];
                this.postRenderListenersRemoveList = [];
                this.addPostRenderListener = function (a) {
                    this.postRenderListeners.push(a)
                };
                this.removePostRenderListener = function (a) {
                    for (var b = 0, d = this.postRenderListeners.length; b < d; b++) if (this.postRenderListeners[b] === a) return this.postRenderListenersRemoveList.push(a), !0;
                    return !1
                };
                this.render = function () {
                    var a;
                    TWEEN.update();
                    document.body.contains(Ma[0]) && (Aa.autoClear =
                        !1, Aa.clear(), Aa.render(this.scene, this.camera));
                    wb = (Date.now() - Fb) / 1E3;
                    for (a = 0; a < this.postRenderListeners.length; a++) this.postRenderListeners[a]();
                    for (y.trigger("redraw", void 0); 0 < this.postRenderListenersRemoveList.length;) {
                        var b = this.postRenderListenersRemoveList.pop();
                        a = 0;
                        for (var d = this.postRenderListeners.length; a < d; a++) if (this.postRenderListeners[a] === b) {
                            this.postRenderListeners.splice(a, 1);
                            break
                        }
                    }
                };
                this.animateObject = Sa;
                this.getGeoinformation = function () {
                    return W
                };
                this.convertPointToScreen = function (a) {
                    a =
                        new THREE.Vector3(a.x, a.y, a.z || 0);
                    a.project(y.camera);
                    return {left: .5 * this.viewportWidth * (a.x + 1), top: .5 * this.viewportHeight * (1 - a.y)}
                };
                this.convertScreenToPoint = function (a, b) {
                    b = b || 0;
                    var d = new THREE.Vector3(2 * a.left / y.viewportWidth - 1, 1 - 2 * a.top / y.viewportHeight, 1);
                    d.unproject(y.camera);
                    if (this.camera instanceof THREE.OrthographicCamera) {
                        var e = new THREE.Vector3(2 * a.left / y.viewportWidth - 1, 1 - 2 * a.top / y.viewportHeight, -1);
                        e.unproject(y.camera);
                        if (d.z == e.z) return {x: e.x, y: e.y, z: b};
                        var f = e.clone();
                        f.sub(d);
                        f.multiplyScalar((e.z -
                            b) / f.z);
                        e.sub(f);
                        return {x: e.x, y: e.y, z: b}
                    }
                    d = d.clone().sub(y.camera.position).normalize();
                    if (.001 > Math.abs(d.z)) return d = y.publicCamera.position, {x: d.x, y: d.y, z: 0};
                    e = (y.camera.position.z - b) / -d.z;
                    d = d.clone().multiplyScalar(e);
                    d = d.add(y.camera.position);
                    return {x: d.x, y: d.y, z: d.z}
                };
                this.convertLatLonToPoint = function (a) {
                    if (!Nb) return {x: 0, y: 0, z: 1, valid: !1};
                    a = new Proj4js.Point([a.lon, a.lat]);
                    a = Proj4js.transform(Kb, Mb, a);
                    a = {x: a.x - Pb, y: a.y - dc};
                    var b = {}, d = a.x, e = a.y;
                    b.x = d * W.matrixUTMToSVG.elements[0] + e * W.matrixUTMToSVG.elements[1] +
                        W.matrixUTMToSVG.elements[4];
                    b.y = d * W.matrixUTMToSVG.elements[2] + e * W.matrixUTMToSVG.elements[3] + W.matrixUTMToSVG.elements[5];
                    "undefined" !== typeof a.z && (b.z = a.z);
                    b.z = 2;
                    return a = ja(b)
                };
                this.convertPointToLatLon = function (a) {
                    if (!Nb) return {lat: 0, lon: 0, valid: !1};
                    var b = bb(a), d = b.x + W.matrixSVGToUTM.elements[4], b = W.matrixSVGToUTM.elements[5] - b.y;
                    a = new Proj4js.Point([d * W.matrixSVGToUTM.elements[0] + b * W.matrixSVGToUTM.elements[1] + Pb, d * W.matrixSVGToUTM.elements[2] + b * W.matrixSVGToUTM.elements[3] + dc, a.z || 0]);
                    a = Proj4js.transform(Mb,
                        Kb, a);
                    return {lat: a.y, lon: a.x}
                };
                this.offsetPosition = function (a, b, d, e) {
                    a = bb(a);
                    b = Math.PI * (b + W.rotation_angle_in_degrees) / 180;
                    d = Math.PI * d / 180;
                    a.z = a.z || 0;
                    var f = e / W.meters_per_pixel;
                    e = {
                        x: a.x + Math.sin(b) * Math.cos(d) * f,
                        y: a.y - Math.cos(b) * Math.cos(d) * f,
                        z: a.z + Math.sin(d) * e
                    };
                    return ja(e)
                };
                this.computeHeadingAngle = function (a, b, d) {
                    a = u._getVector(bb(a));
                    b = u._getVector(bb(b));
                    d = u._getVector(bb(d));
                    b = u._subVectors(b, a);
                    a = u._subVectors(d, a);
                    b.z = 0;
                    a.z = 0;
                    return 0 == b.lengthSq() || 0 == a.lengthSq() ? !1 : u._computeAngle(b.normalize(),
                        a.normalize())
                };
                this.computeDistance = function (a, b) {
                    var d = u._getVector(bb(a)), e = u._getVector(bb(b)), f = (a.z || 0) - (b.z || 0),
                        d = u._subVectors(e, d);
                    d.z = 0;
                    d = d.length() * W.meters_per_pixel;
                    return 0 == f ? d : Math.sqrt(d * d + f * f)
                };
                this.initializeProjection = function (a) {
                    Nb = !1;
                    if ("string" !== typeof a.proj4string) return !1;
                    var b = a.proj4string.replace(/\+proj=(\S+).*$/, "$1");
                    if (!b.match(/utm|somerc|tmerc|lcc/)) return !1;
                    Kb = new Proj4js.Proj("WGS84");
                    b = b.toUpperCase() + "00";
                    Proj4js.defs[b] = a.proj4string;
                    Mb = new Proj4js.Proj(b);
                    Pb = parseFloat(a.offsetX) || 0;
                    dc = parseFloat(a.offsetY) || 0;
                    return Nb = !0
                };
                this.textGenerator = new z;
                this.addPOI = function (a) {
                    return q.createPOI({container: V, _mapviewer: y, MapviewerPrivate: I}, a)
                };
                this.addRoutingPath = function (a) {
                    return (a = this.addRoutingPrivatePath(a)) ? a.getPublicPath() : !1
                };
                this.addRoutingPrivatePath = function (a) {
                    var b, d, e = {};
                    e.points = a.points;
                    if ("undefined" === typeof e.points || 2 > e.points.length) return !1;
                    d = e.points;
                    if (2 === d.length && d[0].x === d[1].x && d[0].y === d[1].y && d[0].z === d[1].z) return !1;
                    e.url =
                        a.url;
                    e.speed = "undefined" !== typeof a.speed ? a.speed : 0;
                    e.repeat = a.repeat || -1;
                    e.overlay = "undefined" !== typeof a.overlay ? a.overlay : !y.useDepthWriteForPOIs;
                    e.segments = a.segments || -1;
                    e.thickness = "undefined" !== typeof a.thickness ? a.thickness : 2;
                    e.lod = a.lod;
                    e.floor = a.floor || y.currentFloorName;
                    e.visible = "undefined" !== typeof a.visible ? a.visible : !0;
                    e.color = "undefined" !== typeof a.color ? a.color : 16777215;
                    e.opacity = "undefined" !== typeof a.opacity ? a.opacity : 1;
                    e.interpolationStart = a.interpolationStart || 0;
                    e.interpolationEnd =
                        "undefined" === typeof a.interpolationEnd ? 1 : a.interpolationEnd;
                    e.interpolationTextureLikeWindow = "undefined" === typeof a.interpolationTextureLikeWindow ? !0 : a.interpolationTextureLikeWindow;
                    0 > e.thickness && (e.thickness *= -1);
                    a = new THREE.CurvePath;
                    var g = d.length;
                    for (b = 0; b < g; b++) d[b].z = d[b].z || 0;
                    if (2 === g) a.add(new THREE.LineCurve3(d[0], d[1])); else {
                        var h = new THREE.Vector3, k = new THREE.Vector3;
                        b = 0;
                        k.subVectors(d[b + 1], d[b]).multiplyScalar(.5).add(d[b]);
                        a.add(new THREE.LineCurve3(d[b], k.clone()));
                        b = 1;
                        h.subVectors(d[b],
                            d[b - 1]);
                        h.multiplyScalar(.5);
                        h.add(d[b - 1]);
                        for (b = 1; b < g - 1; ++b) k.subVectors(d[b + 1], d[b]), k.multiplyScalar(.5), k.add(d[b]), a.add(new THREE.CubicBezierCurve3(h.clone(), d[b], d[b], k.clone())), h = k.clone();
                        b = g - 2;
                        h.subVectors(d[b + 1], d[b]);
                        h.multiplyScalar(.5);
                        h.add(d[b]);
                        a.add(new THREE.LineCurve3(h, d[b + 1]))
                    }
                    d = a.getLength();
                    0 > e.segments && (e.segments = Math.ceil(-d / e.segments));
                    h = e.repeat;
                    0 > h && (h *= -d / e.thickness);
                    b = new m(a, {
                        segments: e.segments,
                        radius: e.thickness,
                        segmentsRadius: 2,
                        closed: !1,
                        debug: !1,
                        interpolationStart: e.interpolationStart,
                        interpolationEnd: e.interpolationEnd,
                        interpolationTextureLikeWindow: e.interpolationTextureLikeWindow,
                        zOffset: I.zOffsetPath
                    });
                    g = b.geometry;
                    k = new THREE.MeshBasicMaterial({
                        color: e.color,
                        opacity: e.opacity,
                        wireframe: !1,
                        transparent: !0,
                        depthWrite: !1,
                        depthTest: !e.overlay
                    });
                    if (e.url) {
                        var n = new f(y, e.url, !1);
                        n.wrapS = THREE.RepeatWrapping;
                        n.wrapT = THREE.RepeatWrapping;
                        n.repeat.x = h;
                        n.repeat.y = -1;
                        k.map = n
                    } else e.speed = 0;
                    h = new THREE.Mesh(g, k);
                    h.matrixAutoUpdate = !1;
                    h.renderDepth = (e.overlay ? I.renderDepthPathOverlay :
                        I.renderDepthPath) - g.vertices[0].z;
                    h.doubleSided = !1;
                    k = y.scene;
                    g = y.getFloor(e.floor);
                    null === g && (g = y.getFloor(y.currentFloorName));
                    null !== g && (k = ("undefined" !== typeof e.lod ? g.getLOD(e.lod) : g.floorContentLOD).contentNode);
                    k.add(h);
                    h.updateMatrixWorld(!0);
                    h.vg = {path: e};
                    a = new l(y, e, a, d, h, b, g.floorContentLOD);
                    g.floorContentLOD.pathObjects.push(a);
                    0 !== e.speed && e.visible && y.incrementUpdatableObjects();
                    e.visible && y.requestRedraw();
                    return a
                };
                this.addRoutingLink = function (a) {
                    a = a || {};
                    if ("undefined" === typeof a.startPoint ||
                        "undefined" === typeof a.endPoint) return !1;
                    var b = y.getFloor(a.startFloor || y.currentFloorName);
                    if (null === b) return !1;
                    var d = y.getFloor(a.endFloor || y.currentFloorName);
                    if (null === d) return !1;
                    var e = b.getPosition(), f = {x: a.startPoint.x, y: a.startPoint.y, z: a.startPoint.z || 0},
                        g = d.getPosition(), h = {x: a.endPoint.x, y: a.endPoint.y, z: a.endPoint.z || 0};
                    a = {
                        floor: b.name,
                        points: [f, {x: g.x - e.x + h.x, y: g.y - e.y + h.y, z: g.z - e.z + h.z}],
                        segments: 1,
                        url: a.url,
                        color: a.color,
                        repeat: a.repeat,
                        speed: a.speed,
                        thickness: a.thickness,
                        visible: a.visible,
                        opacity: a.opacity,
                        interpolationStart: a.interpolationStart,
                        interpolationEnd: a.interpolationEnd,
                        interpolationTextureLikeWindow: a.interpolationTextureLikeWindow,
                        overlay: a.overlay
                    };
                    if (a.points && 2 != a.points.length) return !1;
                    this.mustUpdateCameraObjects = !0;
                    a = this.addRoutingPrivatePath(a);
                    return !1 !== a ? (a.setLinkOptions({
                        cameraFacing: !0,
                        startFloor: b,
                        endFloor: d,
                        startPoint: f,
                        endPoint: h
                    }), this.addLink(a), a.getPublicLink()) : !1
                };
                this.recreateAndUpdateMeshFromPathGeometry = function (a, b, d) {
                    d = "undefined" === typeof d ?
                        !0 : d;
                    var e = b.parent;
                    e && e.remove(b);
                    var f = b.vg || {}, g = b.doubleSided || !1, h = b.material;
                    b.geometry.dispose();
                    b = new THREE.Mesh(a.clone(), h);
                    b.matrixAutoUpdate = !1;
                    b.renderDepth = f.path.overlay ? I.renderDepthPathOverlay : I.renderDepthPath;
                    0 < a.vertices.length && (b.renderDepth -= a.vertices[0].z);
                    b.vg = f;
                    b.doubleSided = g;
                    e && (e.add(b), b.updateMatrixWorld(!0));
                    b.traverse(function (a) {
                        a.visible = d
                    });
                    y.requestRedraw();
                    return b
                };
                this.plugin = function (a) {
                    return this.plugins[a]
                };
                this.incrementUpdatableObjects = function () {
                    ++this.nbUpdatableObjects;
                    this.requestContinuousUpdate(!0);
                    ib = !1
                };
                this.decrementUpdatableObjects = function () {
                    0 === this.nbUpdatableObjects ? E.log("ERROR INTERNAL: decrementUpdatableObjects below 0") : (--this.nbUpdatableObjects, 0 === this.nbUpdatableObjects && (this.requestContinuousUpdate(!1), ib = !0))
                };
                this.computeRoute = function (a) {
                    var b = jQuery.Deferred(), d = b.promise();
                    b.done(function (a, b) {
                        y.trigger("routeComputed", {request: a, data: b})
                    });
                    "undefined" !== typeof a.success && b.done(a.success);
                    "undefined" !== typeof a.error && b.fail(a.error);
                    if (void 0 !== a && void 0 !== a.src && void 0 !== a.dst) {
                        var e = {src: a.src, dst: a.dst},
                            f = ["computeNavigation", "language", "routingParameters", "navigationParameters"], g;
                        for (g in f) {
                            var h = f[g];
                            "undefined" !== typeof a[h] && (e[h] = a[h])
                        }
                        e.version = this.version;
                        e.sdk = "VisioWeb";
                        "#javascript" === y.getRoutingURL() && !1 !== this.routingSolver ? (e = this.routingSolver.computeRoute(a), e.sdkVersion = y.version, e.routingServerVersion = "javascript", 200 === e.status && a.computeNavigation && !1 !== this.navigationSolver && (e.navigation = this.navigationSolver.computeNavigation(e,
                            a.navigationParameters)), b.resolve(a, e)) : (a.src === a.dst && b.reject(a, "routeRequest invalid, src same as dst"), jQuery.jsonp({
                            url: Za,
                            callbackParameter: "callback",
                            dataType: "jsonp",
                            data: e,
                            success: function (d) {
                                E.log(d);
                                b.resolve(a, d)
                            },
                            error: function () {
                                b.reject(a, "error connecting to server?")
                            }
                        }))
                    } else b.reject(a, "routeRequest invalid, maybe missing src or dst");
                    return d
                };
                this.getRoutingModalities = function () {
                    return "undefined" !== typeof y.routingSolver && "#javascript" === y.getRoutingURL() ? y.routingSolver.getModalities() :
                        !1
                };
                this.getRoutingAttributes = function () {
                    return "undefined" !== typeof y.routingSolver && "#javascript" === y.getRoutingURL() ? y.routingSolver.getAttributes() : !1
                };
                this.getRoutingNode = function (a, b) {
                    return "undefined" !== typeof y.routingSolver && "#javascript" === y.getRoutingURL() ? y.routingSolver.getRoutingNode(a, b) : a
                };
                this.getLoaderStatistics = function () {
                    this.loaderStatistics.requestRedraw = !1 !== Pa ? !0 : !1;
                    return this.loaderStatistics
                };
                this.isLoaded = function () {
                    return 0 == this.loaderStatistics.models && 0 == this.loaderStatistics.textures
                };
                this.queryNearPlaces = function (a, b) {
                    return "undefined" !== typeof y.routingSolver && "#javascript" === y.getRoutingURL() ? y.routingSolver.queryNearPlaces(a, b) : []
                };
                this.start = function () {
                    Ta = !0;
                    ib ? y.requestRedraw() : y.requestContinuousUpdate(!0)
                };
                this.getFloors = function () {
                    if (!this.publicFloors) {
                        this.publicFloors = [];
                        for (var a = 0, b = Ha.length; a < b; a++) this.publicFloors.push(Ha[a].getPublicFloor());
                        this.publicFloors.sort(function (a, b) {
                            return "undefined" !== typeof a.heightMin && "undefined" !== typeof a.heightMax && "undefined" !==
                            typeof b.heightMin && "undefined" !== typeof b.heightMax ? a.heightMax + a.heightMin - (b.heightMax + b.heightMin) : 0
                        });
                        a = 0;
                        for (b = this.publicFloors.length; a < b; a++) this.publicFloors[a].index = a
                    }
                    return this.publicFloors
                };
                this.setPlaceName = function (a, b) {
                    this.deferredPoiLoading.active && (this.deferredPoiLoading.setPlaceName[a] = b);
                    var d = this.pois[a];
                    if ("undefined" !== typeof d) {
                        "undefined" === typeof b ? b = {text: ""} : "string" === typeof b && (b = {text: b});
                        for (var e in d) {
                            var f = d[e];
                            f.options("image") || f.options(b)
                        }
                    }
                };
                this.setPlaceIcon =
                    function (a, b) {
                        this.deferredPoiLoading.active && (this.deferredPoiLoading.setPlaceIcon[a] = b);
                        var d = this.pois[a];
                        if ("undefined" !== typeof d) {
                            "undefined" === typeof b ? b = {url: ""} : "string" === typeof b && (b = {url: b});
                            for (var e in d) {
                                var f = d[e];
                                f.options("image") || f.options(b)
                            }
                        }
                    };
                this.getPlace = function (a) {
                    return "undefined" !== typeof this.places[a] ? this.places[a] : !1
                };
                this.getFootprint = function (a) {
                    var b = this.publicFootprintsTable[a];
                    if ("undefined" !== typeof b) return b;
                    if ("undefined" !== typeof this.polygons_table[a] &&
                        0 < this.polygons_table[a].length) {
                        var d = (b = this.pois_floor_table[a]) ? b.floorName : void 0, e = this.polygons_table[a];
                        if (1 < e.length) for (var b = [], f = 0; f < e.length; f++) {
                            for (var g = e[f].points.split(/,/), h, k = [], l = 0, m = g.length; l < m; ++l) h = g[l].split(/ /), k.push(ja({
                                x: parseFloat(h[0]),
                                y: parseFloat(h[1])
                            }));
                            b.push({id: a, points: k, floor: d})
                        } else {
                            g = e[0].points.split(/,/);
                            k = [];
                            l = 0;
                            for (m = g.length; l < m; ++l) h = g[l].split(/ /), k.push(ja({
                                x: parseFloat(h[0]),
                                y: parseFloat(h[1])
                            }));
                            b = {id: a, points: k, floor: d}
                        }
                        return this.publicFootprintsTable[a] =
                            b
                    }
                    return !1
                };
                this.publicFootprintsTable = {};
                this.publicFootprintsTableInitialized = !1;
                this.getFootprints = function () {
                    if (!this.publicFootprintsTableInitialized) {
                        for (id in this.polygons_table) this.getFootprint(id);
                        this.publicFootprintsTableInitialized = !0
                    }
                    return this.publicFootprintsTable
                };
                this.getPoint = function (a) {
                    var b = this.publicPointsTable[a];
                    if (b) return b;
                    if ("undefined" !== typeof this.points_table[a]) {
                        var b = this.points_table[a], d = ja({x: parseFloat(b.x), y: parseFloat(b.y)}),
                            e = this.pois_floor_table[a], b =
                                {
                                    id: a,
                                    x: d.x,
                                    y: d.y,
                                    height: b.height,
                                    headingInDegrees: b.headingInDegrees,
                                    floor: e ? e.floorName : void 0
                                };
                        return this.publicPointsTable[a] = b
                    }
                    return !1
                };
                this.publicPointsTable = {};
                this.publicPointsTableInitialized = !1;
                this.getPoints = function () {
                    if (!this.publicPointsTableInitialized) {
                        for (id in this.points_table) this.getPoint(id);
                        this.publicPointsTableInitialized = !0
                    }
                    return this.publicPointsTable
                };
                this.getAllPlaces = function () {
                    return this.places
                };
                this.highlight = function (a, b) {
                    return a && a.highlight ? a.highlight(b) : !1
                };
                this.removeHighlight = function (a) {
                    var b = !1;
                    if ("undefined" === typeof a || !1 === a) return b;
                    if (a instanceof Array) for (var d in a) a.removeHighlight && (a[d].removeHighlight(), b = !0); else a.removeHighlight && (b = a.removeHighlight());
                    return b
                };
                this.getRoutingURL = function () {
                    return Za
                };
                this.setRoutingURL = function (a) {
                    Za = a
                };
                this.changeFloor = function (a, b) {
                    var d = jQuery.Deferred(), e = d.promise();
                    if ("undefined" === typeof a) d.reject(); else if (this.currentFloorName === a) d.resolve(); else {
                        if (!1 === y.trigger("floorWillChange", {
                                current: y.currentFloorName,
                                target: a
                            })) {
                            d.reject();
                            return
                        }
                        var f = y.currentFloorName;
                        d.done(function () {
                            y.trigger("floorChanged", {current: f, target: a})
                        });
                        var g = this.currentFloor, h = g.getLOD(y.current_lod);
                        if (h && !Zb) {
                            var k = this.getFloor(a), l = this.computeTargetLod(a), m = k.getLOD(l);
                            if (null === m && 0 !== k.lods.length) for (var n in k.lods) {
                                l = n;
                                m = k.lods[n];
                                break
                            }
                            Zb = !0;
                            y.incrementUpdatableObjects();
                            Ea(g, !0, k, b).done(function () {
                                g.setEnabled(!1);
                                h.setEnabled(!1);
                                k.setEnabled(!0);
                                m.setEnabled(!0);
                                y.currentFloorName = a;
                                y.currentFloor = k;
                                y.current_lod =
                                    l;
                                y.mustUpdateCameraObjects = !0;
                                Ea(k, !1, g, b).done(function () {
                                    y.mustUpdateCameraObjects = !0;
                                    y.decrementUpdatableObjects();
                                    y.requestRedraw();
                                    Zb = !1;
                                    d.resolve()
                                })
                            })
                        } else d.reject()
                    }
                    return e
                };
                this.resize = function (a, b) {
                    return this.resizeInternal(a, b, !0)
                };
                this.resizeInternal = function (a, b, d) {
                    this.viewportWidth = a;
                    this.viewportHeight = b;
                    Ja.update(this.viewportWidth, this.viewportHeight);
                    "undefined" !== typeof Ua && "undefined" !== typeof W && P(Ua * W.meters_per_pixel);
                    var e = this.camera;
                    e.aspect = this.viewportWidth / this.viewportHeight;
                    e instanceof THREE.OrthographicCamera ? (e.left = this.viewportWidth / -2, e.right = this.viewportWidth / 2, e.top = this.viewportHeight / 2, e.bottom = this.viewportHeight / -2, this.orthographicNormalizedZoom = this.viewportHeight / this.sideInMeters) : e.fov = Ja.fovY;
                    e.updateProjectionMatrix();
                    y.manipulator.update();
                    Aa.setSize(this.viewportWidth, this.viewportHeight);
                    jQuery(Aa.domElement).width(this.viewportWidth).height(this.viewportHeight);
                    La = null;
                    y.requestRedraw();
                    this.trigger("resize", {mapWidth: a, mapHeight: b}, !0);
                    d && this.render();
                    return !0
                };
                this.getCurrentFloor = function () {
                    return this.currentFloorName
                };
                this.getViewpointFromPositions = function (a) {
                    var b = a.top || 0, d = a.bottom || 0, e = a.left || 0, f = a.right || 0, g = a.points;
                    if ("undefined" === typeof g || !g.length) return !1;
                    var h, k, l = "number" === typeof a.pitch ? !0 : !1, m = "number" === typeof a.heading ? !0 : !1;
                    l && (h = this.publicCamera.pitch, this.publicCamera.pitch = a.pitch);
                    m && (k = this.publicCamera.heading, this.publicCamera.heading = a.heading);
                    a = !1;
                    if (l || m) a = function () {
                        l && (this.publicCamera.pitch = h);
                        m && (this.publicCamera.heading =
                            k)
                    }.bind(this);
                    var n = new THREE.Vector3(y.camera.matrix.elements[0], y.camera.matrix.elements[1], y.camera.matrix.elements[2]),
                        p = new THREE.Vector3(y.camera.matrix.elements[4], y.camera.matrix.elements[5], y.camera.matrix.elements[6]),
                        q = new THREE.Vector3(y.camera.matrix.elements[8], y.camera.matrix.elements[9], y.camera.matrix.elements[10]),
                        r = .5 * y.viewportWidth, t = .5 * y.viewportHeight, u = r / t, v;
                    v = Math.tan(THREE.Math.degToRad(.5 * y.camera.fov));
                    var u = v * u, w, x, z, B, D, A;
                    w = v * (t - b) / t;
                    x = -v * (t - d) / t;
                    z = u * (r - f) / r;
                    B = -u * (r -
                        e) / r;
                    u = .5 * (w + x);
                    v = .5 * (z + B);
                    D = w - x;
                    A = z - B;
                    for (var C in this.helpers) y.scene.remove(this.helpers[C]);
                    this.helpers = [];
                    if (1 === g.length) {
                        q = g[0];
                        if ("undefined" === typeof q || "undefined" === typeof q.x || "undefined" === typeof q.y) return a && a(), !1;
                        n = y.convertScreenToPoint({left: r + .5 * (e - f), top: t + .5 * (b - d)}, q.z || 0);
                        p = y.publicCamera.position;
                        q = {x: q.x - n.x + p.x, y: q.y - n.y + p.y, radius: p.radius};
                        a && a();
                        return q
                    }
                    var E = new THREE.Vector3(g[0].x, g[0].y, g[0].z || 0), F = E.clone();
                    C = 1;
                    for (t = g.length; C < t; ++C) r = g[C], E.x = Math.max(E.x, r.x),
                        E.y = Math.max(E.y, r.y), E.z = Math.max(E.z, r.z || 0), F.x = Math.min(F.x, r.x), F.y = Math.min(F.y, r.y), F.z = Math.min(F.z, r.z || 0);
                    r = new THREE.Vector3;
                    r.addVectors(F, E);
                    r.multiplyScalar(.5);
                    t = new THREE.Vector3(g[0].x, g[0].y, g[0].z || 0);
                    t.sub(r);
                    if (1E-6 > E.x - F.x && 1E-6 > E.y - F.y && 1E-6 > E.z - F.z) return q = this.getViewpointFromPositions({
                        points: [g[0]],
                        top: b,
                        bottom: d,
                        left: e,
                        right: f
                    }), a && a(), q;
                    if (y.camera instanceof THREE.OrthographicCamera) return a && a(), {
                        x: r.x,
                        y: r.y,
                        radius: Math.max(E.x - F.x, E.y - E.y)
                    };
                    var G, H, I, J, K, L, M, N, P, Q;
                    G = t.dot(q);
                    L = K = t.dot(p);
                    N = M = t.dot(n);
                    f = d = b = e = 0;
                    P = K + G * w;
                    Q = L + G * x;
                    E = M + G * z;
                    F = N + G * B;
                    for (C = 1; C < g.length; ++C) t = new THREE.Vector3(g[C].x, g[C].y, g[C].z || 0), t.sub(r), G = t.dot(q), I = H = t.dot(p), J = t = t.dot(n), H > K && (K = H, e = C), I < L && (L = I, b = C), J < N && (N = J, f = C), t > M && (M = t, d = C), H += G * w, I += G * x, t += G * z, J += G * B, P = Math.max(P, H), Q = Math.min(Q, I), E = Math.max(E, t), F = Math.min(F, J);
                    C = .5 * (P + Q);
                    w = .5 * (E + F);
                    D = (P - Q) / D;
                    A = (E - F) / A;
                    D > A ? (A = D, C = r.clone().add(p.clone().multiplyScalar(C - A * u)).add(n.clone().multiplyScalar(w - A * v)).add(q.clone().multiplyScalar(A)),
                        p = (new THREE.Vector3(g[f].x, g[f].y, g[f].z)).sub(C.clone().sub(q.clone().multiplyScalar(A))), u = (new THREE.Vector3(g[d].x, g[d].y, g[d].z)).sub(C.clone().sub(q.clone().multiplyScalar(A))), g = A - p.dot(q), A -= u.dot(q), p = p.dot(n), u = u.dot(n), p = (p * A + u * g - 2 * v * g * A) / (g + A), C.add(n.clone().multiplyScalar(p))) : (C = r.clone().add(p.clone().multiplyScalar(C - A * u)).add(n.clone().multiplyScalar(w - A * v)).add(q.clone().multiplyScalar(A)), n = (new THREE.Vector3(g[e].x, g[e].y, g[e].z)).sub(C.clone().sub(q.clone().multiplyScalar(A))),
                        v = (new THREE.Vector3(g[b].x, g[b].y, g[b].z)).sub(C.clone().sub(q.clone().multiplyScalar(A))), g = A - n.dot(q), A -= v.dot(q), n = n.dot(p), v = v.dot(p), n = (n * A + v * g - 2 * u * g * A) / (g + A), C.add(p.clone().multiplyScalar(n)));
                    n = C.z / q.z;
                    q = q.clone().multiplyScalar(C.z / q.z);
                    C.sub(q);
                    a && a();
                    return {x: C.x, y: C.y, radius: n}
                };
                this.notifications = new F;
                this.on = function (a, b) {
                    return this.notifications.on(a, b, !1)
                };
                this.once = function (a, b) {
                    return this.notifications.on(a, b, !0)
                };
                this.off = function (a, b) {
                    return this.notifications.off(a, b)
                };
                this.trigger =
                    function (a, b, d) {
                        return this.notifications.trigger(a, b, d)
                    };
                this.animateValue = function (a, b, d) {
                    var e;
                    if ("undefined" !== typeof d) {
                        a = parseFloat(a);
                        b = parseFloat(b);
                        d.duration = "undefined" !== typeof d.duration ? d.duration : 1E3;
                        if ("number" === typeof d.duration) {
                            e = (new TWEEN.Tween(a)).to(b, d.duration);
                            y.incrementUpdatableObjects();
                            if ("function" === typeof d.step) e.onUpdate(function (d) {
                                return function (e) {
                                    d(a + e * (b - a))
                                }
                            }(d.step));
                            e.onComplete(function (a) {
                                return function () {
                                    y.decrementUpdatableObjects();
                                    e.onStop(null);
                                    if ("function" === typeof a) {
                                        var b = function () {
                                            setTimeout(function () {
                                                a()
                                            }, 0);
                                            y.removePostRenderListener(b)
                                        };
                                        y.addPostRenderListener(b);
                                        y.requestRedraw()
                                    }
                                }
                            }(d.complete));
                            e.onStop(function (a) {
                                return function () {
                                    y.decrementUpdatableObjects();
                                    e.onStop(null);
                                    "function" === typeof a && a()
                                }
                            }(d.stop));
                            e.start();
                            return function (a) {
                                return {
                                    stop: function () {
                                        a.stop()
                                    }
                                }
                            }(e)
                        }
                        return !1
                    }
                };
                this.cameraNorthRotation = !1;
                Object.defineProperty(this, "isAccelerated", {
                    get: function () {
                        return !0
                    }
                });
                Object.defineProperty(this, "version",
                    {
                        get: function () {
                            return "1.8.2"
                        }
                    });
                Object.defineProperty(this, "minimumDataSDKVersion", {
                    get: function () {
                        return "1.4.0"
                    }
                });
                Object.defineProperty(this, "sdkType", {
                    get: function () {
                        return "web"
                    }
                });
                Object.defineProperty(this, "revision", {
                    get: function () {
                        return "468e7a3"
                    }
                });
                this.getExtraData = function () {
                    return this.extraData
                };
                this.getPois = function () {
                    return jQuery.extend({}, this.pois)
                };
                this.getPoi = function (a) {
                    return this.pois[a]
                };
                this.setup()
            };
            I.available_plugins = [];
            I.zOffsetPOI = .1;
            I.zOffsetPath = .1;
            I.renderDepthPOIOverlay =
                -4E5;
            I.renderDepthPathOverlay = -3E5;
            I.renderDepthPath = -2E5;
            I.renderDepthPOIFacing = -15E4;
            I.renderDepthPOI = -1E5;
            return I
        });
    define("com/visioglobe/web/Mapviewer", ["require", "com/visioglobe/web/MapviewerPrivate"], function (a) {
        var b = a("com/visioglobe/web/MapviewerPrivate");
        return function () {
            var a = new b, e = {
                initialize: !0,
                start: !0,
                getFloors: !0,
                setPlaceName: !0,
                setPlaceIcon: !0,
                getPlace: !0,
                getAllPlaces: !0,
                getPoi: !0,
                getPois: !0,
                highlight: !0,
                removeHighlight: !0,
                computeRoute: !0,
                getRoutingURL: !0,
                setRoutingURL: !0,
                changeFloor: !0,
                resize: !0,
                getCurrentFloor: !0,
                getExtraData: !0,
                getRoutingAttributes: !0,
                getRoutingModalities: !0,
                getRoutingNode: !0,
                queryNearPlaces: !0,
                getViewpointFromPositions: !0,
                convertLatLonToPoint: !0,
                convertPointToLatLon: !0,
                offsetPosition: !0,
                computeHeadingAngle: !0,
                computeDistance: !0,
                initializeProjection: !0,
                addPOI: !0,
                addRoutingPath: !0,
                addRoutingLink: !0,
                convertScreenToPoint: !0,
                convertPointToScreen: !0,
                addPostRenderListener: !0,
                removePostRenderListener: !0,
                plugin: !0,
                getFootprint: !0,
                getFootprints: !0,
                getPoint: !0,
                getPoints: !0,
                setAutoUpdateLOD: !0,
                on: !0,
                once: !0,
                off: !0,
                trigger: !0,
                animateValue: !0,
                getLoaderStatistics: !0,
                isLoaded: !0,
                requestRedraw: !0
            };
            Object.defineProperty(this, "lodFactor", {
                get: function () {
                    return a.publicLodFactor
                }, set: function (b) {
                    0 >= b || (a.publicLodFactor = b, a.manipulator.update())
                }
            });
            Object.defineProperty(this, "camera", {
                get: function () {
                    return a.publicCamera
                }
            });
            Object.defineProperty(this, "cameraNorthRotation", {
                get: function () {
                    return a.cameraNorthRotation
                }
            });
            Object.defineProperty(this, "isAccelerated", {
                get: function () {
                    return a.isAccelerated
                }
            });
            Object.defineProperty(this, "version", {
                get: function () {
                    return a.version
                }
            });
            Object.defineProperty(this,
                "minimumDataSDKVersion", {
                    get: function () {
                        return a.minimumDataSDKVersion
                    }
                });
            Object.defineProperty(this, "sdkType", {
                get: function () {
                    return a.sdkType
                }
            });
            Object.defineProperty(this, "revision", {
                get: function () {
                    return a.revision
                }
            });
            Object.defineProperty(this, "frameRateDivider", {
                get: function () {
                    return a.frameRateDivider
                }, set: function (b) {
                    0 >= b || (a.frameRateDivider = b)
                }
            });
            for (var f in e) {
                var h = f, g = e[f];
                "undefined" !== typeof a[h] && function (b, e, f) {
                    b[e] = !0 !== f ? function () {
                        return f.apply(b, arguments)
                    } : function () {
                        return a[e].apply(a,
                            arguments)
                    }
                }(this, h, g)
            }
            return this
        }
    });
    define("text!com/visioglobe/web/shaders/gradient.frag", [], function () {
        return "uniform vec3 spots[NB_SPOTS];varying vec3 vPos;uniform vec4 gradient[NB_GRADIENTS];float a(float b,float c,float d,float e,float f){return e+(b-c)*(f-e)/(d-c);}vec3 g(float h){h=clamp(h,gradient[0].w,gradient[NB_GRADIENTS-1].w);vec3 i;for(int j=0;j<NB_GRADIENTS-1;++j){if(h>=gradient[j].w&&h<=gradient[j+1].w){h=a(h,gradient[j].w,gradient[j+1].w,0.0,1.0);vec3 k=gradient[j].xyz;vec3 l=gradient[j+1].xyz;i=mix(k,l,h);}}return i;}void main(){vec2 m=vPos.xy;float n=0.0;float o[NB_SPOTS];for(int j=0;j<NB_SPOTS;++j){vec2 p=spots[j].xy-m;float q=sqrt(p.x*p.x+p.y*p.y);float r=1.0/pow(q,1.0);n+=r;o[j]=r*spots[j].z;}float s=0.0;for(int j=0;j<NB_SPOTS;++j){s+=o[j]/n;}vec3 i=g(s);gl_FragColor=vec4(i.rgb,1.0);}"
    });
    define("text!com/visioglobe/web/shaders/gradient.vert", [], function () {
        return "varying vec3 vPos;void main(){vPos=position;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}"
    });
    define("com/visioglobe/web/plugins/GradientPlugin", ["require", "com/visioglobe/web/MapviewerPrivate", "text!com/visioglobe/web/shaders/gradient.frag", "text!com/visioglobe/web/shaders/gradient.vert"], function (a) {
        var b = a("com/visioglobe/web/MapviewerPrivate"), d = a("text!com/visioglobe/web/shaders/gradient.frag"),
            e = a("text!com/visioglobe/web/shaders/gradient.vert");
        b.available_plugins.push({
            name: "gradient", factory: function (a) {
                function b(a, d) {
                    a = THREE.Math.clamp(a, d[0].parameter, d[d.length - 1].parameter);
                    for (var e = 0; e < d.length - 1 && !(a <= d[e + 1].parameter);) ++e;
                    a = THREE.Math.mapLinear(a, d[e].parameter, d[e + 1].parameter, 0, 1);
                    var f = new THREE.Color(d[e].value), e = new THREE.Color(d[e + 1].value);
                    return f.lerp(e, a)
                }

                function g() {
                    for (var a in this.parameters.gradient) {
                        var b = new THREE.Color(this.parameters.gradient[a].value);
                        l.push(new THREE.Vector4(b.r, b.g, b.b, this.parameters.gradient[a].parameter))
                    }
                }

                var k = {}, l = [];
                this.initialize = function (b) {
                    console.log("Running gradient plugin");
                    this.parameters = b;
                    this.inverse_lookup =
                        {};
                    for (var h in this.parameters.spots_lookup) {
                        b = this.parameters.spots_lookup[h];
                        for (var q in b) this.inverse_lookup[b[q].id] = {id: h}
                    }
                    g.apply(this);
                    for (h in this.parameters.spots_lookup) {
                        b = this.parameters.spots_lookup[h];
                        var p = a.places_list[h];
                        if ("undefined" !== typeof p) for (var r in p) {
                            var v = p[r], u = [], x;
                            for (x in b) {
                                q = b[x].id;
                                var w = a.pois[q];
                                "undefined" !== typeof w && 1 === w.length && (w = w[0], w = w.options("position"), this.inverse_lookup[q].index = u.length, u.push(new THREE.Vector3(w.x, w.y, 0)))
                            }
                            if (1 === b.length) v.material.vertexColors =
                                THREE.NoColors; else if (1 < b.length) {
                                q = v;
                                w = u.length;
                                if ("undefined" !== typeof k[w]) w = k[w]; else var z = new THREE.ShaderMaterial({
                                    defines: {
                                        NB_SPOTS: w,
                                        NB_GRADIENTS: l.length
                                    },
                                    uniforms: {spots: {type: "v3v", value: []}, gradient: {type: "v4v", value: l}},
                                    depthWrite: !0,
                                    vertexShader: e,
                                    fragmentShader: d
                                }), w = k[w] = z;
                                q.material = w.clone();
                                v.material.uniforms.gradient.value = l;
                                v.material.uniforms.spots.value = u
                            }
                        }
                    }
                    "undefined" !== typeof this.parameters.spots && this.updateSpots(this.parameters.spots);
                    a.requestRedraw()
                };
                this.updateSpots =
                    function (d) {
                        if ("undefined" === typeof this.inverse_lookup) return !1;
                        for (var e in d) {
                            var g = this.inverse_lookup[e];
                            if ("undefined" !== typeof g) {
                                var k = g.id, l = this.parameters.spots_lookup[k].length, k = a.places_list[k];
                                if ("undefined" !== typeof k) for (var v in k) {
                                    var u = k[v];
                                    if (1 === l) {
                                        var x = b(parseFloat(d[e].value), this.parameters.gradient);
                                        "undefined" !== typeof d[e].duration && 0 < d[e].duration ? (a.incrementUpdatableObjects(), (new TWEEN.Tween(u.material.color)).to(x, parseFloat(d[e].duration)).onComplete(function () {
                                                a.decrementUpdatableObjects()
                                            }).start()) :
                                            u.material.color.copy(x)
                                    } else 1 < l && ("undefined" !== typeof d[e].duration && 0 < d[e].duration ? (a.incrementUpdatableObjects(), (new TWEEN.Tween(u.material.uniforms.spots.value[g.index])).to({z: parseFloat(d[e].value)}, parseFloat(d[e].duration)).onComplete(function () {
                                        a.decrementUpdatableObjects()
                                    }).start()) : u.material.uniforms.spots.value[g.index].z = parseFloat(d[e].value))
                                }
                            }
                        }
                        a.requestRedraw();
                        return !0
                    };
                this.updateGradient = function (b) {
                    this.parameters.gradient = b;
                    l.splice(0, l.length);
                    g.apply(this);
                    for (var d in k) k[d].defines.NB_GRADIENTS =
                        l.length;
                    for (var e in this.parameters.spots_lookup) {
                        b = this.parameters.spots_lookup[e];
                        var h = a.places_list[e];
                        if ("undefined" !== typeof h) for (d in h) {
                            var r = h[d];
                            1 !== b.length && (r.material.needsUpdate = !0)
                        }
                    }
                    a.requestRedraw()
                }
            }
        })
    });
    define("com/visioglobe/web/plugins/IconsPlugin", ["require", "com/visioglobe/web/MapviewerPrivate", "com/visioglobe/web/helpers/CachedTexture"], function (a) {
        var b = a("com/visioglobe/web/MapviewerPrivate"), d = a("com/visioglobe/web/helpers/CachedTexture");
        b.available_plugins.push({
            name: "icons", factory: function (a) {
                this.loadAsset = function (b) {
                    new d(a, b, !0)
                }
            }
        })
    });
    define("com/visioglobe/web/plugins/PoiPlugin", ["require", "com/visioglobe/web/MapviewerPrivate"], function (a) {
        a("com/visioglobe/web/MapviewerPrivate").available_plugins.push({
            name: "poi", factory: function (a) {
                this.getPois = function () {
                    return a.getPois()
                };
                this.getPoi = function (d) {
                    return a.getPoi(d)
                }
            }
        })
    });
    var vg = vg || {};
    (function () {
        var a = new function () {
            var a = 0;
            "undefined" !== typeof jQuery && jQuery.holdReady(!0);
            this.wait = function () {
                ++a
            };
            this.go = function () {
                --a;
                0 === a && "undefined" !== typeof jQuery && jQuery.holdReady(!1)
            }
        };
        a.wait();
        require(["com/visioglobe/web/plugins/GradientPlugin"], function () {
            a.go()
        });
        a.wait();
        require(["com/visioglobe/web/plugins/IconsPlugin"], function () {
            a.go()
        });
        a.wait();
        require(["com/visioglobe/web/plugins/PoiPlugin"], function () {
            a.go()
        });
        a.wait();
        require(["com/visioglobe/web/Mapviewer"], function (b) {
            vg.mapviewer =
                vg.mapviewer || {};
            vg.mapviewer.web = vg.mapviewer.web || {};
            vg.mapviewer.web.Mapviewer = b;
            vg.mapviewer.Mapviewer = vg.mapviewer.Mapviewer || b;
            a.go()
        })
    })();
    define("com/visioglobe/web/main", function () {
    });
    return vg;

    /* without requirejs */
})(vg);

/* with requirejs (uncomment next line, comment line above) */
//});
// module.exports =  vg;
///* end Visioglobe SDK*/
